<html>
<head>
<title>PlainValue-ec8e588e.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8ea765;}
.s1 { color: #cc7832;}
.s2 { color: #cfd2d5;}
.s3 { color: #cc7832; font-weight: bold;}
.s4 { color: #6897bb;}
.s5 { color: #8a8a8a; font-style: italic;}
.s6 { color: #8a8a8a; font-weight: bold; font-style: italic;}
.s7 { color: #808080;}
</style>
</head>
<body bgcolor="#1c1c1c">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
PlainValue-ec8e588e.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s3">const </span><span class="s2">Char = {</span>
  <span class="s2">ANCHOR: </span><span class="s0">'&amp;'</span><span class="s1">,</span>
  <span class="s2">COMMENT: </span><span class="s0">'#'</span><span class="s1">,</span>
  <span class="s2">TAG: </span><span class="s0">'!'</span><span class="s1">,</span>
  <span class="s2">DIRECTIVES_END: </span><span class="s0">'-'</span><span class="s1">,</span>
  <span class="s2">DOCUMENT_END: </span><span class="s0">'.'</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">Type = {</span>
  <span class="s2">ALIAS: </span><span class="s0">'ALIAS'</span><span class="s1">,</span>
  <span class="s2">BLANK_LINE: </span><span class="s0">'BLANK_LINE'</span><span class="s1">,</span>
  <span class="s2">BLOCK_FOLDED: </span><span class="s0">'BLOCK_FOLDED'</span><span class="s1">,</span>
  <span class="s2">BLOCK_LITERAL: </span><span class="s0">'BLOCK_LITERAL'</span><span class="s1">,</span>
  <span class="s2">COMMENT: </span><span class="s0">'COMMENT'</span><span class="s1">,</span>
  <span class="s2">DIRECTIVE: </span><span class="s0">'DIRECTIVE'</span><span class="s1">,</span>
  <span class="s2">DOCUMENT: </span><span class="s0">'DOCUMENT'</span><span class="s1">,</span>
  <span class="s2">FLOW_MAP: </span><span class="s0">'FLOW_MAP'</span><span class="s1">,</span>
  <span class="s2">FLOW_SEQ: </span><span class="s0">'FLOW_SEQ'</span><span class="s1">,</span>
  <span class="s2">MAP: </span><span class="s0">'MAP'</span><span class="s1">,</span>
  <span class="s2">MAP_KEY: </span><span class="s0">'MAP_KEY'</span><span class="s1">,</span>
  <span class="s2">MAP_VALUE: </span><span class="s0">'MAP_VALUE'</span><span class="s1">,</span>
  <span class="s2">PLAIN: </span><span class="s0">'PLAIN'</span><span class="s1">,</span>
  <span class="s2">QUOTE_DOUBLE: </span><span class="s0">'QUOTE_DOUBLE'</span><span class="s1">,</span>
  <span class="s2">QUOTE_SINGLE: </span><span class="s0">'QUOTE_SINGLE'</span><span class="s1">,</span>
  <span class="s2">SEQ: </span><span class="s0">'SEQ'</span><span class="s1">,</span>
  <span class="s2">SEQ_ITEM: </span><span class="s0">'SEQ_ITEM'</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">defaultTagPrefix = </span><span class="s0">'tag:yaml.org,2002:'</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">defaultTags = {</span>
  <span class="s2">MAP: </span><span class="s0">'tag:yaml.org,2002:map'</span><span class="s1">,</span>
  <span class="s2">SEQ: </span><span class="s0">'tag:yaml.org,2002:seq'</span><span class="s1">,</span>
  <span class="s2">STR: </span><span class="s0">'tag:yaml.org,2002:str'</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">findLineStarts(src) {</span>
  <span class="s3">const </span><span class="s2">ls = [</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">offset = src.indexOf(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>

  <span class="s3">while </span><span class="s2">(offset !== -</span><span class="s4">1</span><span class="s2">) {</span>
    <span class="s2">offset += </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">ls.push(offset)</span><span class="s1">;</span>
    <span class="s2">offset = src.indexOf(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">, </span><span class="s2">offset)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">ls</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">getSrcInfo(cst) {</span>
  <span class="s3">let </span><span class="s2">lineStarts</span><span class="s1">, </span><span class="s2">src</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">cst === </span><span class="s0">'string'</span><span class="s2">) {</span>
    <span class="s2">lineStarts = findLineStarts(cst)</span><span class="s1">;</span>
    <span class="s2">src = cst</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
    <span class="s3">if </span><span class="s2">(Array.isArray(cst)) cst = cst[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(cst &amp;&amp; cst.context) {</span>
      <span class="s3">if </span><span class="s2">(!cst.lineStarts) cst.lineStarts = findLineStarts(cst.context.src)</span><span class="s1">;</span>
      <span class="s2">lineStarts = cst.lineStarts</span><span class="s1">;</span>
      <span class="s2">src = cst.context.src</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">{</span>
    <span class="s2">lineStarts</span><span class="s1">,</span>
    <span class="s2">src</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* </span><span class="s6">@typedef </span><span class="s5">{Object} LinePos - One-indexed position in the source</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} line</span>
 <span class="s5">* </span><span class="s6">@property </span><span class="s5">{number} col</span>
 <span class="s5">*/</span>

<span class="s5">/**</span>
 <span class="s5">* Determine the line/col position matching a character offset.</span>
 <span class="s5">*</span>
 <span class="s5">* Accepts a source string or a CST document as the second parameter. With</span>
 <span class="s5">* the latter, starting indices for lines are cached in the document as</span>
 <span class="s5">* `lineStarts: number[]`.</span>
 <span class="s5">*</span>
 <span class="s5">* Returns a one-indexed `{ line, col }` location if found, or</span>
 <span class="s5">* `undefined` otherwise.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} offset</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string|Document|Document[]} cst</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{?LinePos}</span>
 <span class="s5">*/</span>


<span class="s3">function </span><span class="s2">getLinePos(offset</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">offset !== </span><span class="s0">'number' </span><span class="s2">|| offset &lt; </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">lineStarts</span><span class="s1">,</span>
    <span class="s2">src</span>
  <span class="s2">} = getSrcInfo(cst)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(!lineStarts || !src || offset &gt; src.length) </span><span class="s3">return null</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; lineStarts.length</span><span class="s1">; </span><span class="s2">++i) {</span>
    <span class="s3">const </span><span class="s2">start = lineStarts[i]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(offset &lt; start) {</span>
      <span class="s3">return </span><span class="s2">{</span>
        <span class="s2">line: i</span><span class="s1">,</span>
        <span class="s2">col: offset - lineStarts[i - </span><span class="s4">1</span><span class="s2">] + </span><span class="s4">1</span>
      <span class="s2">}</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(offset === start) </span><span class="s3">return </span><span class="s2">{</span>
      <span class="s2">line: i + </span><span class="s4">1</span><span class="s1">,</span>
      <span class="s2">col: </span><span class="s4">1</span>
    <span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">line = lineStarts.length</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">{</span>
    <span class="s2">line</span><span class="s1">,</span>
    <span class="s2">col: offset - lineStarts[line - </span><span class="s4">1</span><span class="s2">] + </span><span class="s4">1</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Get a specified line from the source.</span>
 <span class="s5">*</span>
 <span class="s5">* Accepts a source string or a CST document as the second parameter. With</span>
 <span class="s5">* the latter, starting indices for lines are cached in the document as</span>
 <span class="s5">* `lineStarts: number[]`.</span>
 <span class="s5">*</span>
 <span class="s5">* Returns the line as a string if found, or `null` otherwise.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} line One-indexed line number</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string|Document|Document[]} cst</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{?string}</span>
 <span class="s5">*/</span>

<span class="s3">function </span><span class="s2">getLine(line</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">lineStarts</span><span class="s1">,</span>
    <span class="s2">src</span>
  <span class="s2">} = getSrcInfo(cst)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(!lineStarts || !(line &gt;= </span><span class="s4">1</span><span class="s2">) || line &gt; lineStarts.length) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">start = lineStarts[line - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">end = lineStarts[line]</span><span class="s1">; </span><span class="s7">// undefined for last line; that's ok for slice()</span>

  <span class="s3">while </span><span class="s2">(end &amp;&amp; end &gt; start &amp;&amp; src[end - </span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) --end</span><span class="s1">;</span>

  <span class="s3">return </span><span class="s2">src.slice(start</span><span class="s1">, </span><span class="s2">end)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s5">/**</span>
 <span class="s5">* Pretty-print the starting line from the source indicated by the range `pos`</span>
 <span class="s5">*</span>
 <span class="s5">* Trims output to `maxWidth` chars while keeping the starting column visible,</span>
 <span class="s5">* using `…` at either end to indicate dropped characters.</span>
 <span class="s5">*</span>
 <span class="s5">* Returns a two-line string (or `null`) with `\n` as separator; the second line</span>
 <span class="s5">* will hold appropriately indented `^` marks indicating the column range.</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{Object} pos</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{LinePos} pos.start</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{LinePos} [pos.end]</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string|Document|Document[]*} cst</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} [maxWidth=80]</span>
 <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{?string}</span>
 <span class="s5">*/</span>

<span class="s3">function </span><span class="s2">getPrettyContext({</span>
  <span class="s2">start</span><span class="s1">,</span>
  <span class="s2">end</span>
<span class="s2">}</span><span class="s1">, </span><span class="s2">cst</span><span class="s1">, </span><span class="s2">maxWidth = </span><span class="s4">80</span><span class="s2">) {</span>
  <span class="s3">let </span><span class="s2">src = getLine(start.line</span><span class="s1">, </span><span class="s2">cst)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(!src) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">{</span>
    <span class="s2">col</span>
  <span class="s2">} = start</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(src.length &gt; maxWidth) {</span>
    <span class="s3">if </span><span class="s2">(col &lt;= maxWidth - </span><span class="s4">10</span><span class="s2">) {</span>
      <span class="s2">src = src.substr(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">maxWidth - </span><span class="s4">1</span><span class="s2">) + </span><span class="s0">'…'</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">const </span><span class="s2">halfWidth = Math.round(maxWidth / </span><span class="s4">2</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(src.length &gt; col + halfWidth) src = src.substr(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">col + halfWidth - </span><span class="s4">1</span><span class="s2">) + </span><span class="s0">'…'</span><span class="s1">;</span>
      <span class="s2">col -= src.length - maxWidth</span><span class="s1">;</span>
      <span class="s2">src = </span><span class="s0">'…' </span><span class="s2">+ src.substr(</span><span class="s4">1 </span><span class="s2">- maxWidth)</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">let </span><span class="s2">errLen = </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">errEnd = </span><span class="s0">''</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(end) {</span>
    <span class="s3">if </span><span class="s2">(end.line === start.line &amp;&amp; col + (end.col - start.col) &lt;= maxWidth + </span><span class="s4">1</span><span class="s2">) {</span>
      <span class="s2">errLen = end.col - start.col</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s2">errLen = Math.min(src.length + </span><span class="s4">1</span><span class="s1">, </span><span class="s2">maxWidth) - col</span><span class="s1">;</span>
      <span class="s2">errEnd = </span><span class="s0">'…'</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">offset = col &gt; </span><span class="s4">1 </span><span class="s2">? </span><span class="s0">' '</span><span class="s2">.repeat(col - </span><span class="s4">1</span><span class="s2">) : </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">err = </span><span class="s0">'^'</span><span class="s2">.repeat(errLen)</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s0">`</span><span class="s2">${src}</span><span class="s1">\n</span><span class="s2">${offset}${err}${errEnd}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">class </span><span class="s2">Range {</span>
  <span class="s3">static </span><span class="s2">copy(orig) {</span>
    <span class="s3">return new </span><span class="s2">Range(orig.start</span><span class="s1">, </span><span class="s2">orig.end)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">constructor(start</span><span class="s1">, </span><span class="s2">end) {</span>
    <span class="s3">this</span><span class="s2">.start = start</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.end = end || start</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">isEmpty() {</span>
    <span class="s3">return typeof this</span><span class="s2">.start !== </span><span class="s0">'number' </span><span class="s2">|| !</span><span class="s3">this</span><span class="s2">.end || </span><span class="s3">this</span><span class="s2">.end &lt;= </span><span class="s3">this</span><span class="s2">.start</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s5">/**</span>
   <span class="s5">* Set `origStart` and `origEnd` to point to the original source range for</span>
   <span class="s5">* this node, which may differ due to dropped CR characters.</span>
   <span class="s5">*</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number[]} cr - Positions of dropped CR characters</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} offset - Starting index of `cr` from the last call</span>
   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} - The next offset, matching the one found for `origStart`</span>
   <span class="s5">*/</span>


  <span class="s2">setOrigRange(cr</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">start</span><span class="s1">,</span>
      <span class="s2">end</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(cr.length === </span><span class="s4">0 </span><span class="s2">|| end &lt;= cr[</span><span class="s4">0</span><span class="s2">]) {</span>
      <span class="s3">this</span><span class="s2">.origStart = start</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s2">.origEnd = end</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">let </span><span class="s2">i = offset</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(i &lt; cr.length) {</span>
      <span class="s3">if </span><span class="s2">(cr[i] &gt; start) </span><span class="s3">break</span><span class="s1">;</span><span class="s3">else </span><span class="s2">++i</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">this</span><span class="s2">.origStart = start + i</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">nextOffset = i</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(i &lt; cr.length) {</span>
      <span class="s7">// if end was at \n, it should now be at \r</span>
      <span class="s3">if </span><span class="s2">(cr[i] &gt;= end) </span><span class="s3">break</span><span class="s1">;</span><span class="s3">else </span><span class="s2">++i</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">this</span><span class="s2">.origEnd = end + i</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">nextOffset</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s5">/** Root class of all nodes */</span>

<span class="s3">class </span><span class="s2">Node {</span>
  <span class="s3">static </span><span class="s2">addStringTerminator(src</span><span class="s1">, </span><span class="s2">offset</span><span class="s1">, </span><span class="s2">str) {</span>
    <span class="s3">if </span><span class="s2">(str[str.length - </span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">str</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">next = Node.endOfWhiteSpace(src</span><span class="s1">, </span><span class="s2">offset)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">next &gt;= src.length || src[next] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">? str + </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">: str</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s7">// ^(---|...)</span>


  <span class="s3">static </span><span class="s2">atDocumentBoundary(src</span><span class="s1">, </span><span class="s2">offset</span><span class="s1">, </span><span class="s2">sep) {</span>
    <span class="s3">const </span><span class="s2">ch0 = src[offset]</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(!ch0) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">prev = src[offset - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(prev &amp;&amp; prev !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) </span><span class="s3">return false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(sep) {</span>
      <span class="s3">if </span><span class="s2">(ch0 !== sep) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">if </span><span class="s2">(ch0 !== Char.DIRECTIVES_END &amp;&amp; ch0 !== Char.DOCUMENT_END) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">const </span><span class="s2">ch1 = src[offset + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">ch2 = src[offset + </span><span class="s4">2</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(ch1 !== ch0 || ch2 !== ch0) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">ch3 = src[offset + </span><span class="s4">3</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">!ch3 || ch3 === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">|| ch3 === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">' </span><span class="s2">|| ch3 === </span><span class="s0">' '</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">static </span><span class="s2">endOfIdentifier(src</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s3">let </span><span class="s2">ch = src[offset]</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">isVerbatim = ch === </span><span class="s0">'&lt;'</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">notOk = isVerbatim ? [</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s1">, </span><span class="s0">' '</span><span class="s1">, </span><span class="s0">'&gt;'</span><span class="s2">] : [</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s1">, </span><span class="s0">' '</span><span class="s1">, </span><span class="s0">'['</span><span class="s1">, </span><span class="s0">']'</span><span class="s1">, </span><span class="s0">'{'</span><span class="s1">, </span><span class="s0">'}'</span><span class="s1">, </span><span class="s0">','</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(ch &amp;&amp; notOk.indexOf(ch) === -</span><span class="s4">1</span><span class="s2">) ch = src[offset += </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(isVerbatim &amp;&amp; ch === </span><span class="s0">'&gt;'</span><span class="s2">) offset += </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">static </span><span class="s2">endOfIndent(src</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s3">let </span><span class="s2">ch = src[offset]</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(ch === </span><span class="s0">' '</span><span class="s2">) ch = src[offset += </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">static </span><span class="s2">endOfLine(src</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s3">let </span><span class="s2">ch = src[offset]</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(ch &amp;&amp; ch !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) ch = src[offset += </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">static </span><span class="s2">endOfWhiteSpace(src</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s3">let </span><span class="s2">ch = src[offset]</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(ch === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">' </span><span class="s2">|| ch === </span><span class="s0">' '</span><span class="s2">) ch = src[offset += </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">static </span><span class="s2">startOfLine(src</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s3">let </span><span class="s2">ch = src[offset - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(ch === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(ch &amp;&amp; ch !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) ch = src[offset -= </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s2">offset + </span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s5">/**</span>
   <span class="s5">* End of indentation, or null if the line's indent level is not more</span>
   <span class="s5">* than `indent`</span>
   <span class="s5">*</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{string} src</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} indent</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} lineStart</span>
   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{?number}</span>
   <span class="s5">*/</span>


  <span class="s3">static </span><span class="s2">endOfBlockIndent(src</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">lineStart) {</span>
    <span class="s3">const </span><span class="s2">inEnd = Node.endOfIndent(src</span><span class="s1">, </span><span class="s2">lineStart)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(inEnd &gt; lineStart + indent) {</span>
      <span class="s3">return </span><span class="s2">inEnd</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">const </span><span class="s2">wsEnd = Node.endOfWhiteSpace(src</span><span class="s1">, </span><span class="s2">inEnd)</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">ch = src[wsEnd]</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(!ch || ch === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">wsEnd</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">static </span><span class="s2">atBlank(src</span><span class="s1">, </span><span class="s2">offset</span><span class="s1">, </span><span class="s2">endAsBlank) {</span>
    <span class="s3">const </span><span class="s2">ch = src[offset]</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">ch === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">|| ch === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">' </span><span class="s2">|| ch === </span><span class="s0">' ' </span><span class="s2">|| endAsBlank &amp;&amp; !ch</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">static </span><span class="s2">nextNodeIsIndented(ch</span><span class="s1">, </span><span class="s2">indentDiff</span><span class="s1">, </span><span class="s2">indicatorAsIndent) {</span>
    <span class="s3">if </span><span class="s2">(!ch || indentDiff &lt; </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(indentDiff &gt; </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">indicatorAsIndent &amp;&amp; ch === </span><span class="s0">'-'</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s7">// should be at line or string end, or at next non-whitespace char</span>


  <span class="s3">static </span><span class="s2">normalizeOffset(src</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s3">const </span><span class="s2">ch = src[offset]</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">!ch ? offset : ch !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">&amp;&amp; src[offset - </span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">? offset - </span><span class="s4">1 </span><span class="s2">: Node.endOfWhiteSpace(src</span><span class="s1">, </span><span class="s2">offset)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s7">// fold single newline into space, multiple newlines to N - 1 newlines</span>
  <span class="s7">// presumes src[offset] === '\n'</span>


  <span class="s3">static </span><span class="s2">foldNewline(src</span><span class="s1">, </span><span class="s2">offset</span><span class="s1">, </span><span class="s2">indent) {</span>
    <span class="s3">let </span><span class="s2">inCount = </span><span class="s4">0</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">error = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">fold = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">ch = src[offset + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(ch === </span><span class="s0">' ' </span><span class="s2">|| ch === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">' </span><span class="s2">|| ch === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s3">switch </span><span class="s2">(ch) {</span>
        <span class="s3">case </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">:</span>
          <span class="s2">inCount = </span><span class="s4">0</span><span class="s1">;</span>
          <span class="s2">offset += </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s2">fold += </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">:</span>
          <span class="s3">if </span><span class="s2">(inCount &lt;= indent) error = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s2">offset = Node.endOfWhiteSpace(src</span><span class="s1">, </span><span class="s2">offset + </span><span class="s4">2</span><span class="s2">) - </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s0">' '</span><span class="s2">:</span>
          <span class="s2">inCount += </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s2">offset += </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">ch = src[offset + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(!fold) fold = </span><span class="s0">' '</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(ch &amp;&amp; inCount &lt;= indent) error = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">{</span>
      <span class="s2">fold</span><span class="s1">,</span>
      <span class="s2">offset</span><span class="s1">,</span>
      <span class="s2">error</span>
    <span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">constructor(type</span><span class="s1">, </span><span class="s2">props</span><span class="s1">, </span><span class="s2">context) {</span>
    <span class="s2">Object.defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s0">'context'</span><span class="s1">, </span><span class="s2">{</span>
      <span class="s2">value: context || </span><span class="s3">null</span><span class="s1">,</span>
      <span class="s2">writable: </span><span class="s3">true</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.error = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.range = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.valueRange = </span><span class="s3">null</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.props = props || []</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.type = type</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.value = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">getPropValue(idx</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">skipKey) {</span>
    <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.context) </span><span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">src</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.context</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">prop = </span><span class="s3">this</span><span class="s2">.props[idx]</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">prop &amp;&amp; src[prop.start] === key ? src.slice(prop.start + (skipKey ? </span><span class="s4">1 </span><span class="s2">: </span><span class="s4">0</span><span class="s2">)</span><span class="s1">, </span><span class="s2">prop.end) : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get anchor() {</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; </span><span class="s3">this</span><span class="s2">.props.length</span><span class="s1">; </span><span class="s2">++i) {</span>
      <span class="s3">const </span><span class="s2">anchor = </span><span class="s3">this</span><span class="s2">.getPropValue(i</span><span class="s1">, </span><span class="s2">Char.ANCHOR</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(anchor != </span><span class="s3">null</span><span class="s2">) </span><span class="s3">return </span><span class="s2">anchor</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get comment() {</span>
    <span class="s3">const </span><span class="s2">comments = []</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; </span><span class="s3">this</span><span class="s2">.props.length</span><span class="s1">; </span><span class="s2">++i) {</span>
      <span class="s3">const </span><span class="s2">comment = </span><span class="s3">this</span><span class="s2">.getPropValue(i</span><span class="s1">, </span><span class="s2">Char.COMMENT</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(comment != </span><span class="s3">null</span><span class="s2">) comments.push(comment)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">comments.length &gt; </span><span class="s4">0 </span><span class="s2">? comments.join(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) : </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">commentHasRequiredWhitespace(start) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">src</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.context</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.header &amp;&amp; start === </span><span class="s3">this</span><span class="s2">.header.end) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.valueRange) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">end</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.valueRange</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">start !== end || Node.atBlank(src</span><span class="s1">, </span><span class="s2">end - </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get hasComment() {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.context) {</span>
      <span class="s3">const </span><span class="s2">{</span>
        <span class="s2">src</span>
      <span class="s2">} = </span><span class="s3">this</span><span class="s2">.context</span><span class="s1">;</span>

      <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; </span><span class="s3">this</span><span class="s2">.props.length</span><span class="s1">; </span><span class="s2">++i) {</span>
        <span class="s3">if </span><span class="s2">(src[</span><span class="s3">this</span><span class="s2">.props[i].start] === Char.COMMENT) </span><span class="s3">return true</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get hasProps() {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.context) {</span>
      <span class="s3">const </span><span class="s2">{</span>
        <span class="s2">src</span>
      <span class="s2">} = </span><span class="s3">this</span><span class="s2">.context</span><span class="s1">;</span>

      <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; </span><span class="s3">this</span><span class="s2">.props.length</span><span class="s1">; </span><span class="s2">++i) {</span>
        <span class="s3">if </span><span class="s2">(src[</span><span class="s3">this</span><span class="s2">.props[i].start] !== Char.COMMENT) </span><span class="s3">return true</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get includesTrailingLines() {</span>
    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get jsonLike() {</span>
    <span class="s3">const </span><span class="s2">jsonLikeTypes = [Type.FLOW_MAP</span><span class="s1">, </span><span class="s2">Type.FLOW_SEQ</span><span class="s1">, </span><span class="s2">Type.QUOTE_DOUBLE</span><span class="s1">, </span><span class="s2">Type.QUOTE_SINGLE]</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">jsonLikeTypes.indexOf(</span><span class="s3">this</span><span class="s2">.type) !== -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get rangeAsLinePos() {</span>
    <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.range || !</span><span class="s3">this</span><span class="s2">.context) </span><span class="s3">return </span><span class="s2">undefined</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">start = getLinePos(</span><span class="s3">this</span><span class="s2">.range.start</span><span class="s1">, </span><span class="s3">this</span><span class="s2">.context.root)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(!start) </span><span class="s3">return </span><span class="s2">undefined</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">end = getLinePos(</span><span class="s3">this</span><span class="s2">.range.end</span><span class="s1">, </span><span class="s3">this</span><span class="s2">.context.root)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">{</span>
      <span class="s2">start</span><span class="s1">,</span>
      <span class="s2">end</span>
    <span class="s2">}</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get rawValue() {</span>
    <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.valueRange || !</span><span class="s3">this</span><span class="s2">.context) </span><span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">start</span><span class="s1">,</span>
      <span class="s2">end</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.valueRange</span><span class="s1">;</span>
    <span class="s3">return this</span><span class="s2">.context.src.slice(start</span><span class="s1">, </span><span class="s2">end)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get tag() {</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; </span><span class="s3">this</span><span class="s2">.props.length</span><span class="s1">; </span><span class="s2">++i) {</span>
      <span class="s3">const </span><span class="s2">tag = </span><span class="s3">this</span><span class="s2">.getPropValue(i</span><span class="s1">, </span><span class="s2">Char.TAG</span><span class="s1">, </span><span class="s3">false</span><span class="s2">)</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(tag != </span><span class="s3">null</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(tag[</span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'&lt;'</span><span class="s2">) {</span>
          <span class="s3">return </span><span class="s2">{</span>
            <span class="s2">verbatim: tag.slice(</span><span class="s4">2</span><span class="s1">, </span><span class="s2">-</span><span class="s4">1</span><span class="s2">)</span>
          <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
          <span class="s7">// eslint-disable-next-line no-unused-vars</span>
          <span class="s3">const </span><span class="s2">[_</span><span class="s1">, </span><span class="s2">handle</span><span class="s1">, </span><span class="s2">suffix] = tag.match(</span><span class="s4">/^(.*!)([^!]*)$/</span><span class="s2">)</span><span class="s1">;</span>
          <span class="s3">return </span><span class="s2">{</span>
            <span class="s2">handle</span><span class="s1">,</span>
            <span class="s2">suffix</span>
          <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get valueRangeContainsNewline() {</span>
    <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.valueRange || !</span><span class="s3">this</span><span class="s2">.context) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">start</span><span class="s1">,</span>
      <span class="s2">end</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.valueRange</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">src</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.context</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = start</span><span class="s1">; </span><span class="s2">i &lt; end</span><span class="s1">; </span><span class="s2">++i) {</span>
      <span class="s3">if </span><span class="s2">(src[i] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) </span><span class="s3">return true</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return false</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">parseComment(start) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">src</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.context</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(src[start] === Char.COMMENT) {</span>
      <span class="s3">const </span><span class="s2">end = Node.endOfLine(src</span><span class="s1">, </span><span class="s2">start + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">commentRange = </span><span class="s3">new </span><span class="s2">Range(start</span><span class="s1">, </span><span class="s2">end)</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s2">.props.push(commentRange)</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s2">end</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">start</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s5">/**</span>
   <span class="s5">* Populates the `origStart` and `origEnd` values of all ranges for this</span>
   <span class="s5">* node. Extended by child classes to handle descendant nodes.</span>
   <span class="s5">*</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number[]} cr - Positions of dropped CR characters</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} offset - Starting index of `cr` from the last call</span>
   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} - The next offset, matching the one found for `origStart`</span>
   <span class="s5">*/</span>


  <span class="s2">setOrigRanges(cr</span><span class="s1">, </span><span class="s2">offset) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.range) offset = </span><span class="s3">this</span><span class="s2">.range.setOrigRange(cr</span><span class="s1">, </span><span class="s2">offset)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.valueRange) </span><span class="s3">this</span><span class="s2">.valueRange.setOrigRange(cr</span><span class="s1">, </span><span class="s2">offset)</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.props.forEach(prop =&gt; prop.setOrigRange(cr</span><span class="s1">, </span><span class="s2">offset))</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toString() {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">context: {</span>
        <span class="s2">src</span>
      <span class="s2">}</span><span class="s1">,</span>
      <span class="s2">range</span><span class="s1">,</span>
      <span class="s2">value</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(value != </span><span class="s3">null</span><span class="s2">) </span><span class="s3">return </span><span class="s2">value</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">str = src.slice(range.start</span><span class="s1">, </span><span class="s2">range.end)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">Node.addStringTerminator(src</span><span class="s1">, </span><span class="s2">range.end</span><span class="s1">, </span><span class="s2">str)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s3">class </span><span class="s2">YAMLError </span><span class="s3">extends </span><span class="s2">Error {</span>
  <span class="s2">constructor(name</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">message) {</span>
    <span class="s3">if </span><span class="s2">(!message || !(source </span><span class="s3">instanceof </span><span class="s2">Node)) </span><span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">`Invalid arguments for new </span><span class="s2">${name}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">super</span><span class="s2">()</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.name = name</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.message = message</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.source = source</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">makePretty() {</span>
    <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.source) </span><span class="s3">return</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.nodeType = </span><span class="s3">this</span><span class="s2">.source.type</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">cst = </span><span class="s3">this</span><span class="s2">.source.context &amp;&amp; </span><span class="s3">this</span><span class="s2">.source.context.root</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof this</span><span class="s2">.offset === </span><span class="s0">'number'</span><span class="s2">) {</span>
      <span class="s3">this</span><span class="s2">.range = </span><span class="s3">new </span><span class="s2">Range(</span><span class="s3">this</span><span class="s2">.offset</span><span class="s1">, </span><span class="s3">this</span><span class="s2">.offset + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">start = cst &amp;&amp; getLinePos(</span><span class="s3">this</span><span class="s2">.offset</span><span class="s1">, </span><span class="s2">cst)</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(start) {</span>
        <span class="s3">const </span><span class="s2">end = {</span>
          <span class="s2">line: start.line</span><span class="s1">,</span>
          <span class="s2">col: start.col + </span><span class="s4">1</span>
        <span class="s2">}</span><span class="s1">;</span>
        <span class="s3">this</span><span class="s2">.linePos = {</span>
          <span class="s2">start</span><span class="s1">,</span>
          <span class="s2">end</span>
        <span class="s2">}</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s3">delete this</span><span class="s2">.offset</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">this</span><span class="s2">.range = </span><span class="s3">this</span><span class="s2">.source.range</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s2">.linePos = </span><span class="s3">this</span><span class="s2">.source.rangeAsLinePos</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.linePos) {</span>
      <span class="s3">const </span><span class="s2">{</span>
        <span class="s2">line</span><span class="s1">,</span>
        <span class="s2">col</span>
      <span class="s2">} = </span><span class="s3">this</span><span class="s2">.linePos.start</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s2">.message += </span><span class="s0">` at line </span><span class="s2">${line}</span><span class="s0">, column </span><span class="s2">${col}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">ctx = cst &amp;&amp; getPrettyContext(</span><span class="s3">this</span><span class="s2">.linePos</span><span class="s1">, </span><span class="s2">cst)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(ctx) </span><span class="s3">this</span><span class="s2">.message += </span><span class="s0">`:</span><span class="s1">\n\n</span><span class="s2">${ctx}</span><span class="s1">\n</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">delete this</span><span class="s2">.source</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>
<span class="s3">class </span><span class="s2">YAMLReferenceError </span><span class="s3">extends </span><span class="s2">YAMLError {</span>
  <span class="s2">constructor(source</span><span class="s1">, </span><span class="s2">message) {</span>
    <span class="s3">super</span><span class="s2">(</span><span class="s0">'YAMLReferenceError'</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">message)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>
<span class="s3">class </span><span class="s2">YAMLSemanticError </span><span class="s3">extends </span><span class="s2">YAMLError {</span>
  <span class="s2">constructor(source</span><span class="s1">, </span><span class="s2">message) {</span>
    <span class="s3">super</span><span class="s2">(</span><span class="s0">'YAMLSemanticError'</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">message)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>
<span class="s3">class </span><span class="s2">YAMLSyntaxError </span><span class="s3">extends </span><span class="s2">YAMLError {</span>
  <span class="s2">constructor(source</span><span class="s1">, </span><span class="s2">message) {</span>
    <span class="s3">super</span><span class="s2">(</span><span class="s0">'YAMLSyntaxError'</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">message)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>
<span class="s3">class </span><span class="s2">YAMLWarning </span><span class="s3">extends </span><span class="s2">YAMLError {</span>
  <span class="s2">constructor(source</span><span class="s1">, </span><span class="s2">message) {</span>
    <span class="s3">super</span><span class="s2">(</span><span class="s0">'YAMLWarning'</span><span class="s1">, </span><span class="s2">source</span><span class="s1">, </span><span class="s2">message)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s3">function </span><span class="s2">_defineProperty(obj</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">value) {</span>
  <span class="s3">if </span><span class="s2">(key </span><span class="s3">in </span><span class="s2">obj) {</span>
    <span class="s2">Object.defineProperty(obj</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
      <span class="s2">value: value</span><span class="s1">,</span>
      <span class="s2">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s2">configurable: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s2">writable: </span><span class="s3">true</span>
    <span class="s2">})</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
    <span class="s2">obj[key] = value</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">obj</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">class </span><span class="s2">PlainValue </span><span class="s3">extends </span><span class="s2">Node {</span>
  <span class="s3">static </span><span class="s2">endOfLine(src</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">inFlow) {</span>
    <span class="s3">let </span><span class="s2">ch = src[start]</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">offset = start</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(ch &amp;&amp; ch !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(inFlow &amp;&amp; (ch === </span><span class="s0">'[' </span><span class="s2">|| ch === </span><span class="s0">']' </span><span class="s2">|| ch === </span><span class="s0">'{' </span><span class="s2">|| ch === </span><span class="s0">'}' </span><span class="s2">|| ch === </span><span class="s0">','</span><span class="s2">)) </span><span class="s3">break</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">next = src[offset + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(ch === </span><span class="s0">':' </span><span class="s2">&amp;&amp; (!next || next === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">|| next === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">' </span><span class="s2">|| next === </span><span class="s0">' ' </span><span class="s2">|| inFlow &amp;&amp; next === </span><span class="s0">','</span><span class="s2">)) </span><span class="s3">break</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">((ch === </span><span class="s0">' ' </span><span class="s2">|| ch === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">) &amp;&amp; next === </span><span class="s0">'#'</span><span class="s2">) </span><span class="s3">break</span><span class="s1">;</span>
      <span class="s2">offset += </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">ch = next</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get strValue() {</span>
    <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.valueRange || !</span><span class="s3">this</span><span class="s2">.context) </span><span class="s3">return null</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">{</span>
      <span class="s2">start</span><span class="s1">,</span>
      <span class="s2">end</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.valueRange</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">src</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.context</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">ch = src[end - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(start &lt; end &amp;&amp; (ch === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">|| ch === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">' </span><span class="s2">|| ch === </span><span class="s0">' '</span><span class="s2">)) ch = src[--end - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

    <span class="s3">let </span><span class="s2">str = </span><span class="s0">''</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = start</span><span class="s1">; </span><span class="s2">i &lt; end</span><span class="s1">; </span><span class="s2">++i) {</span>
      <span class="s3">const </span><span class="s2">ch = src[i]</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(ch === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) {</span>
        <span class="s3">const </span><span class="s2">{</span>
          <span class="s2">fold</span><span class="s1">,</span>
          <span class="s2">offset</span>
        <span class="s2">} = Node.foldNewline(src</span><span class="s1">, </span><span class="s2">i</span><span class="s1">, </span><span class="s2">-</span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">str += fold</span><span class="s1">;</span>
        <span class="s2">i = offset</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(ch === </span><span class="s0">' ' </span><span class="s2">|| ch === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">) {</span>
        <span class="s7">// trim trailing whitespace</span>
        <span class="s3">const </span><span class="s2">wsStart = i</span><span class="s1">;</span>
        <span class="s3">let </span><span class="s2">next = src[i + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

        <span class="s3">while </span><span class="s2">(i &lt; end &amp;&amp; (next === </span><span class="s0">' ' </span><span class="s2">|| next === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">)) {</span>
          <span class="s2">i += </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s2">next = src[i + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s3">if </span><span class="s2">(next !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) str += i &gt; wsStart ? src.slice(wsStart</span><span class="s1">, </span><span class="s2">i + </span><span class="s4">1</span><span class="s2">) : ch</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s2">str += ch</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">const </span><span class="s2">ch0 = src[start]</span><span class="s1">;</span>

    <span class="s3">switch </span><span class="s2">(ch0) {</span>
      <span class="s3">case </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Plain value cannot start with a tab character'</span><span class="s1">;</span>
          <span class="s3">const </span><span class="s2">errors = [</span><span class="s3">new </span><span class="s2">YAMLSemanticError(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">msg)]</span><span class="s1">;</span>
          <span class="s3">return </span><span class="s2">{</span>
            <span class="s2">errors</span><span class="s1">,</span>
            <span class="s2">str</span>
          <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>

      <span class="s3">case </span><span class="s0">'@'</span><span class="s2">:</span>
      <span class="s3">case </span><span class="s0">'`'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Plain value cannot start with reserved character </span><span class="s2">${ch0}</span><span class="s0">`</span><span class="s1">;</span>
          <span class="s3">const </span><span class="s2">errors = [</span><span class="s3">new </span><span class="s2">YAMLSemanticError(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">msg)]</span><span class="s1">;</span>
          <span class="s3">return </span><span class="s2">{</span>
            <span class="s2">errors</span><span class="s1">,</span>
            <span class="s2">str</span>
          <span class="s2">}</span><span class="s1">;</span>
        <span class="s2">}</span>

      <span class="s3">default</span><span class="s2">:</span>
        <span class="s3">return </span><span class="s2">str</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s2">parseBlockValue(start) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">indent</span><span class="s1">,</span>
      <span class="s2">inFlow</span><span class="s1">,</span>
      <span class="s2">src</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s2">.context</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">offset = start</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">valueEnd = start</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">ch = src[offset]</span><span class="s1">; </span><span class="s2">ch === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">; </span><span class="s2">ch = src[offset]) {</span>
      <span class="s3">if </span><span class="s2">(Node.atDocumentBoundary(src</span><span class="s1">, </span><span class="s2">offset + </span><span class="s4">1</span><span class="s2">)) </span><span class="s3">break</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">end = Node.endOfBlockIndent(src</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">offset + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(end === </span><span class="s3">null </span><span class="s2">|| src[end] === </span><span class="s0">'#'</span><span class="s2">) </span><span class="s3">break</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(src[end] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) {</span>
        <span class="s2">offset = end</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s2">valueEnd = PlainValue.endOfLine(src</span><span class="s1">, </span><span class="s2">end</span><span class="s1">, </span><span class="s2">inFlow)</span><span class="s1">;</span>
        <span class="s2">offset = valueEnd</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.valueRange.isEmpty()) </span><span class="s3">this</span><span class="s2">.valueRange.start = start</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.valueRange.end = valueEnd</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">valueEnd</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s5">/**</span>
   <span class="s5">* Parses a plain value from the source</span>
   <span class="s5">*</span>
   <span class="s5">* Accepted forms are:</span>
   <span class="s5">* ```</span>
   <span class="s5">* #comment</span>
   <span class="s5">*</span>
   <span class="s5">* first line</span>
   <span class="s5">*</span>
   <span class="s5">* first line #comment</span>
   <span class="s5">*</span>
   <span class="s5">* first line</span>
   <span class="s5">* block</span>
   <span class="s5">* lines</span>
   <span class="s5">*</span>
   <span class="s5">* #comment</span>
   <span class="s5">* block</span>
   <span class="s5">* lines</span>
   <span class="s5">* ```</span>
   <span class="s5">* where block lines are empty or have an indent level greater than `indent`.</span>
   <span class="s5">*</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{ParseContext} context</span>
   <span class="s5">* </span><span class="s6">@param </span><span class="s5">{number} start - Index of first character</span>
   <span class="s5">* </span><span class="s6">@returns </span><span class="s5">{number} - Index of the character after this scalar, may be `\n`</span>
   <span class="s5">*/</span>


  <span class="s2">parse(context</span><span class="s1">, </span><span class="s2">start) {</span>
    <span class="s3">this</span><span class="s2">.context = context</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">inFlow</span><span class="s1">,</span>
      <span class="s2">src</span>
    <span class="s2">} = context</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">offset = start</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">ch = src[offset]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(ch &amp;&amp; ch !== </span><span class="s0">'#' </span><span class="s2">&amp;&amp; ch !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s2">offset = PlainValue.endOfLine(src</span><span class="s1">, </span><span class="s2">start</span><span class="s1">, </span><span class="s2">inFlow)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">this</span><span class="s2">.valueRange = </span><span class="s3">new </span><span class="s2">Range(start</span><span class="s1">, </span><span class="s2">offset)</span><span class="s1">;</span>
    <span class="s2">offset = Node.endOfWhiteSpace(src</span><span class="s1">, </span><span class="s2">offset)</span><span class="s1">;</span>
    <span class="s2">offset = </span><span class="s3">this</span><span class="s2">.parseComment(offset)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(!</span><span class="s3">this</span><span class="s2">.hasComment || </span><span class="s3">this</span><span class="s2">.valueRange.isEmpty()) {</span>
      <span class="s2">offset = </span><span class="s3">this</span><span class="s2">.parseBlockValue(offset)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">offset</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s2">exports.Char = Char</span><span class="s1">;</span>
<span class="s2">exports.Node = Node</span><span class="s1">;</span>
<span class="s2">exports.PlainValue = PlainValue</span><span class="s1">;</span>
<span class="s2">exports.Range = Range</span><span class="s1">;</span>
<span class="s2">exports.Type = Type</span><span class="s1">;</span>
<span class="s2">exports.YAMLError = YAMLError</span><span class="s1">;</span>
<span class="s2">exports.YAMLReferenceError = YAMLReferenceError</span><span class="s1">;</span>
<span class="s2">exports.YAMLSemanticError = YAMLSemanticError</span><span class="s1">;</span>
<span class="s2">exports.YAMLSyntaxError = YAMLSyntaxError</span><span class="s1">;</span>
<span class="s2">exports.YAMLWarning = YAMLWarning</span><span class="s1">;</span>
<span class="s2">exports._defineProperty = _defineProperty</span><span class="s1">;</span>
<span class="s2">exports.defaultTagPrefix = defaultTagPrefix</span><span class="s1">;</span>
<span class="s2">exports.defaultTags = defaultTags</span><span class="s1">;</span>
</pre>
</body>
</html>