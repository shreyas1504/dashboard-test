<html>
<head>
<title>ascii.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832; font-weight: bold;}
.s1 { color: #cfd2d5;}
.s2 { color: #8ea765;}
.s3 { color: #cc7832;}
.s4 { color: #6897bb;}
.s5 { color: #8a8a8a; font-style: italic;}
.s6 { color: #8a8a8a; font-weight: bold; font-style: italic;}
.s7 { color: #808080;}
</style>
</head>
<body bgcolor="#1c1c1c">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
ascii.mjs</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ compareRangeCovs } from </span><span class="s2">&quot;./compare&quot;</span><span class="s3">;</span>
<span class="s0">export function </span><span class="s1">emitForest(trees) {</span>
    <span class="s0">return </span><span class="s1">emitForestLines(trees).join(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">)</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">export function </span><span class="s1">emitForestLines(trees) {</span>
    <span class="s0">const </span><span class="s1">colMap = getColMap(trees)</span><span class="s3">;</span>
    <span class="s0">const </span><span class="s1">header = emitOffsets(colMap)</span><span class="s3">;</span>
    <span class="s0">return </span><span class="s1">[header</span><span class="s3">, </span><span class="s1">...trees.map(tree =&gt; emitTree(tree</span><span class="s3">, </span><span class="s1">colMap).join(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">))]</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getColMap(trees) {</span>
    <span class="s0">const </span><span class="s1">eventSet = </span><span class="s0">new </span><span class="s1">Set()</span><span class="s3">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">tree of trees) {</span>
        <span class="s0">const </span><span class="s1">stack = [tree]</span><span class="s3">;</span>
        <span class="s0">while </span><span class="s1">(stack.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">cur = stack.pop()</span><span class="s3">;</span>
            <span class="s1">eventSet.add(cur.start)</span><span class="s3">;</span>
            <span class="s1">eventSet.add(cur.end)</span><span class="s3">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">child of cur.children) {</span>
                <span class="s1">stack.push(child)</span><span class="s3">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">events = [...eventSet]</span><span class="s3">;</span>
    <span class="s1">events.sort((a</span><span class="s3">, </span><span class="s1">b) =&gt; a - b)</span><span class="s3">;</span>
    <span class="s0">let </span><span class="s1">maxDigits = </span><span class="s4">1</span><span class="s3">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">event of events) {</span>
        <span class="s1">maxDigits = Math.max(maxDigits</span><span class="s3">, </span><span class="s1">event.toString(</span><span class="s4">10</span><span class="s1">).length)</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s0">const </span><span class="s1">colWidth = maxDigits + </span><span class="s4">3</span><span class="s3">;</span>
    <span class="s0">const </span><span class="s1">colMap = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s3">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">[i</span><span class="s3">, </span><span class="s1">event] of events.entries()) {</span>
        <span class="s1">colMap.set(event</span><span class="s3">, </span><span class="s1">i * colWidth)</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">colMap</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">emitTree(tree</span><span class="s3">, </span><span class="s1">colMap) {</span>
    <span class="s0">const </span><span class="s1">layers = []</span><span class="s3">;</span>
    <span class="s0">let </span><span class="s1">nextLayer = [tree]</span><span class="s3">;</span>
    <span class="s0">while </span><span class="s1">(nextLayer.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">layer = nextLayer</span><span class="s3">;</span>
        <span class="s1">layers.push(layer)</span><span class="s3">;</span>
        <span class="s1">nextLayer = []</span><span class="s3">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">node of layer) {</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">child of node.children) {</span>
                <span class="s1">nextLayer.push(child)</span><span class="s3">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">layers.map(layer =&gt; emitTreeLayer(layer</span><span class="s3">, </span><span class="s1">colMap))</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">export function </span><span class="s1">parseFunctionRanges(text</span><span class="s3">, </span><span class="s1">offsetMap) {</span>
    <span class="s0">const </span><span class="s1">result = []</span><span class="s3">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">line of text.split(</span><span class="s2">&quot;</span><span class="s3">\n</span><span class="s2">&quot;</span><span class="s1">)) {</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">range of parseTreeLayer(line</span><span class="s3">, </span><span class="s1">offsetMap)) {</span>
            <span class="s1">result.push(range)</span><span class="s3">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s1">result.sort(compareRangeCovs)</span><span class="s3">;</span>
    <span class="s0">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s5">/**</span>
 <span class="s5">*</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">layer Sorted list of disjoint trees.</span>
 <span class="s5">* </span><span class="s6">@param </span><span class="s5">colMap</span>
 <span class="s5">*/</span>
<span class="s0">function </span><span class="s1">emitTreeLayer(layer</span><span class="s3">, </span><span class="s1">colMap) {</span>
    <span class="s0">const </span><span class="s1">line = []</span><span class="s3">;</span>
    <span class="s0">let </span><span class="s1">curIdx = </span><span class="s4">0</span><span class="s3">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">{ start</span><span class="s3">, </span><span class="s1">end</span><span class="s3">, </span><span class="s1">count } of layer) {</span>
        <span class="s0">const </span><span class="s1">startIdx = colMap.get(start)</span><span class="s3">;</span>
        <span class="s0">const </span><span class="s1">endIdx = colMap.get(end)</span><span class="s3">;</span>
        <span class="s0">if </span><span class="s1">(startIdx &gt; curIdx) {</span>
            <span class="s1">line.push(</span><span class="s2">&quot; &quot;</span><span class="s1">.repeat(startIdx - curIdx))</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s1">line.push(emitRange(count</span><span class="s3">, </span><span class="s1">endIdx - startIdx))</span><span class="s3">;</span>
        <span class="s1">curIdx = endIdx</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">line.join(</span><span class="s2">&quot;&quot;</span><span class="s1">)</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">parseTreeLayer(text</span><span class="s3">, </span><span class="s1">offsetMap) {</span>
    <span class="s0">const </span><span class="s1">result = []</span><span class="s3">;</span>
    <span class="s0">const </span><span class="s1">regex = </span><span class="s4">/\[(\d+)-*\)/gs</span><span class="s3">;</span>
    <span class="s0">while </span><span class="s1">(</span><span class="s0">true</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">match = regex.exec(text)</span><span class="s3">;</span>
        <span class="s0">if </span><span class="s1">(match === </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s0">break</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">startIdx = match.index</span><span class="s3">;</span>
        <span class="s0">const </span><span class="s1">endIdx = startIdx + match[</span><span class="s4">0</span><span class="s1">].length</span><span class="s3">;</span>
        <span class="s0">const </span><span class="s1">count = parseInt(match[</span><span class="s4">1</span><span class="s1">]</span><span class="s3">, </span><span class="s4">10</span><span class="s1">)</span><span class="s3">;</span>
        <span class="s0">const </span><span class="s1">startOffset = offsetMap.get(startIdx)</span><span class="s3">;</span>
        <span class="s0">const </span><span class="s1">endOffset = offsetMap.get(endIdx)</span><span class="s3">;</span>
        <span class="s0">if </span><span class="s1">(startOffset === undefined || endOffset === undefined) {</span>
            <span class="s0">throw new </span><span class="s1">Error(</span><span class="s2">`Invalid offsets for: </span><span class="s1">${JSON.stringify(text)}</span><span class="s2">`</span><span class="s1">)</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s1">result.push({ startOffset</span><span class="s3">, </span><span class="s1">endOffset</span><span class="s3">, </span><span class="s1">count })</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">emitRange(count</span><span class="s3">, </span><span class="s1">len) {</span>
    <span class="s0">const </span><span class="s1">rangeStart = </span><span class="s2">`[</span><span class="s1">${count.toString(</span><span class="s4">10</span><span class="s1">)}</span><span class="s2">`</span><span class="s3">;</span>
    <span class="s0">const </span><span class="s1">rangeEnd = </span><span class="s2">&quot;)&quot;</span><span class="s3">;</span>
    <span class="s0">const </span><span class="s1">hyphensLen = len - (rangeStart.length + rangeEnd.length)</span><span class="s3">;</span>
    <span class="s0">const </span><span class="s1">hyphens = </span><span class="s2">&quot;-&quot;</span><span class="s1">.repeat(Math.max(</span><span class="s4">0</span><span class="s3">, </span><span class="s1">hyphensLen))</span><span class="s3">;</span>
    <span class="s0">return </span><span class="s2">`</span><span class="s1">${rangeStart}${hyphens}${rangeEnd}</span><span class="s2">`</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">emitOffsets(colMap) {</span>
    <span class="s0">let </span><span class="s1">line = </span><span class="s2">&quot;&quot;</span><span class="s3">;</span>
    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">[event</span><span class="s3">, </span><span class="s1">col] of colMap) {</span>
        <span class="s0">if </span><span class="s1">(line.length &lt; col) {</span>
            <span class="s1">line += </span><span class="s2">&quot; &quot;</span><span class="s1">.repeat(col - line.length)</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s1">line += event.toString(</span><span class="s4">10</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">line</span><span class="s3">;</span>
<span class="s1">}</span>
<span class="s0">export function </span><span class="s1">parseOffsets(text) {</span>
    <span class="s0">const </span><span class="s1">result = </span><span class="s0">new </span><span class="s1">Map()</span><span class="s3">;</span>
    <span class="s0">const </span><span class="s1">regex = </span><span class="s4">/\d+/gs</span><span class="s3">;</span>
    <span class="s0">while </span><span class="s1">(</span><span class="s0">true</span><span class="s1">) {</span>
        <span class="s0">const </span><span class="s1">match = regex.exec(text)</span><span class="s3">;</span>
        <span class="s0">if </span><span class="s1">(match === </span><span class="s0">null</span><span class="s1">) {</span>
            <span class="s0">break</span><span class="s3">;</span>
        <span class="s1">}</span>
        <span class="s1">result.set(match.index</span><span class="s3">, </span><span class="s1">parseInt(match[</span><span class="s4">0</span><span class="s1">]</span><span class="s3">, </span><span class="s4">10</span><span class="s1">))</span><span class="s3">;</span>
    <span class="s1">}</span>
    <span class="s0">return </span><span class="s1">result</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s7">//# sourceMappingURL=data:application/json;charset=utf8;base64,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RUFBRTtZQUNsQixNQUFNO1NBQ1A7UUFDRCxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ2pEO0lBQ0QsT0FBTyxNQUFNLENBQUM7QUFDaEIsQ0FBQyIsImZpbGUiOiJhc2NpaS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNvbXBhcmVSYW5nZUNvdnMgfSBmcm9tIFwiLi9jb21wYXJlXCI7XG5pbXBvcnQgeyBSYW5nZUNvdiB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmludGVyZmFjZSBSZWFkb25seVJhbmdlVHJlZSB7XG4gIHJlYWRvbmx5IHN0YXJ0OiBudW1iZXI7XG4gIHJlYWRvbmx5IGVuZDogbnVtYmVyO1xuICByZWFkb25seSBjb3VudDogbnVtYmVyO1xuICByZWFkb25seSBjaGlsZHJlbjogUmVhZG9ubHlSYW5nZVRyZWVbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRGb3Jlc3QodHJlZXM6IFJlYWRvbmx5QXJyYXk8UmVhZG9ubHlSYW5nZVRyZWU+KTogc3RyaW5nIHtcbiAgcmV0dXJuIGVtaXRGb3Jlc3RMaW5lcyh0cmVlcykuam9pbihcIlxcblwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRGb3Jlc3RMaW5lcyh0cmVlczogUmVhZG9ubHlBcnJheTxSZWFkb25seVJhbmdlVHJlZT4pOiBzdHJpbmdbXSB7XG4gIGNvbnN0IGNvbE1hcDogTWFwPG51bWJlciwgbnVtYmVyPiA9IGdldENvbE1hcCh0cmVlcyk7XG4gIGNvbnN0IGhlYWRlcjogc3RyaW5nID0gZW1pdE9mZnNldHMoY29sTWFwKTtcbiAgcmV0dXJuIFtoZWFkZXIsIC4uLnRyZWVzLm1hcCh0cmVlID0+IGVtaXRUcmVlKHRyZWUsIGNvbE1hcCkuam9pbihcIlxcblwiKSldO1xufVxuXG5mdW5jdGlvbiBnZXRDb2xNYXAodHJlZXM6IEl0ZXJhYmxlPFJlYWRvbmx5UmFuZ2VUcmVlPik6IE1hcDxudW1iZXIsIG51bWJlcj4ge1xuICBjb25zdCBldmVudFNldDogU2V0PG51bWJlcj4gPSBuZXcgU2V0KCk7XG4gIGZvciAoY29uc3QgdHJlZSBvZiB0cmVlcykge1xuICAgIGNvbnN0IHN0YWNrOiBSZWFkb25seVJhbmdlVHJlZVtdID0gW3RyZWVdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjdXI6IFJlYWRvbmx5UmFuZ2VUcmVlID0gc3RhY2sucG9wKCkhO1xuICAgICAgZXZlbnRTZXQuYWRkKGN1ci5zdGFydCk7XG4gICAgICBldmVudFNldC5hZGQoY3VyLmVuZCk7XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGN1ci5jaGlsZHJlbikge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgZXZlbnRzOiBudW1iZXJbXSA9IFsuLi5ldmVudFNldF07XG4gIGV2ZW50cy5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGxldCBtYXhEaWdpdHM6IG51bWJlciA9IDE7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgZXZlbnRzKSB7XG4gICAgbWF4RGlnaXRzID0gTWF0aC5tYXgobWF4RGlnaXRzLCBldmVudC50b1N0cmluZygxMCkubGVuZ3RoKTtcbiAgfVxuICBjb25zdCBjb2xXaWR0aDogbnVtYmVyID0gbWF4RGlnaXRzICsgMztcbiAgY29uc3QgY29sTWFwOiBNYXA8bnVtYmVyLCBudW1iZXI+ID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IFtpLCBldmVudF0gb2YgZXZlbnRzLmVudHJpZXMoKSkge1xuICAgIGNvbE1hcC5zZXQoZXZlbnQsIGkgKiBjb2xXaWR0aCk7XG4gIH1cbiAgcmV0dXJuIGNvbE1hcDtcbn1cblxuZnVuY3Rpb24gZW1pdFRyZWUodHJlZTogUmVhZG9ubHlSYW5nZVRyZWUsIGNvbE1hcDogTWFwPG51bWJlciwgbnVtYmVyPik6IHN0cmluZ1tdIHtcbiAgY29uc3QgbGF5ZXJzOiBSZWFkb25seVJhbmdlVHJlZVtdW10gPSBbXTtcbiAgbGV0IG5leHRMYXllcjogUmVhZG9ubHlSYW5nZVRyZWVbXSA9IFt0cmVlXTtcbiAgd2hpbGUgKG5leHRMYXllci5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgbGF5ZXI6IFJlYWRvbmx5UmFuZ2VUcmVlW10gPSBuZXh0TGF5ZXI7XG4gICAgbGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgIG5leHRMYXllciA9IFtdO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBsYXllcikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgIG5leHRMYXllci5wdXNoKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxheWVycy5tYXAobGF5ZXIgPT4gZW1pdFRyZWVMYXllcihsYXllciwgY29sTWFwKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZ1bmN0aW9uUmFuZ2VzKHRleHQ6IHN0cmluZywgb2Zmc2V0TWFwOiBNYXA8bnVtYmVyLCBudW1iZXI+KTogUmFuZ2VDb3ZbXSB7XG4gIGNvbnN0IHJlc3VsdDogUmFuZ2VDb3ZbXSA9IFtdO1xuICBmb3IgKGNvbnN0IGxpbmUgb2YgdGV4dC5zcGxpdChcIlxcblwiKSkge1xuICAgIGZvciAoY29uc3QgcmFuZ2Ugb2YgcGFyc2VUcmVlTGF5ZXIobGluZSwgb2Zmc2V0TWFwKSkge1xuICAgICAgcmVzdWx0LnB1c2gocmFuZ2UpO1xuICAgIH1cbiAgfVxuICByZXN1bHQuc29ydChjb21wYXJlUmFuZ2VDb3ZzKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIGxheWVyIFNvcnRlZCBsaXN0IG9mIGRpc2pvaW50IHRyZWVzLlxuICogQHBhcmFtIGNvbE1hcFxuICovXG5mdW5jdGlvbiBlbWl0VHJlZUxheWVyKGxheWVyOiBSZWFkb25seVJhbmdlVHJlZVtdLCBjb2xNYXA6IE1hcDxudW1iZXIsIG51bWJlcj4pOiBzdHJpbmcge1xuICBjb25zdCBsaW5lOiBzdHJpbmdbXSA9IFtdO1xuICBsZXQgY3VySWR4OiBudW1iZXIgPSAwO1xuICBmb3IgKGNvbnN0IHtzdGFydCwgZW5kLCBjb3VudH0gb2YgbGF5ZXIpIHtcbiAgICBjb25zdCBzdGFydElkeDogbnVtYmVyID0gY29sTWFwLmdldChzdGFydCkhO1xuICAgIGNvbnN0IGVuZElkeDogbnVtYmVyID0gY29sTWFwLmdldChlbmQpITtcbiAgICBpZiAoc3RhcnRJZHggPiBjdXJJZHgpIHtcbiAgICAgIGxpbmUucHVzaChcIiBcIi5yZXBlYXQoc3RhcnRJZHggLSBjdXJJZHgpKTtcbiAgICB9XG4gICAgbGluZS5wdXNoKGVtaXRSYW5nZShjb3VudCwgZW5kSWR4IC0gc3RhcnRJZHgpKTtcbiAgICBjdXJJZHggPSBlbmRJZHg7XG4gIH1cbiAgcmV0dXJuIGxpbmUuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VUcmVlTGF5ZXIodGV4dDogc3RyaW5nLCBvZmZzZXRNYXA6IE1hcDxudW1iZXIsIG51bWJlcj4pOiBSYW5nZUNvdltdIHtcbiAgY29uc3QgcmVzdWx0OiBSYW5nZUNvdltdID0gW107XG4gIGNvbnN0IHJlZ2V4OiBSZWdFeHAgPSAvXFxbKFxcZCspLSpcXCkvZ3M7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWF0Y2g6IFJlZ0V4cE1hdGNoQXJyYXkgfCBudWxsID0gcmVnZXguZXhlYyh0ZXh0KTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBzdGFydElkeDogbnVtYmVyID0gbWF0Y2guaW5kZXghO1xuICAgIGNvbnN0IGVuZElkeDogbnVtYmVyID0gc3RhcnRJZHggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgY29uc3QgY291bnQ6IG51bWJlciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XG4gICAgY29uc3Qgc3RhcnRPZmZzZXQ6IG51bWJlciB8IHVuZGVmaW5lZCA9IG9mZnNldE1hcC5nZXQoc3RhcnRJZHgpO1xuICAgIGNvbnN0IGVuZE9mZnNldDogbnVtYmVyIHwgdW5kZWZpbmVkID0gb2Zmc2V0TWFwLmdldChlbmRJZHgpO1xuICAgIGlmIChzdGFydE9mZnNldCA9PT0gdW5kZWZpbmVkIHx8IGVuZE9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgb2Zmc2V0cyBmb3I6ICR7SlNPTi5zdHJpbmdpZnkodGV4dCl9YCk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKHtzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBjb3VudH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGVtaXRSYW5nZShjb3VudDogbnVtYmVyLCBsZW46IG51bWJlcik6IHN0cmluZyB7XG4gIGNvbnN0IHJhbmdlU3RhcnQ6IHN0cmluZyA9IGBbJHtjb3VudC50b1N0cmluZygxMCl9YDtcbiAgY29uc3QgcmFuZ2VFbmQ6IHN0cmluZyA9IFwiKVwiO1xuICBjb25zdCBoeXBoZW5zTGVuOiBudW1iZXIgPSBsZW4gLSAocmFuZ2VTdGFydC5sZW5ndGggKyByYW5nZUVuZC5sZW5ndGgpO1xuICBjb25zdCBoeXBoZW5zOiBzdHJpbmcgPSBcIi1cIi5yZXBlYXQoTWF0aC5tYXgoMCwgaHlwaGVuc0xlbikpO1xuICByZXR1cm4gYCR7cmFuZ2VTdGFydH0ke2h5cGhlbnN9JHtyYW5nZUVuZH1gO1xufVxuXG5mdW5jdGlvbiBlbWl0T2Zmc2V0cyhjb2xNYXA6IE1hcDxudW1iZXIsIG51bWJlcj4pOiBzdHJpbmcge1xuICBsZXQgbGluZTogc3RyaW5nID0gXCJcIjtcbiAgZm9yIChjb25zdCBbZXZlbnQsIGNvbF0gb2YgY29sTWFwKSB7XG4gICAgaWYgKGxpbmUubGVuZ3RoIDwgY29sKSB7XG4gICAgICBsaW5lICs9IFwiIFwiLnJlcGVhdChjb2wgLSBsaW5lLmxlbmd0aCk7XG4gICAgfVxuICAgIGxpbmUgKz0gZXZlbnQudG9TdHJpbmcoMTApO1xuICB9XG4gIHJldHVybiBsaW5lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VPZmZzZXRzKHRleHQ6IHN0cmluZyk6IE1hcDxudW1iZXIsIG51bWJlcj4ge1xuICBjb25zdCByZXN1bHQ6IE1hcDxudW1iZXIsIG51bWJlcj4gPSBuZXcgTWFwKCk7XG4gIGNvbnN0IHJlZ2V4OiBSZWdFeHAgPSAvXFxkKy9ncztcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBtYXRjaDogUmVnRXhwRXhlY0FycmF5IHwgbnVsbCA9IHJlZ2V4LmV4ZWModGV4dCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmVzdWx0LnNldChtYXRjaC5pbmRleCwgcGFyc2VJbnQobWF0Y2hbMF0sIDEwKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=</span>
</pre>
</body>
</html>