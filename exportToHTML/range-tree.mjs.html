<html>
<head>
<title>range-tree.mjs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832; font-weight: bold;}
.s1 { color: #cfd2d5;}
.s2 { color: #cc7832;}
.s3 { color: #8a8a8a; font-style: italic;}
.s4 { color: #8a8a8a; font-weight: bold; font-style: italic;}
.s5 { color: #808080;}
.s6 { color: #6897bb;}
</style>
</head>
<body bgcolor="#1c1c1c">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
range-tree.mjs</font>
</center></td></tr></table>
<pre><span class="s0">export class </span><span class="s1">RangeTree {</span>
    <span class="s1">constructor(start</span><span class="s2">, </span><span class="s1">end</span><span class="s2">, </span><span class="s1">delta</span><span class="s2">, </span><span class="s1">children) {</span>
        <span class="s0">this</span><span class="s1">.start = start</span><span class="s2">;</span>
        <span class="s0">this</span><span class="s1">.end = end</span><span class="s2">;</span>
        <span class="s0">this</span><span class="s1">.delta = delta</span><span class="s2">;</span>
        <span class="s0">this</span><span class="s1">.children = children</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@precodition </span><span class="s3">`ranges` are well-formed and pre-order sorted</span>
     <span class="s3">*/</span>
    <span class="s0">static </span><span class="s1">fromSortedRanges(ranges) {</span>
        <span class="s0">let </span><span class="s1">root</span><span class="s2">;</span>
        <span class="s5">// Stack of parent trees and parent counts.</span>
        <span class="s0">const </span><span class="s1">stack = []</span><span class="s2">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">range of ranges) {</span>
            <span class="s0">const </span><span class="s1">node = </span><span class="s0">new </span><span class="s1">RangeTree(range.startOffset</span><span class="s2">, </span><span class="s1">range.endOffset</span><span class="s2">, </span><span class="s1">range.count</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">;</span>
            <span class="s0">if </span><span class="s1">(root === undefined) {</span>
                <span class="s1">root = node</span><span class="s2">;</span>
                <span class="s1">stack.push([node</span><span class="s2">, </span><span class="s1">range.count])</span><span class="s2">;</span>
                <span class="s0">continue</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">let </span><span class="s1">parent</span><span class="s2">;</span>
            <span class="s0">let </span><span class="s1">parentCount</span><span class="s2">;</span>
            <span class="s0">while </span><span class="s1">(</span><span class="s0">true</span><span class="s1">) {</span>
                <span class="s1">[parent</span><span class="s2">, </span><span class="s1">parentCount] = stack[stack.length - </span><span class="s6">1</span><span class="s1">]</span><span class="s2">;</span>
                <span class="s5">// assert: `top !== undefined` (the ranges are sorted)</span>
                <span class="s0">if </span><span class="s1">(range.startOffset &lt; parent.end) {</span>
                    <span class="s0">break</span><span class="s2">;</span>
                <span class="s1">}</span>
                <span class="s0">else </span><span class="s1">{</span>
                    <span class="s1">stack.pop()</span><span class="s2">;</span>
                <span class="s1">}</span>
            <span class="s1">}</span>
            <span class="s1">node.delta -= parentCount</span><span class="s2">;</span>
            <span class="s1">parent.children.push(node)</span><span class="s2">;</span>
            <span class="s1">stack.push([node</span><span class="s2">, </span><span class="s1">range.count])</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">root</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s1">normalize() {</span>
        <span class="s0">const </span><span class="s1">children = []</span><span class="s2">;</span>
        <span class="s0">let </span><span class="s1">curEnd</span><span class="s2">;</span>
        <span class="s0">let </span><span class="s1">head</span><span class="s2">;</span>
        <span class="s0">const </span><span class="s1">tail = []</span><span class="s2">;</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">child of </span><span class="s0">this</span><span class="s1">.children) {</span>
            <span class="s0">if </span><span class="s1">(head === undefined) {</span>
                <span class="s1">head = child</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(child.delta === head.delta &amp;&amp; child.start === curEnd) {</span>
                <span class="s1">tail.push(child)</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">else </span><span class="s1">{</span>
                <span class="s1">endChain()</span><span class="s2">;</span>
                <span class="s1">head = child</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">curEnd = child.end</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(head !== undefined) {</span>
            <span class="s1">endChain()</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">if </span><span class="s1">(children.length === </span><span class="s6">1</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">child = children[</span><span class="s6">0</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s0">if </span><span class="s1">(child.start === </span><span class="s0">this</span><span class="s1">.start &amp;&amp; child.end === </span><span class="s0">this</span><span class="s1">.end) {</span>
                <span class="s0">this</span><span class="s1">.delta += child.delta</span><span class="s2">;</span>
                <span class="s0">this</span><span class="s1">.children = child.children</span><span class="s2">;</span>
                <span class="s5">// `.lazyCount` is zero for both (both are after normalization)</span>
                <span class="s0">return</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">this</span><span class="s1">.children = children</span><span class="s2">;</span>
        <span class="s0">function </span><span class="s1">endChain() {</span>
            <span class="s0">if </span><span class="s1">(tail.length !== </span><span class="s6">0</span><span class="s1">) {</span>
                <span class="s1">head.end = tail[tail.length - </span><span class="s6">1</span><span class="s1">].end</span><span class="s2">;</span>
                <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">tailTree of tail) {</span>
                    <span class="s0">for </span><span class="s1">(</span><span class="s0">const </span><span class="s1">subChild of tailTree.children) {</span>
                        <span class="s1">subChild.delta += tailTree.delta - head.delta</span><span class="s2">;</span>
                        <span class="s1">head.children.push(subChild)</span><span class="s2">;</span>
                    <span class="s1">}</span>
                <span class="s1">}</span>
                <span class="s1">tail.length = </span><span class="s6">0</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s1">head.normalize()</span><span class="s2">;</span>
            <span class="s1">children.push(head)</span><span class="s2">;</span>
        <span class="s1">}</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* </span><span class="s4">@precondition </span><span class="s3">`tree.start &lt; value &amp;&amp; value &lt; tree.end`</span>
     <span class="s3">* </span><span class="s4">@return </span><span class="s3">RangeTree Right part</span>
     <span class="s3">*/</span>
    <span class="s1">split(value) {</span>
        <span class="s0">let </span><span class="s1">leftChildLen = </span><span class="s0">this</span><span class="s1">.children.length</span><span class="s2">;</span>
        <span class="s0">let </span><span class="s1">mid</span><span class="s2">;</span>
        <span class="s5">// TODO(perf): Binary search (check overhead)</span>
        <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i &lt; </span><span class="s0">this</span><span class="s1">.children.length</span><span class="s2">; </span><span class="s1">i++) {</span>
            <span class="s0">const </span><span class="s1">child = </span><span class="s0">this</span><span class="s1">.children[i]</span><span class="s2">;</span>
            <span class="s0">if </span><span class="s1">(child.start &lt; value &amp;&amp; value &lt; child.end) {</span>
                <span class="s1">mid = child.split(value)</span><span class="s2">;</span>
                <span class="s1">leftChildLen = i + </span><span class="s6">1</span><span class="s2">;</span>
                <span class="s0">break</span><span class="s2">;</span>
            <span class="s1">}</span>
            <span class="s0">else if </span><span class="s1">(child.start &gt;= value) {</span>
                <span class="s1">leftChildLen = i</span><span class="s2">;</span>
                <span class="s0">break</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">rightLen = </span><span class="s0">this</span><span class="s1">.children.length - leftChildLen</span><span class="s2">;</span>
        <span class="s0">const </span><span class="s1">rightChildren = </span><span class="s0">this</span><span class="s1">.children.splice(leftChildLen</span><span class="s2">, </span><span class="s1">rightLen)</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(mid !== undefined) {</span>
            <span class="s1">rightChildren.unshift(mid)</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">const </span><span class="s1">result = </span><span class="s0">new </span><span class="s1">RangeTree(value</span><span class="s2">, </span><span class="s0">this</span><span class="s1">.end</span><span class="s2">, </span><span class="s0">this</span><span class="s1">.delta</span><span class="s2">, </span><span class="s1">rightChildren)</span><span class="s2">;</span>
        <span class="s0">this</span><span class="s1">.end = value</span><span class="s2">;</span>
        <span class="s0">return </span><span class="s1">result</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s3">/**</span>
     <span class="s3">* Get the range coverages corresponding to the tree.</span>
     <span class="s3">*</span>
     <span class="s3">* The ranges are pre-order sorted.</span>
     <span class="s3">*/</span>
    <span class="s1">toRanges() {</span>
        <span class="s0">const </span><span class="s1">ranges = []</span><span class="s2">;</span>
        <span class="s5">// Stack of parent trees and counts.</span>
        <span class="s0">const </span><span class="s1">stack = [[</span><span class="s0">this</span><span class="s2">, </span><span class="s6">0</span><span class="s1">]]</span><span class="s2">;</span>
        <span class="s0">while </span><span class="s1">(stack.length &gt; </span><span class="s6">0</span><span class="s1">) {</span>
            <span class="s0">const </span><span class="s1">[cur</span><span class="s2">, </span><span class="s1">parentCount] = stack.pop()</span><span class="s2">;</span>
            <span class="s0">const </span><span class="s1">count = parentCount + cur.delta</span><span class="s2">;</span>
            <span class="s1">ranges.push({ startOffset: cur.start</span><span class="s2">, </span><span class="s1">endOffset: cur.end</span><span class="s2">, </span><span class="s1">count })</span><span class="s2">;</span>
            <span class="s0">for </span><span class="s1">(</span><span class="s0">let </span><span class="s1">i = cur.children.length - </span><span class="s6">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s1">i--) {</span>
                <span class="s1">stack.push([cur.children[i]</span><span class="s2">, </span><span class="s1">count])</span><span class="s2">;</span>
            <span class="s1">}</span>
        <span class="s1">}</span>
        <span class="s0">return </span><span class="s1">ranges</span><span class="s2">;</span>
    <span class="s1">}</span>
<span class="s1">}</span>

<span class="s5">//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUMsR0FBRyxFQUFFLFdBQVcsQ0FBQyxHQUF3QixLQUFLLENBQUMsR0FBRyxFQUFHLENBQUM7WUFDN0QsTUFBTSxLQUFLLEdBQVcsV0FBVyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUM7WUFDOUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFDLFdBQVcsRUFBRSxHQUFHLENBQUMsS0FBSyxFQUFFLFNBQVMsRUFBRSxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBQyxDQUFDLENBQUM7WUFDakUsS0FBSyxJQUFJLENBQUMsR0FBVyxHQUFHLENBQUMsUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDekQsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQzthQUN0QztTQUNGO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztDQUNGIiwiZmlsZSI6InJhbmdlLXRyZWUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYW5nZUNvdiB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBSYW5nZVRyZWUge1xuICBzdGFydDogbnVtYmVyO1xuICBlbmQ6IG51bWJlcjtcbiAgZGVsdGE6IG51bWJlcjtcbiAgY2hpbGRyZW46IFJhbmdlVHJlZVtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHN0YXJ0OiBudW1iZXIsXG4gICAgZW5kOiBudW1iZXIsXG4gICAgZGVsdGE6IG51bWJlcixcbiAgICBjaGlsZHJlbjogUmFuZ2VUcmVlW10sXG4gICkge1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB0aGlzLmRlbHRhID0gZGVsdGE7XG4gICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcmVjb2RpdGlvbiBgcmFuZ2VzYCBhcmUgd2VsbC1mb3JtZWQgYW5kIHByZS1vcmRlciBzb3J0ZWRcbiAgICovXG4gIHN0YXRpYyBmcm9tU29ydGVkUmFuZ2VzKHJhbmdlczogUmVhZG9ubHlBcnJheTxSYW5nZUNvdj4pOiBSYW5nZVRyZWUgfCB1bmRlZmluZWQge1xuICAgIGxldCByb290OiBSYW5nZVRyZWUgfCB1bmRlZmluZWQ7XG4gICAgLy8gU3RhY2sgb2YgcGFyZW50IHRyZWVzIGFuZCBwYXJlbnQgY291bnRzLlxuICAgIGNvbnN0IHN0YWNrOiBbUmFuZ2VUcmVlLCBudW1iZXJdW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHJhbmdlIG9mIHJhbmdlcykge1xuICAgICAgY29uc3Qgbm9kZTogUmFuZ2VUcmVlID0gbmV3IFJhbmdlVHJlZShyYW5nZS5zdGFydE9mZnNldCwgcmFuZ2UuZW5kT2Zmc2V0LCByYW5nZS5jb3VudCwgW10pO1xuICAgICAgaWYgKHJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByb290ID0gbm9kZTtcbiAgICAgICAgc3RhY2sucHVzaChbbm9kZSwgcmFuZ2UuY291bnRdKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcGFyZW50OiBSYW5nZVRyZWU7XG4gICAgICBsZXQgcGFyZW50Q291bnQ6IG51bWJlcjtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIFtwYXJlbnQsIHBhcmVudENvdW50XSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBhc3NlcnQ6IGB0b3AgIT09IHVuZGVmaW5lZGAgKHRoZSByYW5nZXMgYXJlIHNvcnRlZClcbiAgICAgICAgaWYgKHJhbmdlLnN0YXJ0T2Zmc2V0IDwgcGFyZW50LmVuZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLmRlbHRhIC09IHBhcmVudENvdW50O1xuICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICBzdGFjay5wdXNoKFtub2RlLCByYW5nZS5jb3VudF0pO1xuICAgIH1cbiAgICByZXR1cm4gcm9vdDtcbiAgfVxuXG4gIG5vcm1hbGl6ZSgpOiB2b2lkIHtcbiAgICBjb25zdCBjaGlsZHJlbjogUmFuZ2VUcmVlW10gPSBbXTtcbiAgICBsZXQgY3VyRW5kOiBudW1iZXI7XG4gICAgbGV0IGhlYWQ6IFJhbmdlVHJlZSB8IHVuZGVmaW5lZDtcbiAgICBjb25zdCB0YWlsOiBSYW5nZVRyZWVbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xuICAgICAgaWYgKGhlYWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBoZWFkID0gY2hpbGQ7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmRlbHRhID09PSBoZWFkLmRlbHRhICYmIGNoaWxkLnN0YXJ0ID09PSBjdXJFbmQhKSB7XG4gICAgICAgIHRhaWwucHVzaChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmRDaGFpbigpO1xuICAgICAgICBoZWFkID0gY2hpbGQ7XG4gICAgICB9XG4gICAgICBjdXJFbmQgPSBjaGlsZC5lbmQ7XG4gICAgfVxuICAgIGlmIChoZWFkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZENoYWluKCk7XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY2hpbGQ6IFJhbmdlVHJlZSA9IGNoaWxkcmVuWzBdO1xuICAgICAgaWYgKGNoaWxkLnN0YXJ0ID09PSB0aGlzLnN0YXJ0ICYmIGNoaWxkLmVuZCA9PT0gdGhpcy5lbmQpIHtcbiAgICAgICAgdGhpcy5kZWx0YSArPSBjaGlsZC5kZWx0YTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IGNoaWxkLmNoaWxkcmVuO1xuICAgICAgICAvLyBgLmxhenlDb3VudGAgaXMgemVybyBmb3IgYm90aCAoYm90aCBhcmUgYWZ0ZXIgbm9ybWFsaXphdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcblxuICAgIGZ1bmN0aW9uIGVuZENoYWluKCk6IHZvaWQge1xuICAgICAgaWYgKHRhaWwubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGhlYWQhLmVuZCA9IHRhaWxbdGFpbC5sZW5ndGggLSAxXS5lbmQ7XG4gICAgICAgIGZvciAoY29uc3QgdGFpbFRyZWUgb2YgdGFpbCkge1xuICAgICAgICAgIGZvciAoY29uc3Qgc3ViQ2hpbGQgb2YgdGFpbFRyZWUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHN1YkNoaWxkLmRlbHRhICs9IHRhaWxUcmVlLmRlbHRhIC0gaGVhZCEuZGVsdGE7XG4gICAgICAgICAgICBoZWFkIS5jaGlsZHJlbi5wdXNoKHN1YkNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGFpbC5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgaGVhZCEubm9ybWFsaXplKCk7XG4gICAgICBjaGlsZHJlbi5wdXNoKGhlYWQhKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHByZWNvbmRpdGlvbiBgdHJlZS5zdGFydCA8IHZhbHVlICYmIHZhbHVlIDwgdHJlZS5lbmRgXG4gICAqIEByZXR1cm4gUmFuZ2VUcmVlIFJpZ2h0IHBhcnRcbiAgICovXG4gIHNwbGl0KHZhbHVlOiBudW1iZXIpOiBSYW5nZVRyZWUge1xuICAgIGxldCBsZWZ0Q2hpbGRMZW46IG51bWJlciA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIGxldCBtaWQ6IFJhbmdlVHJlZSB8IHVuZGVmaW5lZDtcblxuICAgIC8vIFRPRE8ocGVyZik6IEJpbmFyeSBzZWFyY2ggKGNoZWNrIG92ZXJoZWFkKVxuICAgIGZvciAobGV0IGk6IG51bWJlciA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaGlsZDogUmFuZ2VUcmVlID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChjaGlsZC5zdGFydCA8IHZhbHVlICYmIHZhbHVlIDwgY2hpbGQuZW5kKSB7XG4gICAgICAgIG1pZCA9IGNoaWxkLnNwbGl0KHZhbHVlKTtcbiAgICAgICAgbGVmdENoaWxkTGVuID0gaSArIDE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5zdGFydCA+PSB2YWx1ZSkge1xuICAgICAgICBsZWZ0Q2hpbGRMZW4gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCByaWdodExlbjogbnVtYmVyID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSBsZWZ0Q2hpbGRMZW47XG4gICAgY29uc3QgcmlnaHRDaGlsZHJlbjogUmFuZ2VUcmVlW10gPSB0aGlzLmNoaWxkcmVuLnNwbGljZShsZWZ0Q2hpbGRMZW4sIHJpZ2h0TGVuKTtcbiAgICBpZiAobWlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJpZ2h0Q2hpbGRyZW4udW5zaGlmdChtaWQpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQ6IFJhbmdlVHJlZSA9IG5ldyBSYW5nZVRyZWUoXG4gICAgICB2YWx1ZSxcbiAgICAgIHRoaXMuZW5kLFxuICAgICAgdGhpcy5kZWx0YSxcbiAgICAgIHJpZ2h0Q2hpbGRyZW4sXG4gICAgKTtcbiAgICB0aGlzLmVuZCA9IHZhbHVlO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSByYW5nZSBjb3ZlcmFnZXMgY29ycmVzcG9uZGluZyB0byB0aGUgdHJlZS5cbiAgICpcbiAgICogVGhlIHJhbmdlcyBhcmUgcHJlLW9yZGVyIHNvcnRlZC5cbiAgICovXG4gIHRvUmFuZ2VzKCk6IFJhbmdlQ292W10ge1xuICAgIGNvbnN0IHJhbmdlczogUmFuZ2VDb3ZbXSA9IFtdO1xuICAgIC8vIFN0YWNrIG9mIHBhcmVudCB0cmVlcyBhbmQgY291bnRzLlxuICAgIGNvbnN0IHN0YWNrOiBbUmFuZ2VUcmVlLCBudW1iZXJdW10gPSBbW3RoaXMsIDBdXTtcbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgW2N1ciwgcGFyZW50Q291bnRdOiBbUmFuZ2VUcmVlLCBudW1iZXJdID0gc3RhY2sucG9wKCkhO1xuICAgICAgY29uc3QgY291bnQ6IG51bWJlciA9IHBhcmVudENvdW50ICsgY3VyLmRlbHRhO1xuICAgICAgcmFuZ2VzLnB1c2goe3N0YXJ0T2Zmc2V0OiBjdXIuc3RhcnQsIGVuZE9mZnNldDogY3VyLmVuZCwgY291bnR9KTtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IGN1ci5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzdGFjay5wdXNoKFtjdXIuY2hpbGRyZW5baV0sIGNvdW50XSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW5nZXM7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=</span>
</pre>
</body>
</html>