<html>
<head>
<title>resolveSeq-492ab440.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832; font-weight: bold;}
.s1 { color: #cfd2d5;}
.s2 { color: #cc7832;}
.s3 { color: #8ea765;}
.s4 { color: #6897bb;}
.s5 { color: #8a8a8a;}
.s6 { color: #808080;}
.s7 { color: #8a8a8a; font-style: italic;}
.s8 { color: #8a8a8a; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#1c1c1c">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolveSeq-492ab440.js</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">{ c as _classCallCheck</span><span class="s2">, </span><span class="s1">j as _inherits</span><span class="s2">, </span><span class="s1">k as _createSuper</span><span class="s2">, </span><span class="s1">b as _createClass</span><span class="s2">, </span><span class="s1">e as _defineProperty</span><span class="s2">, </span><span class="s1">p as _assertThisInitialized</span><span class="s2">, </span><span class="s1">a as _typeof</span><span class="s2">, </span><span class="s1">q as _toArray</span><span class="s2">, </span><span class="s1">T as Type</span><span class="s2">, </span><span class="s1">_ as _createForOfIteratorHelper</span><span class="s2">, </span><span class="s1">l as _get</span><span class="s2">, </span><span class="s1">m as _getPrototypeOf</span><span class="s2">, </span><span class="s1">o as YAMLReferenceError</span><span class="s2">, </span><span class="s1">r as _possibleConstructorReturn</span><span class="s2">, </span><span class="s1">h as _slicedToArray</span><span class="s2">, </span><span class="s1">g as YAMLSemanticError</span><span class="s2">, </span><span class="s1">n as defaultTags</span><span class="s2">, </span><span class="s1">f as YAMLWarning</span><span class="s2">, </span><span class="s1">C as Char</span><span class="s2">, </span><span class="s1">Y as YAMLSyntaxError</span><span class="s2">, </span><span class="s1">P as PlainValue } from </span><span class="s3">'./PlainValue-b8036b75.js'</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">addCommentBefore(str</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">comment) {</span>
  <span class="s0">if </span><span class="s1">(!comment) </span><span class="s0">return </span><span class="s1">str</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">cc = comment.replace(</span><span class="s4">/[\s\S]^/gm</span><span class="s2">, </span><span class="s3">&quot;$&amp;&quot;</span><span class="s1">.concat(indent</span><span class="s2">, </span><span class="s3">&quot;#&quot;</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s3">&quot;#&quot;</span><span class="s1">.concat(cc</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">).concat(indent).concat(str)</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">addComment(str</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">comment) {</span>
  <span class="s0">return </span><span class="s1">!comment ? str : comment.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) === -</span><span class="s4">1 </span><span class="s1">? </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(str</span><span class="s2">, </span><span class="s3">&quot; #&quot;</span><span class="s1">).concat(comment) : </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(str</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">) + comment.replace(</span><span class="s4">/^/gm</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(indent || </span><span class="s3">''</span><span class="s2">, </span><span class="s3">&quot;#&quot;</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">Node = </span><span class="s0">function </span><span class="s1">Node() {</span>
  <span class="s1">_classCallCheck(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">Node)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">toJSON(value</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ctx) {</span>
  <span class="s0">if </span><span class="s1">(Array.isArray(value)) </span><span class="s0">return </span><span class="s1">value.map(</span><span class="s0">function </span><span class="s1">(v</span><span class="s2">, </span><span class="s1">i) {</span>
    <span class="s0">return </span><span class="s1">toJSON(v</span><span class="s2">, </span><span class="s1">String(i)</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(value &amp;&amp; </span><span class="s0">typeof </span><span class="s1">value.toJSON === </span><span class="s3">'function'</span><span class="s1">) {</span>
    <span class="s0">var </span><span class="s1">anchor = ctx &amp;&amp; ctx.anchors &amp;&amp; ctx.anchors.get(value)</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(anchor) ctx.onCreate = </span><span class="s0">function </span><span class="s1">(res) {</span>
      <span class="s1">anchor.res = res</span><span class="s2">;</span>
      <span class="s0">delete </span><span class="s1">ctx.onCreate</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">res = value.toJSON(arg</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(anchor &amp;&amp; ctx.onCreate) ctx.onCreate(res)</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">((!ctx || !ctx.keep) &amp;&amp; </span><span class="s0">typeof </span><span class="s1">value === </span><span class="s3">'bigint'</span><span class="s1">) </span><span class="s0">return </span><span class="s1">Number(value)</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">value</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">Scalar = </span><span class="s5">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
  <span class="s1">_inherits(Scalar</span><span class="s2">, </span><span class="s1">_Node)</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_super = _createSuper(Scalar)</span><span class="s2">;</span>

  <span class="s0">function </span><span class="s1">Scalar(value) {</span>
    <span class="s0">var </span><span class="s1">_this</span><span class="s2">;</span>

    <span class="s1">_classCallCheck(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">Scalar)</span><span class="s2">;</span>

    <span class="s1">_this = _super.call(</span><span class="s0">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">_this.value = value</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">_this</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">_createClass(Scalar</span><span class="s2">, </span><span class="s1">[{</span>
    <span class="s1">key: </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toJSON$1(arg</span><span class="s2">, </span><span class="s1">ctx) {</span>
      <span class="s0">return </span><span class="s1">ctx &amp;&amp; ctx.keep ? </span><span class="s0">this</span><span class="s1">.value : toJSON(</span><span class="s0">this</span><span class="s1">.value</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toString&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toString() {</span>
      <span class="s0">return </span><span class="s1">String(</span><span class="s0">this</span><span class="s1">.value)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}])</span><span class="s2">;</span>

  <span class="s0">return </span><span class="s1">Scalar</span><span class="s2">;</span>
<span class="s1">}(Node)</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">collectionFromPath(schema</span><span class="s2">, </span><span class="s1">path</span><span class="s2">, </span><span class="s1">value) {</span>
  <span class="s0">var </span><span class="s1">v = value</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = path.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">--i) {</span>
    <span class="s0">var </span><span class="s1">k = path[i]</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(Number.isInteger(k) &amp;&amp; k &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">a = []</span><span class="s2">;</span>
      <span class="s1">a[k] = v</span><span class="s2">;</span>
      <span class="s1">v = a</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">var </span><span class="s1">o = {}</span><span class="s2">;</span>
      <span class="s1">Object.defineProperty(o</span><span class="s2">, </span><span class="s1">k</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">value: v</span><span class="s2">,</span>
        <span class="s1">writable: </span><span class="s0">true</span><span class="s2">,</span>
        <span class="s1">enumerable: </span><span class="s0">true</span><span class="s2">,</span>
        <span class="s1">configurable: </span><span class="s0">true</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">v = o</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">schema.createNode(v</span><span class="s2">, </span><span class="s0">false</span><span class="s1">)</span><span class="s2">;</span>
<span class="s1">} </span><span class="s6">// null, undefined, or an empty non-string iterable (e.g. [])</span>


<span class="s0">var </span><span class="s1">isEmptyPath = </span><span class="s0">function </span><span class="s1">isEmptyPath(path) {</span>
  <span class="s0">return </span><span class="s1">path == </span><span class="s0">null </span><span class="s1">|| _typeof(path) === </span><span class="s3">'object' </span><span class="s1">&amp;&amp; path[Symbol.iterator]().next().done</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">var </span><span class="s1">Collection = </span><span class="s5">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
  <span class="s1">_inherits(Collection</span><span class="s2">, </span><span class="s1">_Node)</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_super = _createSuper(Collection)</span><span class="s2">;</span>

  <span class="s0">function </span><span class="s1">Collection(schema) {</span>
    <span class="s0">var </span><span class="s1">_this</span><span class="s2">;</span>

    <span class="s1">_classCallCheck(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">Collection)</span><span class="s2">;</span>

    <span class="s1">_this = _super.call(</span><span class="s0">this</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">_defineProperty(_assertThisInitialized(_this)</span><span class="s2">, </span><span class="s3">&quot;items&quot;</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">;</span>

    <span class="s1">_this.schema = schema</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">_this</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">_createClass(Collection</span><span class="s2">, </span><span class="s1">[{</span>
    <span class="s1">key: </span><span class="s3">&quot;addIn&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">addIn(path</span><span class="s2">, </span><span class="s1">value) {</span>
      <span class="s0">if </span><span class="s1">(isEmptyPath(path)) </span><span class="s0">this</span><span class="s1">.add(value)</span><span class="s2">;</span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">var </span><span class="s1">_path = _toArray(path)</span><span class="s2">,</span>
            <span class="s1">key = _path[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
            <span class="s1">rest = _path.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>

        <span class="s0">var </span><span class="s1">node = </span><span class="s0">this</span><span class="s1">.get(key</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(node </span><span class="s0">instanceof </span><span class="s1">Collection) node.addIn(rest</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span><span class="s0">else if </span><span class="s1">(node === undefined &amp;&amp; </span><span class="s0">this</span><span class="s1">.schema) </span><span class="s0">this</span><span class="s1">.set(key</span><span class="s2">, </span><span class="s1">collectionFromPath(</span><span class="s0">this</span><span class="s1">.schema</span><span class="s2">, </span><span class="s1">rest</span><span class="s2">, </span><span class="s1">value))</span><span class="s2">;</span><span class="s0">else throw new </span><span class="s1">Error(</span><span class="s3">&quot;Expected YAML collection at &quot;</span><span class="s1">.concat(key</span><span class="s2">, </span><span class="s3">&quot;. Remaining path: &quot;</span><span class="s1">).concat(rest))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;deleteIn&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">deleteIn(_ref) {</span>
      <span class="s0">var </span><span class="s1">_ref2 = _toArray(_ref)</span><span class="s2">,</span>
          <span class="s1">key = _ref2[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
          <span class="s1">rest = _ref2.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(rest.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s0">return this</span><span class="s1">.delete(key)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">node = </span><span class="s0">this</span><span class="s1">.get(key</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(node </span><span class="s0">instanceof </span><span class="s1">Collection) </span><span class="s0">return </span><span class="s1">node.deleteIn(rest)</span><span class="s2">;</span><span class="s0">else throw new </span><span class="s1">Error(</span><span class="s3">&quot;Expected YAML collection at &quot;</span><span class="s1">.concat(key</span><span class="s2">, </span><span class="s3">&quot;. Remaining path: &quot;</span><span class="s1">).concat(rest))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;getIn&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">getIn(_ref3</span><span class="s2">, </span><span class="s1">keepScalar) {</span>
      <span class="s0">var </span><span class="s1">_ref4 = _toArray(_ref3)</span><span class="s2">,</span>
          <span class="s1">key = _ref4[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
          <span class="s1">rest = _ref4.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s0">var </span><span class="s1">node = </span><span class="s0">this</span><span class="s1">.get(key</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(rest.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s0">return </span><span class="s1">!keepScalar &amp;&amp; node </span><span class="s0">instanceof </span><span class="s1">Scalar ? node.value : node</span><span class="s2">;</span><span class="s0">else return </span><span class="s1">node </span><span class="s0">instanceof </span><span class="s1">Collection ? node.getIn(rest</span><span class="s2">, </span><span class="s1">keepScalar) : undefined</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;hasAllNullValues&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">hasAllNullValues() {</span>
      <span class="s0">return this</span><span class="s1">.items.every(</span><span class="s0">function </span><span class="s1">(node) {</span>
        <span class="s0">if </span><span class="s1">(!node || node.type !== </span><span class="s3">'PAIR'</span><span class="s1">) </span><span class="s0">return false</span><span class="s2">;</span>
        <span class="s0">var </span><span class="s1">n = node.value</span><span class="s2">;</span>
        <span class="s0">return </span><span class="s1">n == </span><span class="s0">null </span><span class="s1">|| n </span><span class="s0">instanceof </span><span class="s1">Scalar &amp;&amp; n.value == </span><span class="s0">null </span><span class="s1">&amp;&amp; !n.commentBefore &amp;&amp; !n.comment &amp;&amp; !n.tag</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;hasIn&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">hasIn(_ref5) {</span>
      <span class="s0">var </span><span class="s1">_ref6 = _toArray(_ref5)</span><span class="s2">,</span>
          <span class="s1">key = _ref6[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
          <span class="s1">rest = _ref6.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(rest.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s0">return this</span><span class="s1">.has(key)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">node = </span><span class="s0">this</span><span class="s1">.get(key</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">node </span><span class="s0">instanceof </span><span class="s1">Collection ? node.hasIn(rest) : </span><span class="s0">false</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;setIn&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">setIn(_ref7</span><span class="s2">, </span><span class="s1">value) {</span>
      <span class="s0">var </span><span class="s1">_ref8 = _toArray(_ref7)</span><span class="s2">,</span>
          <span class="s1">key = _ref8[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
          <span class="s1">rest = _ref8.slice(</span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(rest.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s0">this</span><span class="s1">.set(key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">var </span><span class="s1">node = </span><span class="s0">this</span><span class="s1">.get(key</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(node </span><span class="s0">instanceof </span><span class="s1">Collection) node.setIn(rest</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span><span class="s0">else if </span><span class="s1">(node === undefined &amp;&amp; </span><span class="s0">this</span><span class="s1">.schema) </span><span class="s0">this</span><span class="s1">.set(key</span><span class="s2">, </span><span class="s1">collectionFromPath(</span><span class="s0">this</span><span class="s1">.schema</span><span class="s2">, </span><span class="s1">rest</span><span class="s2">, </span><span class="s1">value))</span><span class="s2">;</span><span class="s0">else throw new </span><span class="s1">Error(</span><span class="s3">&quot;Expected YAML collection at &quot;</span><span class="s1">.concat(key</span><span class="s2">, </span><span class="s3">&quot;. Remaining path: &quot;</span><span class="s1">).concat(rest))</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s6">// overridden in implementations</span>

    <span class="s5">/* istanbul ignore next */</span>

  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toJSON() {</span>
      <span class="s0">return null</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toString&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toString(ctx</span><span class="s2">, </span><span class="s1">_ref9</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep) {</span>
      <span class="s0">var </span><span class="s1">_this2 = </span><span class="s0">this</span><span class="s2">;</span>

      <span class="s0">var </span><span class="s1">blockItem = _ref9.blockItem</span><span class="s2">,</span>
          <span class="s1">flowChars = _ref9.flowChars</span><span class="s2">,</span>
          <span class="s1">isMap = _ref9.isMap</span><span class="s2">,</span>
          <span class="s1">itemIndent = _ref9.itemIndent</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">_ctx = ctx</span><span class="s2">,</span>
          <span class="s1">indent = _ctx.indent</span><span class="s2">,</span>
          <span class="s1">indentStep = _ctx.indentStep</span><span class="s2">,</span>
          <span class="s1">stringify = _ctx.stringify</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">inFlow = </span><span class="s0">this</span><span class="s1">.type === Type.FLOW_MAP || </span><span class="s0">this</span><span class="s1">.type === Type.FLOW_SEQ || ctx.inFlow</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(inFlow) itemIndent += indentStep</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">allNullValues = isMap &amp;&amp; </span><span class="s0">this</span><span class="s1">.hasAllNullValues()</span><span class="s2">;</span>
      <span class="s1">ctx = Object.assign({}</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">allNullValues: allNullValues</span><span class="s2">,</span>
        <span class="s1">indent: itemIndent</span><span class="s2">,</span>
        <span class="s1">inFlow: inFlow</span><span class="s2">,</span>
        <span class="s1">type: </span><span class="s0">null</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">chompKeep = </span><span class="s0">false</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">hasItemWithNewLine = </span><span class="s0">false</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">nodes = </span><span class="s0">this</span><span class="s1">.items.reduce(</span><span class="s0">function </span><span class="s1">(nodes</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">i) {</span>
        <span class="s0">var </span><span class="s1">comment</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(item) {</span>
          <span class="s0">if </span><span class="s1">(!chompKeep &amp;&amp; item.spaceBefore) nodes.push({</span>
            <span class="s1">type: </span><span class="s3">'comment'</span><span class="s2">,</span>
            <span class="s1">str: </span><span class="s3">''</span>
          <span class="s1">})</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(item.commentBefore) item.commentBefore.match(</span><span class="s4">/^.*$/gm</span><span class="s1">).forEach(</span><span class="s0">function </span><span class="s1">(line) {</span>
            <span class="s1">nodes.push({</span>
              <span class="s1">type: </span><span class="s3">'comment'</span><span class="s2">,</span>
              <span class="s1">str: </span><span class="s3">&quot;#&quot;</span><span class="s1">.concat(line)</span>
            <span class="s1">})</span><span class="s2">;</span>
          <span class="s1">})</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(item.comment) comment = item.comment</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(inFlow &amp;&amp; (!chompKeep &amp;&amp; item.spaceBefore || item.commentBefore || item.comment || item.key &amp;&amp; (item.key.commentBefore || item.key.comment) || item.value &amp;&amp; (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = </span><span class="s0">true</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">chompKeep = </span><span class="s0">false</span><span class="s2">;</span>
        <span class="s0">var </span><span class="s1">str = stringify(item</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s0">function </span><span class="s1">() {</span>
          <span class="s0">return </span><span class="s1">comment = </span><span class="s0">null</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s0">function </span><span class="s1">() {</span>
          <span class="s0">return </span><span class="s1">chompKeep = </span><span class="s0">true</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(inFlow &amp;&amp; !hasItemWithNewLine &amp;&amp; str.includes(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) hasItemWithNewLine = </span><span class="s0">true</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(inFlow &amp;&amp; i &lt; _this2.items.length - </span><span class="s4">1</span><span class="s1">) str += </span><span class="s3">','</span><span class="s2">;</span>
        <span class="s1">str = addComment(str</span><span class="s2">, </span><span class="s1">itemIndent</span><span class="s2">, </span><span class="s1">comment)</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(chompKeep &amp;&amp; (comment || inFlow)) chompKeep = </span><span class="s0">false</span><span class="s2">;</span>
        <span class="s1">nodes.push({</span>
          <span class="s1">type: </span><span class="s3">'item'</span><span class="s2">,</span>
          <span class="s1">str: str</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s0">return </span><span class="s1">nodes</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">str</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(nodes.length === </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">str = flowChars.start + flowChars.end</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(inFlow) {</span>
        <span class="s0">var </span><span class="s1">start = flowChars.start</span><span class="s2">,</span>
            <span class="s1">end = flowChars.end</span><span class="s2">;</span>
        <span class="s0">var </span><span class="s1">strings = nodes.map(</span><span class="s0">function </span><span class="s1">(n) {</span>
          <span class="s0">return </span><span class="s1">n.str</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(hasItemWithNewLine || strings.reduce(</span><span class="s0">function </span><span class="s1">(sum</span><span class="s2">, </span><span class="s1">str) {</span>
          <span class="s0">return </span><span class="s1">sum + str.length + </span><span class="s4">2</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) &gt; Collection.maxFlowStringSingleLineLength) {</span>
          <span class="s1">str = start</span><span class="s2">;</span>

          <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(strings)</span><span class="s2">,</span>
              <span class="s1">_step</span><span class="s2">;</span>

          <span class="s0">try </span><span class="s1">{</span>
            <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
              <span class="s0">var </span><span class="s1">s = _step.value</span><span class="s2">;</span>
              <span class="s1">str += s ? </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(indentStep).concat(indent).concat(s) : </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
            <span class="s1">_iterator.f()</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s1">str += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(indent).concat(end)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s1">str = </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(start</span><span class="s2">, </span><span class="s3">&quot; &quot;</span><span class="s1">).concat(strings.join(</span><span class="s3">' '</span><span class="s1">)</span><span class="s2">, </span><span class="s3">&quot; &quot;</span><span class="s1">).concat(end)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">var </span><span class="s1">_strings = nodes.map(blockItem)</span><span class="s2">;</span>

        <span class="s1">str = _strings.shift()</span><span class="s2">;</span>

        <span class="s0">var </span><span class="s1">_iterator2 = _createForOfIteratorHelper(_strings)</span><span class="s2">,</span>
            <span class="s1">_step2</span><span class="s2">;</span>

        <span class="s0">try </span><span class="s1">{</span>
          <span class="s0">for </span><span class="s1">(_iterator2.s()</span><span class="s2">; </span><span class="s1">!(_step2 = _iterator2.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
            <span class="s0">var </span><span class="s1">_s = _step2.value</span><span class="s2">;</span>
            <span class="s1">str += _s ? </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(indent).concat(_s) : </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
          <span class="s1">_iterator2.e(err)</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
          <span class="s1">_iterator2.f()</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.comment) {</span>
        <span class="s1">str += </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ </span><span class="s0">this</span><span class="s1">.comment.replace(</span><span class="s4">/^/gm</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(indent</span><span class="s2">, </span><span class="s3">&quot;#&quot;</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(onComment) onComment()</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(chompKeep &amp;&amp; onChompKeep) onChompKeep()</span><span class="s2">;</span>

      <span class="s0">return </span><span class="s1">str</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}])</span><span class="s2">;</span>

  <span class="s0">return </span><span class="s1">Collection</span><span class="s2">;</span>
<span class="s1">}(Node)</span><span class="s2">;</span>

<span class="s1">_defineProperty(Collection</span><span class="s2">, </span><span class="s3">&quot;maxFlowStringSingleLineLength&quot;</span><span class="s2">, </span><span class="s4">60</span><span class="s1">)</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">asItemIndex(key) {</span>
  <span class="s0">var </span><span class="s1">idx = key </span><span class="s0">instanceof </span><span class="s1">Scalar ? key.value : key</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(idx &amp;&amp; </span><span class="s0">typeof </span><span class="s1">idx === </span><span class="s3">'string'</span><span class="s1">) idx = Number(idx)</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">Number.isInteger(idx) &amp;&amp; idx &gt;= </span><span class="s4">0 </span><span class="s1">? idx : </span><span class="s0">null</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">YAMLSeq = </span><span class="s5">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Collection) {</span>
  <span class="s1">_inherits(YAMLSeq</span><span class="s2">, </span><span class="s1">_Collection)</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_super = _createSuper(YAMLSeq)</span><span class="s2">;</span>

  <span class="s0">function </span><span class="s1">YAMLSeq() {</span>
    <span class="s1">_classCallCheck(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">YAMLSeq)</span><span class="s2">;</span>

    <span class="s0">return </span><span class="s1">_super.apply(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">arguments)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">_createClass(YAMLSeq</span><span class="s2">, </span><span class="s1">[{</span>
    <span class="s1">key: </span><span class="s3">&quot;add&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">add(value) {</span>
      <span class="s0">this</span><span class="s1">.items.push(value)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;delete&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">_delete(key) {</span>
      <span class="s0">var </span><span class="s1">idx = asItemIndex(key)</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">idx !== </span><span class="s3">'number'</span><span class="s1">) </span><span class="s0">return false</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">del = </span><span class="s0">this</span><span class="s1">.items.splice(idx</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">del.length &gt; </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;get&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">get(key</span><span class="s2">, </span><span class="s1">keepScalar) {</span>
      <span class="s0">var </span><span class="s1">idx = asItemIndex(key)</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">idx !== </span><span class="s3">'number'</span><span class="s1">) </span><span class="s0">return </span><span class="s1">undefined</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">it = </span><span class="s0">this</span><span class="s1">.items[idx]</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">!keepScalar &amp;&amp; it </span><span class="s0">instanceof </span><span class="s1">Scalar ? it.value : it</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;has&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">has(key) {</span>
      <span class="s0">var </span><span class="s1">idx = asItemIndex(key)</span><span class="s2">;</span>
      <span class="s0">return typeof </span><span class="s1">idx === </span><span class="s3">'number' </span><span class="s1">&amp;&amp; idx &lt; </span><span class="s0">this</span><span class="s1">.items.length</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;set&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">set(key</span><span class="s2">, </span><span class="s1">value) {</span>
      <span class="s0">var </span><span class="s1">idx = asItemIndex(key)</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">idx !== </span><span class="s3">'number'</span><span class="s1">) </span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Expected a valid index, not &quot;</span><span class="s1">.concat(key</span><span class="s2">, </span><span class="s3">&quot;.&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s0">this</span><span class="s1">.items[idx] = value</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toJSON$1(_</span><span class="s2">, </span><span class="s1">ctx) {</span>
      <span class="s0">var </span><span class="s1">seq = []</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(ctx &amp;&amp; ctx.onCreate) ctx.onCreate(seq)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">;</span>

      <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(</span><span class="s0">this</span><span class="s1">.items)</span><span class="s2">,</span>
          <span class="s1">_step</span><span class="s2">;</span>

      <span class="s0">try </span><span class="s1">{</span>
        <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
          <span class="s0">var </span><span class="s1">item = _step.value</span><span class="s2">;</span>
          <span class="s1">seq.push(toJSON(item</span><span class="s2">, </span><span class="s1">String(i++)</span><span class="s2">, </span><span class="s1">ctx))</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
        <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
        <span class="s1">_iterator.f()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">seq</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toString&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toString(ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep) {</span>
      <span class="s0">if </span><span class="s1">(!ctx) </span><span class="s0">return </span><span class="s1">JSON.stringify(</span><span class="s0">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">_get(_getPrototypeOf(YAMLSeq.prototype)</span><span class="s2">, </span><span class="s3">&quot;toString&quot;</span><span class="s2">, </span><span class="s0">this</span><span class="s1">).call(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">blockItem: </span><span class="s0">function </span><span class="s1">blockItem(n) {</span>
          <span class="s0">return </span><span class="s1">n.type === </span><span class="s3">'comment' </span><span class="s1">? n.str : </span><span class="s3">&quot;- &quot;</span><span class="s1">.concat(n.str)</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">flowChars: {</span>
          <span class="s1">start: </span><span class="s3">'['</span><span class="s2">,</span>
          <span class="s1">end: </span><span class="s3">']'</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">isMap: </span><span class="s0">false</span><span class="s2">,</span>
        <span class="s1">itemIndent: (ctx.indent || </span><span class="s3">''</span><span class="s1">) + </span><span class="s3">'  '</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}])</span><span class="s2">;</span>

  <span class="s0">return </span><span class="s1">YAMLSeq</span><span class="s2">;</span>
<span class="s1">}(Collection)</span><span class="s2">;</span>

<span class="s0">var </span><span class="s1">stringifyKey = </span><span class="s0">function </span><span class="s1">stringifyKey(key</span><span class="s2">, </span><span class="s1">jsKey</span><span class="s2">, </span><span class="s1">ctx) {</span>
  <span class="s0">if </span><span class="s1">(jsKey === </span><span class="s0">null</span><span class="s1">) </span><span class="s0">return </span><span class="s3">''</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(_typeof(jsKey) !== </span><span class="s3">'object'</span><span class="s1">) </span><span class="s0">return </span><span class="s1">String(jsKey)</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(key </span><span class="s0">instanceof </span><span class="s1">Node &amp;&amp; ctx &amp;&amp; ctx.doc) </span><span class="s0">return </span><span class="s1">key.toString({</span>
    <span class="s1">anchors: Object.create(</span><span class="s0">null</span><span class="s1">)</span><span class="s2">,</span>
    <span class="s1">doc: ctx.doc</span><span class="s2">,</span>
    <span class="s1">indent: </span><span class="s3">''</span><span class="s2">,</span>
    <span class="s1">indentStep: ctx.indentStep</span><span class="s2">,</span>
    <span class="s1">inFlow: </span><span class="s0">true</span><span class="s2">,</span>
    <span class="s1">inStringifyKey: </span><span class="s0">true</span><span class="s2">,</span>
    <span class="s1">stringify: ctx.stringify</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">JSON.stringify(jsKey)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">var </span><span class="s1">Pair = </span><span class="s5">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
  <span class="s1">_inherits(Pair</span><span class="s2">, </span><span class="s1">_Node)</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_super = _createSuper(Pair)</span><span class="s2">;</span>

  <span class="s0">function </span><span class="s1">Pair(key) {</span>
    <span class="s0">var </span><span class="s1">_this</span><span class="s2">;</span>

    <span class="s0">var </span><span class="s1">value = arguments.length &gt; </span><span class="s4">1 </span><span class="s1">&amp;&amp; arguments[</span><span class="s4">1</span><span class="s1">] !== undefined ? arguments[</span><span class="s4">1</span><span class="s1">] : </span><span class="s0">null</span><span class="s2">;</span>

    <span class="s1">_classCallCheck(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">Pair)</span><span class="s2">;</span>

    <span class="s1">_this = _super.call(</span><span class="s0">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">_this.key = key</span><span class="s2">;</span>
    <span class="s1">_this.value = value</span><span class="s2">;</span>
    <span class="s1">_this.type = Pair.Type.PAIR</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">_this</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">_createClass(Pair</span><span class="s2">, </span><span class="s1">[{</span>
    <span class="s1">key: </span><span class="s3">&quot;commentBefore&quot;</span><span class="s2">,</span>
    <span class="s1">get: </span><span class="s0">function </span><span class="s1">get() {</span>
      <span class="s0">return this</span><span class="s1">.key </span><span class="s0">instanceof </span><span class="s1">Node ? </span><span class="s0">this</span><span class="s1">.key.commentBefore : undefined</span><span class="s2">;</span>
    <span class="s1">}</span><span class="s2">,</span>
    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(cb) {</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.key == </span><span class="s0">null</span><span class="s1">) </span><span class="s0">this</span><span class="s1">.key = </span><span class="s0">new </span><span class="s1">Scalar(</span><span class="s0">null</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.key </span><span class="s0">instanceof </span><span class="s1">Node) </span><span class="s0">this</span><span class="s1">.key.commentBefore = cb</span><span class="s2">;</span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.'</span><span class="s2">;</span>
        <span class="s0">throw new </span><span class="s1">Error(msg)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;addToJSMap&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">addToJSMap(ctx</span><span class="s2">, </span><span class="s1">map) {</span>
      <span class="s0">var </span><span class="s1">key = toJSON(</span><span class="s0">this</span><span class="s1">.key</span><span class="s2">, </span><span class="s3">''</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(map </span><span class="s0">instanceof </span><span class="s1">Map) {</span>
        <span class="s0">var </span><span class="s1">value = toJSON(</span><span class="s0">this</span><span class="s1">.value</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
        <span class="s1">map.set(key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(map </span><span class="s0">instanceof </span><span class="s1">Set) {</span>
        <span class="s1">map.add(key)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">var </span><span class="s1">stringKey = stringifyKey(</span><span class="s0">this</span><span class="s1">.key</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>

        <span class="s0">var </span><span class="s1">_value = toJSON(</span><span class="s0">this</span><span class="s1">.value</span><span class="s2">, </span><span class="s1">stringKey</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(stringKey </span><span class="s0">in </span><span class="s1">map) Object.defineProperty(map</span><span class="s2">, </span><span class="s1">stringKey</span><span class="s2">, </span><span class="s1">{</span>
          <span class="s1">value: _value</span><span class="s2">,</span>
          <span class="s1">writable: </span><span class="s0">true</span><span class="s2">,</span>
          <span class="s1">enumerable: </span><span class="s0">true</span><span class="s2">,</span>
          <span class="s1">configurable: </span><span class="s0">true</span>
        <span class="s1">})</span><span class="s2">;</span><span class="s0">else </span><span class="s1">map[stringKey] = _value</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">map</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toJSON(_</span><span class="s2">, </span><span class="s1">ctx) {</span>
      <span class="s0">var </span><span class="s1">pair = ctx &amp;&amp; ctx.mapAsMap ? </span><span class="s0">new </span><span class="s1">Map() : {}</span><span class="s2">;</span>
      <span class="s0">return this</span><span class="s1">.addToJSMap(ctx</span><span class="s2">, </span><span class="s1">pair)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toString&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toString(ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep) {</span>
      <span class="s0">if </span><span class="s1">(!ctx || !ctx.doc) </span><span class="s0">return </span><span class="s1">JSON.stringify(</span><span class="s0">this</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">_ctx$doc$options = ctx.doc.options</span><span class="s2">,</span>
          <span class="s1">indentSize = _ctx$doc$options.indent</span><span class="s2">,</span>
          <span class="s1">indentSeq = _ctx$doc$options.indentSeq</span><span class="s2">,</span>
          <span class="s1">simpleKeys = _ctx$doc$options.simpleKeys</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">key = </span><span class="s0">this</span><span class="s1">.key</span><span class="s2">,</span>
          <span class="s1">value = </span><span class="s0">this</span><span class="s1">.value</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">keyComment = key </span><span class="s0">instanceof </span><span class="s1">Node &amp;&amp; key.comment</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(simpleKeys) {</span>
        <span class="s0">if </span><span class="s1">(keyComment) {</span>
          <span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">'With simple keys, key nodes cannot have comments'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">if </span><span class="s1">(key </span><span class="s0">instanceof </span><span class="s1">Collection) {</span>
          <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'With simple keys, collection cannot be used as a key value'</span><span class="s2">;</span>
          <span class="s0">throw new </span><span class="s1">Error(msg)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">var </span><span class="s1">explicitKey = !simpleKeys &amp;&amp; (!key || keyComment || (key </span><span class="s0">instanceof </span><span class="s1">Node ? key </span><span class="s0">instanceof </span><span class="s1">Collection || key.type === Type.BLOCK_FOLDED || key.type === Type.BLOCK_LITERAL : _typeof(key) === </span><span class="s3">'object'</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">_ctx = ctx</span><span class="s2">,</span>
          <span class="s1">doc = _ctx.doc</span><span class="s2">,</span>
          <span class="s1">indent = _ctx.indent</span><span class="s2">,</span>
          <span class="s1">indentStep = _ctx.indentStep</span><span class="s2">,</span>
          <span class="s1">stringify = _ctx.stringify</span><span class="s2">;</span>
      <span class="s1">ctx = Object.assign({}</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">implicitKey: !explicitKey</span><span class="s2">,</span>
        <span class="s1">indent: indent + indentStep</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">chompKeep = </span><span class="s0">false</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">str = stringify(key</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s0">function </span><span class="s1">() {</span>
        <span class="s0">return </span><span class="s1">keyComment = </span><span class="s0">null</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s0">function </span><span class="s1">() {</span>
        <span class="s0">return </span><span class="s1">chompKeep = </span><span class="s0">true</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s1">str = addComment(str</span><span class="s2">, </span><span class="s1">ctx.indent</span><span class="s2">, </span><span class="s1">keyComment)</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(!explicitKey &amp;&amp; str.length &gt; </span><span class="s4">1024</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(simpleKeys) </span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">'With simple keys, single line scalar must not span more than 1024 characters'</span><span class="s1">)</span><span class="s2">;</span>
        <span class="s1">explicitKey = </span><span class="s0">true</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(ctx.allNullValues &amp;&amp; !simpleKeys) {</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.comment) {</span>
          <span class="s1">str = addComment(str</span><span class="s2">, </span><span class="s1">ctx.indent</span><span class="s2">, </span><span class="s0">this</span><span class="s1">.comment)</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(onComment) onComment()</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(chompKeep &amp;&amp; !keyComment &amp;&amp; onChompKeep) onChompKeep()</span><span class="s2">;</span>

        <span class="s0">return </span><span class="s1">ctx.inFlow &amp;&amp; !explicitKey ? str : </span><span class="s3">&quot;? &quot;</span><span class="s1">.concat(str)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">str = explicitKey ? </span><span class="s3">&quot;? &quot;</span><span class="s1">.concat(str</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">).concat(indent</span><span class="s2">, </span><span class="s3">&quot;:&quot;</span><span class="s1">) : </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(str</span><span class="s2">, </span><span class="s3">&quot;:&quot;</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.comment) {</span>
        <span class="s6">// expected (but not strictly required) to be a single-line comment</span>
        <span class="s1">str = addComment(str</span><span class="s2">, </span><span class="s1">ctx.indent</span><span class="s2">, </span><span class="s0">this</span><span class="s1">.comment)</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(onComment) onComment()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">var </span><span class="s1">vcb = </span><span class="s3">''</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">valueComment = </span><span class="s0">null</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(value </span><span class="s0">instanceof </span><span class="s1">Node) {</span>
        <span class="s0">if </span><span class="s1">(value.spaceBefore) vcb = </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(value.commentBefore) {</span>
          <span class="s0">var </span><span class="s1">cs = value.commentBefore.replace(</span><span class="s4">/^/gm</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(ctx.indent</span><span class="s2">, </span><span class="s3">&quot;#&quot;</span><span class="s1">))</span><span class="s2">;</span>
          <span class="s1">vcb += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(cs)</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">valueComment = value.comment</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(value &amp;&amp; _typeof(value) === </span><span class="s3">'object'</span><span class="s1">) {</span>
        <span class="s1">value = doc.schema.createNode(value</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">ctx.implicitKey = </span><span class="s0">false</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(!explicitKey &amp;&amp; !</span><span class="s0">this</span><span class="s1">.comment &amp;&amp; value </span><span class="s0">instanceof </span><span class="s1">Scalar) ctx.indentAtStart = str.length + </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s1">chompKeep = </span><span class="s0">false</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(!indentSeq &amp;&amp; indentSize &gt;= </span><span class="s4">2 </span><span class="s1">&amp;&amp; !ctx.inFlow &amp;&amp; !explicitKey &amp;&amp; value </span><span class="s0">instanceof </span><span class="s1">YAMLSeq &amp;&amp; value.type !== Type.FLOW_SEQ &amp;&amp; !value.tag &amp;&amp; !doc.anchors.getName(value)) {</span>
        <span class="s6">// If indentSeq === false, consider '- ' as part of indentation where possible</span>
        <span class="s1">ctx.indent = ctx.indent.substr(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">var </span><span class="s1">valueStr = stringify(value</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s0">function </span><span class="s1">() {</span>
        <span class="s0">return </span><span class="s1">valueComment = </span><span class="s0">null</span><span class="s2">;</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s0">function </span><span class="s1">() {</span>
        <span class="s0">return </span><span class="s1">chompKeep = </span><span class="s0">true</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">ws = </span><span class="s3">' '</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(vcb || </span><span class="s0">this</span><span class="s1">.comment) {</span>
        <span class="s1">ws = </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(vcb</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">).concat(ctx.indent)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!explicitKey &amp;&amp; value </span><span class="s0">instanceof </span><span class="s1">Collection) {</span>
        <span class="s0">var </span><span class="s1">flow = valueStr[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'[' </span><span class="s1">|| valueStr[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'{'</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(!flow || valueStr.includes(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)) ws = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(ctx.indent)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(valueStr[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) ws = </span><span class="s3">''</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(chompKeep &amp;&amp; !valueComment &amp;&amp; onChompKeep) onChompKeep()</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">addComment(str + ws + valueStr</span><span class="s2">, </span><span class="s1">ctx.indent</span><span class="s2">, </span><span class="s1">valueComment)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}])</span><span class="s2">;</span>

  <span class="s0">return </span><span class="s1">Pair</span><span class="s2">;</span>
<span class="s1">}(Node)</span><span class="s2">;</span>

<span class="s1">_defineProperty(Pair</span><span class="s2">, </span><span class="s3">&quot;Type&quot;</span><span class="s2">, </span><span class="s1">{</span>
  <span class="s1">PAIR: </span><span class="s3">'PAIR'</span><span class="s2">,</span>
  <span class="s1">MERGE_PAIR: </span><span class="s3">'MERGE_PAIR'</span>
<span class="s1">})</span><span class="s2">;</span>

<span class="s0">var </span><span class="s1">getAliasCount = </span><span class="s0">function </span><span class="s1">getAliasCount(node</span><span class="s2">, </span><span class="s1">anchors) {</span>
  <span class="s0">if </span><span class="s1">(node </span><span class="s0">instanceof </span><span class="s1">Alias) {</span>
    <span class="s0">var </span><span class="s1">anchor = anchors.get(node.source)</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">anchor.count * anchor.aliasCount</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">else if </span><span class="s1">(node </span><span class="s0">instanceof </span><span class="s1">Collection) {</span>
    <span class="s0">var </span><span class="s1">count = </span><span class="s4">0</span><span class="s2">;</span>

    <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(node.items)</span><span class="s2">,</span>
        <span class="s1">_step</span><span class="s2">;</span>

    <span class="s0">try </span><span class="s1">{</span>
      <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
        <span class="s0">var </span><span class="s1">item = _step.value</span><span class="s2">;</span>
        <span class="s0">var </span><span class="s1">c = getAliasCount(item</span><span class="s2">, </span><span class="s1">anchors)</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(c &gt; count) count = c</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
      <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
      <span class="s1">_iterator.f()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">return </span><span class="s1">count</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">else if </span><span class="s1">(node </span><span class="s0">instanceof </span><span class="s1">Pair) {</span>
    <span class="s0">var </span><span class="s1">kc = getAliasCount(node.key</span><span class="s2">, </span><span class="s1">anchors)</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">vc = getAliasCount(node.value</span><span class="s2">, </span><span class="s1">anchors)</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">Math.max(kc</span><span class="s2">, </span><span class="s1">vc)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s4">1</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">var </span><span class="s1">Alias = </span><span class="s5">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Node) {</span>
  <span class="s1">_inherits(Alias</span><span class="s2">, </span><span class="s1">_Node)</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_super = _createSuper(Alias)</span><span class="s2">;</span>

  <span class="s0">function </span><span class="s1">Alias(source) {</span>
    <span class="s0">var </span><span class="s1">_this</span><span class="s2">;</span>

    <span class="s1">_classCallCheck(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">Alias)</span><span class="s2">;</span>

    <span class="s1">_this = _super.call(</span><span class="s0">this</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">_this.source = source</span><span class="s2">;</span>
    <span class="s1">_this.type = Type.ALIAS</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">_this</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">_createClass(Alias</span><span class="s2">, </span><span class="s1">[{</span>
    <span class="s1">key: </span><span class="s3">&quot;tag&quot;</span><span class="s2">,</span>
    <span class="s1">set: </span><span class="s0">function </span><span class="s1">set(t) {</span>
      <span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">'Alias nodes cannot have tags'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toJSON$1(arg</span><span class="s2">, </span><span class="s1">ctx) {</span>
      <span class="s0">if </span><span class="s1">(!ctx) </span><span class="s0">return </span><span class="s1">toJSON(</span><span class="s0">this</span><span class="s1">.source</span><span class="s2">, </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">anchors = ctx.anchors</span><span class="s2">,</span>
          <span class="s1">maxAliasCount = ctx.maxAliasCount</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">anchor = anchors.get(</span><span class="s0">this</span><span class="s1">.source)</span><span class="s2">;</span>
      <span class="s5">/* istanbul ignore if */</span>

      <span class="s0">if </span><span class="s1">(!anchor || anchor.res === undefined) {</span>
        <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'This should not happen: Alias anchor was not resolved?'</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.cstNode) </span><span class="s0">throw new </span><span class="s1">YAMLReferenceError(</span><span class="s0">this</span><span class="s1">.cstNode</span><span class="s2">, </span><span class="s1">msg)</span><span class="s2">;</span><span class="s0">else throw new </span><span class="s1">ReferenceError(msg)</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(maxAliasCount &gt;= </span><span class="s4">0</span><span class="s1">) {</span>
        <span class="s1">anchor.count += </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(anchor.aliasCount === </span><span class="s4">0</span><span class="s1">) anchor.aliasCount = getAliasCount(</span><span class="s0">this</span><span class="s1">.source</span><span class="s2">, </span><span class="s1">anchors)</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(anchor.count * anchor.aliasCount &gt; maxAliasCount) {</span>
          <span class="s0">var </span><span class="s1">_msg = </span><span class="s3">'Excessive alias count indicates a resource exhaustion attack'</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(</span><span class="s0">this</span><span class="s1">.cstNode) </span><span class="s0">throw new </span><span class="s1">YAMLReferenceError(</span><span class="s0">this</span><span class="s1">.cstNode</span><span class="s2">, </span><span class="s1">_msg)</span><span class="s2">;</span><span class="s0">else throw new </span><span class="s1">ReferenceError(_msg)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">anchor.res</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s6">// Only called when stringifying an alias mapping key while constructing</span>
    <span class="s6">// Object output.</span>

  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toString&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toString(ctx) {</span>
      <span class="s0">return </span><span class="s1">Alias.stringify(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}]</span><span class="s2">, </span><span class="s1">[{</span>
    <span class="s1">key: </span><span class="s3">&quot;stringify&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">stringify(_ref</span><span class="s2">, </span><span class="s1">_ref2) {</span>
      <span class="s0">var </span><span class="s1">range = _ref.range</span><span class="s2">,</span>
          <span class="s1">source = _ref.source</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">anchors = _ref2.anchors</span><span class="s2">,</span>
          <span class="s1">doc = _ref2.doc</span><span class="s2">,</span>
          <span class="s1">implicitKey = _ref2.implicitKey</span><span class="s2">,</span>
          <span class="s1">inStringifyKey = _ref2.inStringifyKey</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">anchor = Object.keys(anchors).find(</span><span class="s0">function </span><span class="s1">(a) {</span>
        <span class="s0">return </span><span class="s1">anchors[a] === source</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(!anchor &amp;&amp; inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName()</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(anchor) </span><span class="s0">return </span><span class="s3">&quot;*&quot;</span><span class="s1">.concat(anchor).concat(implicitKey ? </span><span class="s3">' ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">msg = doc.anchors.getName(source) ? </span><span class="s3">'Alias node must be after source node' </span><span class="s1">: </span><span class="s3">'Source node not found for alias node'</span><span class="s2">;</span>
      <span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">&quot;&quot;</span><span class="s1">.concat(msg</span><span class="s2">, </span><span class="s3">&quot; [&quot;</span><span class="s1">).concat(range</span><span class="s2">, </span><span class="s3">&quot;]&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}])</span><span class="s2">;</span>

  <span class="s0">return </span><span class="s1">Alias</span><span class="s2">;</span>
<span class="s1">}(Node)</span><span class="s2">;</span>

<span class="s1">_defineProperty(Alias</span><span class="s2">, </span><span class="s3">&quot;default&quot;</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">findPair(items</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s0">var </span><span class="s1">k = key </span><span class="s0">instanceof </span><span class="s1">Scalar ? key.value : key</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(items)</span><span class="s2">,</span>
      <span class="s1">_step</span><span class="s2">;</span>

  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">it = _step.value</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(it </span><span class="s0">instanceof </span><span class="s1">Pair) {</span>
        <span class="s0">if </span><span class="s1">(it.key === key || it.key === k) </span><span class="s0">return </span><span class="s1">it</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(it.key &amp;&amp; it.key.value === k) </span><span class="s0">return </span><span class="s1">it</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
    <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
    <span class="s1">_iterator.f()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">undefined</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">var </span><span class="s1">YAMLMap = </span><span class="s5">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Collection) {</span>
  <span class="s1">_inherits(YAMLMap</span><span class="s2">, </span><span class="s1">_Collection)</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_super = _createSuper(YAMLMap)</span><span class="s2">;</span>

  <span class="s0">function </span><span class="s1">YAMLMap() {</span>
    <span class="s1">_classCallCheck(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">YAMLMap)</span><span class="s2">;</span>

    <span class="s0">return </span><span class="s1">_super.apply(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">arguments)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">_createClass(YAMLMap</span><span class="s2">, </span><span class="s1">[{</span>
    <span class="s1">key: </span><span class="s3">&quot;add&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">add(pair</span><span class="s2">, </span><span class="s1">overwrite) {</span>
      <span class="s0">if </span><span class="s1">(!pair) pair = </span><span class="s0">new </span><span class="s1">Pair(pair)</span><span class="s2">;</span><span class="s0">else if </span><span class="s1">(!(pair </span><span class="s0">instanceof </span><span class="s1">Pair)) pair = </span><span class="s0">new </span><span class="s1">Pair(pair.key || pair</span><span class="s2">, </span><span class="s1">pair.value)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">prev = findPair(</span><span class="s0">this</span><span class="s1">.items</span><span class="s2">, </span><span class="s1">pair.key)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">sortEntries = </span><span class="s0">this</span><span class="s1">.schema &amp;&amp; </span><span class="s0">this</span><span class="s1">.schema.sortMapEntries</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(prev) {</span>
        <span class="s0">if </span><span class="s1">(overwrite) prev.value = pair.value</span><span class="s2">;</span><span class="s0">else throw new </span><span class="s1">Error(</span><span class="s3">&quot;Key &quot;</span><span class="s1">.concat(pair.key</span><span class="s2">, </span><span class="s3">&quot; already set&quot;</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(sortEntries) {</span>
        <span class="s0">var </span><span class="s1">i = </span><span class="s0">this</span><span class="s1">.items.findIndex(</span><span class="s0">function </span><span class="s1">(item) {</span>
          <span class="s0">return </span><span class="s1">sortEntries(pair</span><span class="s2">, </span><span class="s1">item) &lt; </span><span class="s4">0</span><span class="s2">;</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(i === -</span><span class="s4">1</span><span class="s1">) </span><span class="s0">this</span><span class="s1">.items.push(pair)</span><span class="s2">;</span><span class="s0">else this</span><span class="s1">.items.splice(i</span><span class="s2">, </span><span class="s4">0</span><span class="s2">, </span><span class="s1">pair)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">this</span><span class="s1">.items.push(pair)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;delete&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">_delete(key) {</span>
      <span class="s0">var </span><span class="s1">it = findPair(</span><span class="s0">this</span><span class="s1">.items</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(!it) </span><span class="s0">return false</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">del = </span><span class="s0">this</span><span class="s1">.items.splice(</span><span class="s0">this</span><span class="s1">.items.indexOf(it)</span><span class="s2">, </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">del.length &gt; </span><span class="s4">0</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;get&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">get(key</span><span class="s2">, </span><span class="s1">keepScalar) {</span>
      <span class="s0">var </span><span class="s1">it = findPair(</span><span class="s0">this</span><span class="s1">.items</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">node = it &amp;&amp; it.value</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">!keepScalar &amp;&amp; node </span><span class="s0">instanceof </span><span class="s1">Scalar ? node.value : node</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;has&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">has(key) {</span>
      <span class="s0">return </span><span class="s1">!!findPair(</span><span class="s0">this</span><span class="s1">.items</span><span class="s2">, </span><span class="s1">key)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;set&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">set(key</span><span class="s2">, </span><span class="s1">value) {</span>
      <span class="s0">this</span><span class="s1">.add(</span><span class="s0">new </span><span class="s1">Pair(key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">}</span>
    <span class="s7">/**</span>
     <span class="s7">* </span><span class="s8">@param </span><span class="s7">{*} arg ignored</span>
     <span class="s7">* </span><span class="s8">@param </span><span class="s7">{*} ctx Conversion context, originally set in Document#toJSON()</span>
     <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Class} Type If set, forces the returned collection type</span>
     <span class="s7">* </span><span class="s8">@returns </span><span class="s7">{*} Instance of Type, Map, or Object</span>
     <span class="s7">*/</span>

  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toJSON&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toJSON(_</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">Type) {</span>
      <span class="s0">var </span><span class="s1">map = Type ? </span><span class="s0">new </span><span class="s1">Type() : ctx &amp;&amp; ctx.mapAsMap ? </span><span class="s0">new </span><span class="s1">Map() : {}</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(ctx &amp;&amp; ctx.onCreate) ctx.onCreate(map)</span><span class="s2">;</span>

      <span class="s0">var </span><span class="s1">_iterator2 = _createForOfIteratorHelper(</span><span class="s0">this</span><span class="s1">.items)</span><span class="s2">,</span>
          <span class="s1">_step2</span><span class="s2">;</span>

      <span class="s0">try </span><span class="s1">{</span>
        <span class="s0">for </span><span class="s1">(_iterator2.s()</span><span class="s2">; </span><span class="s1">!(_step2 = _iterator2.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
          <span class="s0">var </span><span class="s1">item = _step2.value</span><span class="s2">;</span>
          <span class="s1">item.addToJSMap(ctx</span><span class="s2">, </span><span class="s1">map)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
        <span class="s1">_iterator2.e(err)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
        <span class="s1">_iterator2.f()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">map</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toString&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toString(ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep) {</span>
      <span class="s0">if </span><span class="s1">(!ctx) </span><span class="s0">return </span><span class="s1">JSON.stringify(</span><span class="s0">this</span><span class="s1">)</span><span class="s2">;</span>

      <span class="s0">var </span><span class="s1">_iterator3 = _createForOfIteratorHelper(</span><span class="s0">this</span><span class="s1">.items)</span><span class="s2">,</span>
          <span class="s1">_step3</span><span class="s2">;</span>

      <span class="s0">try </span><span class="s1">{</span>
        <span class="s0">for </span><span class="s1">(_iterator3.s()</span><span class="s2">; </span><span class="s1">!(_step3 = _iterator3.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
          <span class="s0">var </span><span class="s1">item = _step3.value</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(!(item </span><span class="s0">instanceof </span><span class="s1">Pair)) </span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Map items must all be pairs; found &quot;</span><span class="s1">.concat(JSON.stringify(item)</span><span class="s2">, </span><span class="s3">&quot; instead&quot;</span><span class="s1">))</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
        <span class="s1">_iterator3.e(err)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
        <span class="s1">_iterator3.f()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">_get(_getPrototypeOf(YAMLMap.prototype)</span><span class="s2">, </span><span class="s3">&quot;toString&quot;</span><span class="s2">, </span><span class="s0">this</span><span class="s1">).call(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">{</span>
        <span class="s1">blockItem: </span><span class="s0">function </span><span class="s1">blockItem(n) {</span>
          <span class="s0">return </span><span class="s1">n.str</span><span class="s2">;</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">flowChars: {</span>
          <span class="s1">start: </span><span class="s3">'{'</span><span class="s2">,</span>
          <span class="s1">end: </span><span class="s3">'}'</span>
        <span class="s1">}</span><span class="s2">,</span>
        <span class="s1">isMap: </span><span class="s0">true</span><span class="s2">,</span>
        <span class="s1">itemIndent: ctx.indent || </span><span class="s3">''</span>
      <span class="s1">}</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}])</span><span class="s2">;</span>

  <span class="s0">return </span><span class="s1">YAMLMap</span><span class="s2">;</span>
<span class="s1">}(Collection)</span><span class="s2">;</span>

<span class="s0">var </span><span class="s1">MERGE_KEY = </span><span class="s3">'&lt;&lt;'</span><span class="s2">;</span>
<span class="s0">var </span><span class="s1">Merge = </span><span class="s5">/*#__PURE__*/</span><span class="s0">function </span><span class="s1">(_Pair) {</span>
  <span class="s1">_inherits(Merge</span><span class="s2">, </span><span class="s1">_Pair)</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_super = _createSuper(Merge)</span><span class="s2">;</span>

  <span class="s0">function </span><span class="s1">Merge(pair) {</span>
    <span class="s0">var </span><span class="s1">_this</span><span class="s2">;</span>

    <span class="s1">_classCallCheck(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">Merge)</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(pair </span><span class="s0">instanceof </span><span class="s1">Pair) {</span>
      <span class="s0">var </span><span class="s1">seq = pair.value</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(!(seq </span><span class="s0">instanceof </span><span class="s1">YAMLSeq)) {</span>
        <span class="s1">seq = </span><span class="s0">new </span><span class="s1">YAMLSeq()</span><span class="s2">;</span>
        <span class="s1">seq.items.push(pair.value)</span><span class="s2">;</span>
        <span class="s1">seq.range = pair.value.range</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">_this = _super.call(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">pair.key</span><span class="s2">, </span><span class="s1">seq)</span><span class="s2">;</span>
      <span class="s1">_this.range = pair.range</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">_this = _super.call(</span><span class="s0">this</span><span class="s2">, </span><span class="s0">new </span><span class="s1">Scalar(MERGE_KEY)</span><span class="s2">, </span><span class="s0">new </span><span class="s1">YAMLSeq())</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">_this.type = Pair.Type.MERGE_PAIR</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">_possibleConstructorReturn(_this)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s6">// If the value associated with a merge key is a single mapping node, each of</span>
  <span class="s6">// its key/value pairs is inserted into the current mapping, unless the key</span>
  <span class="s6">// already exists in it. If the value associated with the merge key is a</span>
  <span class="s6">// sequence, then this sequence is expected to contain mapping nodes and each</span>
  <span class="s6">// of these nodes is merged in turn according to its order in the sequence.</span>
  <span class="s6">// Keys in mapping nodes earlier in the sequence override keys specified in</span>
  <span class="s6">// later mapping nodes. -- http://yaml.org/type/merge.html</span>


  <span class="s1">_createClass(Merge</span><span class="s2">, </span><span class="s1">[{</span>
    <span class="s1">key: </span><span class="s3">&quot;addToJSMap&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">addToJSMap(ctx</span><span class="s2">, </span><span class="s1">map) {</span>
      <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(</span><span class="s0">this</span><span class="s1">.value.items)</span><span class="s2">,</span>
          <span class="s1">_step</span><span class="s2">;</span>

      <span class="s0">try </span><span class="s1">{</span>
        <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
          <span class="s0">var </span><span class="s1">source = _step.value.source</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(!(source </span><span class="s0">instanceof </span><span class="s1">YAMLMap)) </span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">'Merge sources must be maps'</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s0">var </span><span class="s1">srcMap = source.toJSON(</span><span class="s0">null</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">Map)</span><span class="s2">;</span>

          <span class="s0">var </span><span class="s1">_iterator2 = _createForOfIteratorHelper(srcMap)</span><span class="s2">,</span>
              <span class="s1">_step2</span><span class="s2">;</span>

          <span class="s0">try </span><span class="s1">{</span>
            <span class="s0">for </span><span class="s1">(_iterator2.s()</span><span class="s2">; </span><span class="s1">!(_step2 = _iterator2.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
              <span class="s0">var </span><span class="s1">_step2$value = _slicedToArray(_step2.value</span><span class="s2">, </span><span class="s4">2</span><span class="s1">)</span><span class="s2">,</span>
                  <span class="s1">key = _step2$value[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">,</span>
                  <span class="s1">value = _step2$value[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>

              <span class="s0">if </span><span class="s1">(map </span><span class="s0">instanceof </span><span class="s1">Map) {</span>
                <span class="s0">if </span><span class="s1">(!map.has(key)) map.set(key</span><span class="s2">, </span><span class="s1">value)</span><span class="s2">;</span>
              <span class="s1">} </span><span class="s0">else if </span><span class="s1">(map </span><span class="s0">instanceof </span><span class="s1">Set) {</span>
                <span class="s1">map.add(key)</span><span class="s2">;</span>
              <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!Object.prototype.hasOwnProperty.call(map</span><span class="s2">, </span><span class="s1">key)) {</span>
                <span class="s1">Object.defineProperty(map</span><span class="s2">, </span><span class="s1">key</span><span class="s2">, </span><span class="s1">{</span>
                  <span class="s1">value: value</span><span class="s2">,</span>
                  <span class="s1">writable: </span><span class="s0">true</span><span class="s2">,</span>
                  <span class="s1">enumerable: </span><span class="s0">true</span><span class="s2">,</span>
                  <span class="s1">configurable: </span><span class="s0">true</span>
                <span class="s1">})</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
            <span class="s1">_iterator2.e(err)</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
            <span class="s1">_iterator2.f()</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
        <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
        <span class="s1">_iterator.f()</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">return </span><span class="s1">map</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">{</span>
    <span class="s1">key: </span><span class="s3">&quot;toString&quot;</span><span class="s2">,</span>
    <span class="s1">value: </span><span class="s0">function </span><span class="s1">toString(ctx</span><span class="s2">, </span><span class="s1">onComment) {</span>
      <span class="s0">var </span><span class="s1">seq = </span><span class="s0">this</span><span class="s1">.value</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(seq.items.length &gt; </span><span class="s4">1</span><span class="s1">) </span><span class="s0">return </span><span class="s1">_get(_getPrototypeOf(Merge.prototype)</span><span class="s2">, </span><span class="s3">&quot;toString&quot;</span><span class="s2">, </span><span class="s0">this</span><span class="s1">).call(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment)</span><span class="s2">;</span>
      <span class="s0">this</span><span class="s1">.value = seq.items[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>

      <span class="s0">var </span><span class="s1">str = _get(_getPrototypeOf(Merge.prototype)</span><span class="s2">, </span><span class="s3">&quot;toString&quot;</span><span class="s2">, </span><span class="s0">this</span><span class="s1">).call(</span><span class="s0">this</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment)</span><span class="s2">;</span>

      <span class="s0">this</span><span class="s1">.value = seq</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">str</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}])</span><span class="s2">;</span>

  <span class="s0">return </span><span class="s1">Merge</span><span class="s2">;</span>
<span class="s1">}(Pair)</span><span class="s2">;</span>

<span class="s0">var </span><span class="s1">binaryOptions = {</span>
  <span class="s1">defaultType: Type.BLOCK_LITERAL</span><span class="s2">,</span>
  <span class="s1">lineWidth: </span><span class="s4">76</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">var </span><span class="s1">boolOptions = {</span>
  <span class="s1">trueStr: </span><span class="s3">'true'</span><span class="s2">,</span>
  <span class="s1">falseStr: </span><span class="s3">'false'</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">var </span><span class="s1">intOptions = {</span>
  <span class="s1">asBigInt: </span><span class="s0">false</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">var </span><span class="s1">nullOptions = {</span>
  <span class="s1">nullStr: </span><span class="s3">'null'</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s0">var </span><span class="s1">strOptions = {</span>
  <span class="s1">defaultType: Type.PLAIN</span><span class="s2">,</span>
  <span class="s1">doubleQuoted: {</span>
    <span class="s1">jsonEncoding: </span><span class="s0">false</span><span class="s2">,</span>
    <span class="s1">minMultiLineLength: </span><span class="s4">40</span>
  <span class="s1">}</span><span class="s2">,</span>
  <span class="s1">fold: {</span>
    <span class="s1">lineWidth: </span><span class="s4">80</span><span class="s2">,</span>
    <span class="s1">minContentWidth: </span><span class="s4">20</span>
  <span class="s1">}</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">resolveScalar(str</span><span class="s2">, </span><span class="s1">tags</span><span class="s2">, </span><span class="s1">scalarFallback) {</span>
  <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(tags)</span><span class="s2">,</span>
      <span class="s1">_step</span><span class="s2">;</span>

  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">_step$value = _step.value</span><span class="s2">,</span>
          <span class="s1">format = _step$value.format</span><span class="s2">,</span>
          <span class="s1">test = _step$value.test</span><span class="s2">,</span>
          <span class="s1">resolve = _step$value.resolve</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(test) {</span>
        <span class="s0">var </span><span class="s1">match = str.match(test)</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(match) {</span>
          <span class="s0">var </span><span class="s1">res = resolve.apply(</span><span class="s0">null</span><span class="s2">, </span><span class="s1">match)</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(!(res </span><span class="s0">instanceof </span><span class="s1">Scalar)) res = </span><span class="s0">new </span><span class="s1">Scalar(res)</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(format) res.format = format</span><span class="s2">;</span>
          <span class="s0">return </span><span class="s1">res</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
    <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
    <span class="s1">_iterator.f()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(scalarFallback) str = scalarFallback(str)</span><span class="s2">;</span>
  <span class="s0">return new </span><span class="s1">Scalar(str)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">FOLD_FLOW = </span><span class="s3">'flow'</span><span class="s2">;</span>
<span class="s0">var </span><span class="s1">FOLD_BLOCK = </span><span class="s3">'block'</span><span class="s2">;</span>
<span class="s0">var </span><span class="s1">FOLD_QUOTED = </span><span class="s3">'quoted'</span><span class="s2">; </span><span class="s6">// presumes i+1 is at the start of a line</span>
<span class="s6">// returns index of last newline in more-indented block</span>

<span class="s0">var </span><span class="s1">consumeMoreIndentedLines = </span><span class="s0">function </span><span class="s1">consumeMoreIndentedLines(text</span><span class="s2">, </span><span class="s1">i) {</span>
  <span class="s0">var </span><span class="s1">ch = text[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>

  <span class="s0">while </span><span class="s1">(ch === </span><span class="s3">' ' </span><span class="s1">|| ch === </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s1">) {</span>
    <span class="s0">do </span><span class="s1">{</span>
      <span class="s1">ch = text[i += </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">while </span><span class="s1">(ch &amp;&amp; ch !== </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">ch = text[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">i</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>
<span class="s7">/**</span>
 <span class="s7">* Tries to keep input at up to `lineWidth` characters, splitting only on spaces</span>
 <span class="s7">* not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are</span>
 <span class="s7">* terminated with `\n` and started with `indent`.</span>
 <span class="s7">*</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{string} text</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{string} indent</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{string} [mode='flow'] `'block'` prevents more-indented lines</span>
 <span class="s7">*   from being folded; `'quoted'` allows for `\` escapes, including escaped</span>
 <span class="s7">*   newlines</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Object} options</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{number} [options.indentAtStart] Accounts for leading contents on</span>
 <span class="s7">*   the first line, defaulting to `indent.length`</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{number} [options.lineWidth=80]</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{number} [options.minContentWidth=20] Allow highly indented lines to</span>
 <span class="s7">*   stretch the line width or indent content from the start</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{function} options.onFold Called once if the text is folded</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{function} options.onFold Called once if any line of text exceeds</span>
 <span class="s7">*   lineWidth characters</span>
 <span class="s7">*/</span>


<span class="s0">function </span><span class="s1">foldFlowLines(text</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">mode</span><span class="s2">, </span><span class="s1">_ref) {</span>
  <span class="s0">var </span><span class="s1">indentAtStart = _ref.indentAtStart</span><span class="s2">,</span>
      <span class="s1">_ref$lineWidth = _ref.lineWidth</span><span class="s2">,</span>
      <span class="s1">lineWidth = _ref$lineWidth === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s4">80 </span><span class="s1">: _ref$lineWidth</span><span class="s2">,</span>
      <span class="s1">_ref$minContentWidth = _ref.minContentWidth</span><span class="s2">,</span>
      <span class="s1">minContentWidth = _ref$minContentWidth === </span><span class="s0">void </span><span class="s4">0 </span><span class="s1">? </span><span class="s4">20 </span><span class="s1">: _ref$minContentWidth</span><span class="s2">,</span>
      <span class="s1">onFold = _ref.onFold</span><span class="s2">,</span>
      <span class="s1">onOverflow = _ref.onOverflow</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(!lineWidth || lineWidth &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s0">return </span><span class="s1">text</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">endStep = Math.max(</span><span class="s4">1 </span><span class="s1">+ minContentWidth</span><span class="s2">, </span><span class="s4">1 </span><span class="s1">+ lineWidth - indent.length)</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(text.length &lt;= endStep) </span><span class="s0">return </span><span class="s1">text</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">folds = []</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">escapedFolds = {}</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">end = lineWidth - indent.length</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">indentAtStart === </span><span class="s3">'number'</span><span class="s1">) {</span>
    <span class="s0">if </span><span class="s1">(indentAtStart &gt; lineWidth - Math.max(</span><span class="s4">2</span><span class="s2">, </span><span class="s1">minContentWidth)) folds.push(</span><span class="s4">0</span><span class="s1">)</span><span class="s2">;</span><span class="s0">else </span><span class="s1">end = lineWidth - indentAtStart</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">split = undefined</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">prev = undefined</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">overflow = </span><span class="s0">false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">i = -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">escStart = -</span><span class="s4">1</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">escEnd = -</span><span class="s4">1</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(mode === FOLD_BLOCK) {</span>
    <span class="s1">i = consumeMoreIndentedLines(text</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(i !== -</span><span class="s4">1</span><span class="s1">) end = i + endStep</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">ch</span><span class="s2">; </span><span class="s1">ch = text[i += </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span><span class="s1">) {</span>
    <span class="s0">if </span><span class="s1">(mode === FOLD_QUOTED &amp;&amp; ch === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">) {</span>
      <span class="s1">escStart = i</span><span class="s2">;</span>

      <span class="s0">switch </span><span class="s1">(text[i + </span><span class="s4">1</span><span class="s1">]) {</span>
        <span class="s0">case </span><span class="s3">'x'</span><span class="s1">:</span>
          <span class="s1">i += </span><span class="s4">3</span><span class="s2">;</span>
          <span class="s0">break</span><span class="s2">;</span>

        <span class="s0">case </span><span class="s3">'u'</span><span class="s1">:</span>
          <span class="s1">i += </span><span class="s4">5</span><span class="s2">;</span>
          <span class="s0">break</span><span class="s2">;</span>

        <span class="s0">case </span><span class="s3">'U'</span><span class="s1">:</span>
          <span class="s1">i += </span><span class="s4">9</span><span class="s2">;</span>
          <span class="s0">break</span><span class="s2">;</span>

        <span class="s0">default</span><span class="s1">:</span>
          <span class="s1">i += </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">escEnd = i</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(ch === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
      <span class="s1">end = i + endStep</span><span class="s2">;</span>
      <span class="s1">split = undefined</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">if </span><span class="s1">(ch === </span><span class="s3">' ' </span><span class="s1">&amp;&amp; prev &amp;&amp; prev !== </span><span class="s3">' ' </span><span class="s1">&amp;&amp; prev !== </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">&amp;&amp; prev !== </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s1">) {</span>
        <span class="s6">// space surrounded by non-space can be replaced with newline + indent</span>
        <span class="s0">var </span><span class="s1">next = text[i + </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(next &amp;&amp; next !== </span><span class="s3">' ' </span><span class="s1">&amp;&amp; next !== </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">&amp;&amp; next !== </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s1">) split = i</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(i &gt;= end) {</span>
        <span class="s0">if </span><span class="s1">(split) {</span>
          <span class="s1">folds.push(split)</span><span class="s2">;</span>
          <span class="s1">end = split + endStep</span><span class="s2">;</span>
          <span class="s1">split = undefined</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s0">else if </span><span class="s1">(mode === FOLD_QUOTED) {</span>
          <span class="s6">// white-space collected at end may stretch past lineWidth</span>
          <span class="s0">while </span><span class="s1">(prev === </span><span class="s3">' ' </span><span class="s1">|| prev === </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">'</span><span class="s1">) {</span>
            <span class="s1">prev = ch</span><span class="s2">;</span>
            <span class="s1">ch = text[i += </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>
            <span class="s1">overflow = </span><span class="s0">true</span><span class="s2">;</span>
          <span class="s1">} </span><span class="s6">// Account for newline escape, but don't break preceding escape</span>


          <span class="s0">var </span><span class="s1">j = i &gt; escEnd + </span><span class="s4">1 </span><span class="s1">? i - </span><span class="s4">2 </span><span class="s1">: escStart - </span><span class="s4">1</span><span class="s2">; </span><span class="s6">// Bail out if lineWidth &amp; minContentWidth are shorter than an escape string</span>

          <span class="s0">if </span><span class="s1">(escapedFolds[j]) </span><span class="s0">return </span><span class="s1">text</span><span class="s2">;</span>
          <span class="s1">folds.push(j)</span><span class="s2">;</span>
          <span class="s1">escapedFolds[j] = </span><span class="s0">true</span><span class="s2">;</span>
          <span class="s1">end = j + endStep</span><span class="s2">;</span>
          <span class="s1">split = undefined</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s1">overflow = </span><span class="s0">true</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">prev = ch</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(overflow &amp;&amp; onOverflow) onOverflow()</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(folds.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s0">return </span><span class="s1">text</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(onFold) onFold()</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">res = text.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">folds[</span><span class="s4">0</span><span class="s1">])</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">_i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">_i &lt; folds.length</span><span class="s2">; </span><span class="s1">++_i) {</span>
    <span class="s0">var </span><span class="s1">fold = folds[_i]</span><span class="s2">;</span>

    <span class="s0">var </span><span class="s1">_end = folds[_i + </span><span class="s4">1</span><span class="s1">] || text.length</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(fold === </span><span class="s4">0</span><span class="s1">) res = </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(indent).concat(text.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">_end))</span><span class="s2">;</span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">if </span><span class="s1">(mode === FOLD_QUOTED &amp;&amp; escapedFolds[fold]) res += </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(text[fold]</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\\</span><span class="s3">&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">res += </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(indent).concat(text.slice(fold + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">_end))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">getFoldOptions = </span><span class="s0">function </span><span class="s1">getFoldOptions(_ref) {</span>
  <span class="s0">var </span><span class="s1">indentAtStart = _ref.indentAtStart</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">indentAtStart ? Object.assign({</span>
    <span class="s1">indentAtStart: indentAtStart</span>
  <span class="s1">}</span><span class="s2">, </span><span class="s1">strOptions.fold) : strOptions.fold</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">; </span><span class="s6">// Also checks for lines starting with %, as parsing the output as YAML 1.1 will</span>
<span class="s6">// presume that's starting a new document.</span>


<span class="s0">var </span><span class="s1">containsDocumentMarker = </span><span class="s0">function </span><span class="s1">containsDocumentMarker(str) {</span>
  <span class="s0">return </span><span class="s4">/^(%|---|\.\.\.)/m</span><span class="s1">.test(str)</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">lineLengthOverLimit(str</span><span class="s2">, </span><span class="s1">lineWidth</span><span class="s2">, </span><span class="s1">indentLength) {</span>
  <span class="s0">if </span><span class="s1">(!lineWidth || lineWidth &lt; </span><span class="s4">0</span><span class="s1">) </span><span class="s0">return false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">limit = lineWidth - indentLength</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">strLen = str.length</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(strLen &lt;= limit) </span><span class="s0">return false</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">start = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; strLen</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s0">if </span><span class="s1">(str[i] === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) {</span>
      <span class="s0">if </span><span class="s1">(i - start &gt; limit) </span><span class="s0">return true</span><span class="s2">;</span>
      <span class="s1">start = i + </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(strLen - start &lt;= limit) </span><span class="s0">return false</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return true</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">doubleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx) {</span>
  <span class="s0">var </span><span class="s1">implicitKey = ctx.implicitKey</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">_strOptions$doubleQuo = strOptions.doubleQuoted</span><span class="s2">,</span>
      <span class="s1">jsonEncoding = _strOptions$doubleQuo.jsonEncoding</span><span class="s2">,</span>
      <span class="s1">minMultiLineLength = _strOptions$doubleQuo.minMultiLineLength</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">json = JSON.stringify(value)</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(jsonEncoding) </span><span class="s0">return </span><span class="s1">json</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">indent = ctx.indent || (containsDocumentMarker(value) ? </span><span class="s3">'  ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">str = </span><span class="s3">''</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">start = </span><span class="s4">0</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">, </span><span class="s1">ch = json[i]</span><span class="s2">; </span><span class="s1">ch</span><span class="s2">; </span><span class="s1">ch = json[++i]) {</span>
    <span class="s0">if </span><span class="s1">(ch === </span><span class="s3">' ' </span><span class="s1">&amp;&amp; json[i + </span><span class="s4">1</span><span class="s1">] === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">&amp;&amp; json[i + </span><span class="s4">2</span><span class="s1">] === </span><span class="s3">'n'</span><span class="s1">) {</span>
      <span class="s6">// space before newline needs to be escaped to not be folded</span>
      <span class="s1">str += json.slice(start</span><span class="s2">, </span><span class="s1">i) + </span><span class="s3">'</span><span class="s2">\\ </span><span class="s3">'</span><span class="s2">;</span>
      <span class="s1">i += </span><span class="s4">1</span><span class="s2">;</span>
      <span class="s1">start = i</span><span class="s2">;</span>
      <span class="s1">ch = </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(ch === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s1">) </span><span class="s0">switch </span><span class="s1">(json[i + </span><span class="s4">1</span><span class="s1">]) {</span>
      <span class="s0">case </span><span class="s3">'u'</span><span class="s1">:</span>
        <span class="s1">{</span>
          <span class="s1">str += json.slice(start</span><span class="s2">, </span><span class="s1">i)</span><span class="s2">;</span>
          <span class="s0">var </span><span class="s1">code = json.substr(i + </span><span class="s4">2</span><span class="s2">, </span><span class="s4">4</span><span class="s1">)</span><span class="s2">;</span>

          <span class="s0">switch </span><span class="s1">(code) {</span>
            <span class="s0">case </span><span class="s3">'0000'</span><span class="s1">:</span>
              <span class="s1">str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">0'</span><span class="s2">;</span>
              <span class="s0">break</span><span class="s2">;</span>

            <span class="s0">case </span><span class="s3">'0007'</span><span class="s1">:</span>
              <span class="s1">str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">a'</span><span class="s2">;</span>
              <span class="s0">break</span><span class="s2">;</span>

            <span class="s0">case </span><span class="s3">'000b'</span><span class="s1">:</span>
              <span class="s1">str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">v'</span><span class="s2">;</span>
              <span class="s0">break</span><span class="s2">;</span>

            <span class="s0">case </span><span class="s3">'001b'</span><span class="s1">:</span>
              <span class="s1">str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">e'</span><span class="s2">;</span>
              <span class="s0">break</span><span class="s2">;</span>

            <span class="s0">case </span><span class="s3">'0085'</span><span class="s1">:</span>
              <span class="s1">str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">N'</span><span class="s2">;</span>
              <span class="s0">break</span><span class="s2">;</span>

            <span class="s0">case </span><span class="s3">'00a0'</span><span class="s1">:</span>
              <span class="s1">str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">_'</span><span class="s2">;</span>
              <span class="s0">break</span><span class="s2">;</span>

            <span class="s0">case </span><span class="s3">'2028'</span><span class="s1">:</span>
              <span class="s1">str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">L'</span><span class="s2">;</span>
              <span class="s0">break</span><span class="s2">;</span>

            <span class="s0">case </span><span class="s3">'2029'</span><span class="s1">:</span>
              <span class="s1">str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">P'</span><span class="s2">;</span>
              <span class="s0">break</span><span class="s2">;</span>

            <span class="s0">default</span><span class="s1">:</span>
              <span class="s0">if </span><span class="s1">(code.substr(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">2</span><span class="s1">) === </span><span class="s3">'00'</span><span class="s1">) str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">x' </span><span class="s1">+ code.substr(</span><span class="s4">2</span><span class="s1">)</span><span class="s2">;</span><span class="s0">else </span><span class="s1">str += json.substr(i</span><span class="s2">, </span><span class="s4">6</span><span class="s1">)</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s1">i += </span><span class="s4">5</span><span class="s2">;</span>
          <span class="s1">start = i + </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s3">'n'</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">(implicitKey || json[i + </span><span class="s4">2</span><span class="s1">] === </span><span class="s3">'&quot;' </span><span class="s1">|| json.length &lt; minMultiLineLength) {</span>
          <span class="s1">i += </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s6">// folding will eat first newline</span>
          <span class="s1">str += json.slice(start</span><span class="s2">, </span><span class="s1">i) + </span><span class="s3">'</span><span class="s2">\n\n</span><span class="s3">'</span><span class="s2">;</span>

          <span class="s0">while </span><span class="s1">(json[i + </span><span class="s4">2</span><span class="s1">] === </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">' </span><span class="s1">&amp;&amp; json[i + </span><span class="s4">3</span><span class="s1">] === </span><span class="s3">'n' </span><span class="s1">&amp;&amp; json[i + </span><span class="s4">4</span><span class="s1">] !== </span><span class="s3">'&quot;'</span><span class="s1">) {</span>
            <span class="s1">str += </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
            <span class="s1">i += </span><span class="s4">2</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s1">str += indent</span><span class="s2">; </span><span class="s6">// space after newline needs to be escaped to not be folded</span>

          <span class="s0">if </span><span class="s1">(json[i + </span><span class="s4">2</span><span class="s1">] === </span><span class="s3">' '</span><span class="s1">) str += </span><span class="s3">'</span><span class="s2">\\</span><span class="s3">'</span><span class="s2">;</span>
          <span class="s1">i += </span><span class="s4">1</span><span class="s2">;</span>
          <span class="s1">start = i + </span><span class="s4">1</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">default</span><span class="s1">:</span>
        <span class="s1">i += </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">str = start ? str + json.slice(start) : json</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">implicitKey ? str : foldFlowLines(str</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">FOLD_QUOTED</span><span class="s2">, </span><span class="s1">getFoldOptions(ctx))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">singleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx) {</span>
  <span class="s0">if </span><span class="s1">(ctx.implicitKey) {</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s4">/\n/</span><span class="s1">.test(value)) </span><span class="s0">return </span><span class="s1">doubleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s6">// single quoted string can't have leading or trailing whitespace around newline</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s4">/[ \t]\n|\n[ \t]/</span><span class="s1">.test(value)) </span><span class="s0">return </span><span class="s1">doubleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">indent = ctx.indent || (containsDocumentMarker(value) ? </span><span class="s3">'  ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">res = </span><span class="s3">&quot;'&quot; </span><span class="s1">+ value.replace(</span><span class="s4">/'/g</span><span class="s2">, </span><span class="s3">&quot;''&quot;</span><span class="s1">).replace(</span><span class="s4">/\n+/g</span><span class="s2">, </span><span class="s3">&quot;$&amp;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(indent)) + </span><span class="s3">&quot;'&quot;</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">ctx.implicitKey ? res : foldFlowLines(res</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">FOLD_FLOW</span><span class="s2">, </span><span class="s1">getFoldOptions(ctx))</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">blockString(_ref2</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep) {</span>
  <span class="s0">var </span><span class="s1">comment = _ref2.comment</span><span class="s2">,</span>
      <span class="s1">type = _ref2.type</span><span class="s2">,</span>
      <span class="s1">value = _ref2.value</span><span class="s2">;</span>

  <span class="s6">// 1. Block can't end in whitespace unless the last line is non-empty.</span>
  <span class="s6">// 2. Strings consisting of only whitespace are best rendered explicitly.</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s4">/\n[\t ]+$/</span><span class="s1">.test(value) || </span><span class="s4">/^\s*$/</span><span class="s1">.test(value)) {</span>
    <span class="s0">return </span><span class="s1">doubleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? </span><span class="s3">'  ' </span><span class="s1">: </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">indentSize = indent ? </span><span class="s3">'2' </span><span class="s1">: </span><span class="s3">'1'</span><span class="s2">; </span><span class="s6">// root is at -1</span>

  <span class="s0">var </span><span class="s1">literal = type === Type.BLOCK_FOLDED ? </span><span class="s0">false </span><span class="s1">: type === Type.BLOCK_LITERAL ? </span><span class="s0">true </span><span class="s1">: !lineLengthOverLimit(value</span><span class="s2">, </span><span class="s1">strOptions.fold.lineWidth</span><span class="s2">, </span><span class="s1">indent.length)</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">header = literal ? </span><span class="s3">'|' </span><span class="s1">: </span><span class="s3">'&gt;'</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(!value) </span><span class="s0">return </span><span class="s1">header + </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">wsStart = </span><span class="s3">''</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">wsEnd = </span><span class="s3">''</span><span class="s2">;</span>
  <span class="s1">value = value.replace(</span><span class="s4">/[\n\t ]*$/</span><span class="s2">, </span><span class="s0">function </span><span class="s1">(ws) {</span>
    <span class="s0">var </span><span class="s1">n = ws.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(n === -</span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">header += </span><span class="s3">'-'</span><span class="s2">; </span><span class="s6">// strip</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(value === ws || n !== ws.length - </span><span class="s4">1</span><span class="s1">) {</span>
      <span class="s1">header += </span><span class="s3">'+'</span><span class="s2">; </span><span class="s6">// keep</span>

      <span class="s0">if </span><span class="s1">(onChompKeep) onChompKeep()</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">wsEnd = ws.replace(</span><span class="s4">/\n$/</span><span class="s2">, </span><span class="s3">''</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s3">''</span><span class="s2">;</span>
  <span class="s1">}).replace(</span><span class="s4">/^[\n ]*/</span><span class="s2">, </span><span class="s0">function </span><span class="s1">(ws) {</span>
    <span class="s0">if </span><span class="s1">(ws.indexOf(</span><span class="s3">' '</span><span class="s1">) !== -</span><span class="s4">1</span><span class="s1">) header += indentSize</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">m = ws.match(</span><span class="s4">/ +$/</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(m) {</span>
      <span class="s1">wsStart = ws.slice(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">-m[</span><span class="s4">0</span><span class="s1">].length)</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">m[</span><span class="s4">0</span><span class="s1">]</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">wsStart = ws</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s3">''</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(wsEnd) wsEnd = wsEnd.replace(</span><span class="s4">/\n+(?!\n|$)/g</span><span class="s2">, </span><span class="s3">&quot;$&amp;&quot;</span><span class="s1">.concat(indent))</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(wsStart) wsStart = wsStart.replace(</span><span class="s4">/\n+/g</span><span class="s2">, </span><span class="s3">&quot;$&amp;&quot;</span><span class="s1">.concat(indent))</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(comment) {</span>
    <span class="s1">header += </span><span class="s3">' #' </span><span class="s1">+ comment.replace(</span><span class="s4">/ ?[\r\n]+/g</span><span class="s2">, </span><span class="s3">' '</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(onComment) onComment()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(!value) </span><span class="s0">return </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(header).concat(indentSize</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">).concat(indent).concat(wsEnd)</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(literal) {</span>
    <span class="s1">value = value.replace(</span><span class="s4">/\n+/g</span><span class="s2">, </span><span class="s3">&quot;$&amp;&quot;</span><span class="s1">.concat(indent))</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(header</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">).concat(indent).concat(wsStart).concat(value).concat(wsEnd)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">value = value.replace(</span><span class="s4">/\n+/g</span><span class="s2">, </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">$&amp;'</span><span class="s1">).replace(</span><span class="s4">/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g</span><span class="s2">, </span><span class="s3">'$1$2'</span><span class="s1">) </span><span class="s6">// more-indented lines aren't folded</span>
  <span class="s6">//         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent</span>
  <span class="s1">.replace(</span><span class="s4">/\n+/g</span><span class="s2">, </span><span class="s3">&quot;$&amp;&quot;</span><span class="s1">.concat(indent))</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">body = foldFlowLines(</span><span class="s3">&quot;&quot;</span><span class="s1">.concat(wsStart).concat(value).concat(wsEnd)</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">FOLD_BLOCK</span><span class="s2">, </span><span class="s1">strOptions.fold)</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(header</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">).concat(indent).concat(body)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">plainString(item</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep) {</span>
  <span class="s0">var </span><span class="s1">comment = item.comment</span><span class="s2">,</span>
      <span class="s1">type = item.type</span><span class="s2">,</span>
      <span class="s1">value = item.value</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">actualString = ctx.actualString</span><span class="s2">,</span>
      <span class="s1">implicitKey = ctx.implicitKey</span><span class="s2">,</span>
      <span class="s1">indent = ctx.indent</span><span class="s2">,</span>
      <span class="s1">inFlow = ctx.inFlow</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(implicitKey &amp;&amp; </span><span class="s4">/[\n[\]{},]/</span><span class="s1">.test(value) || inFlow &amp;&amp; </span><span class="s4">/[[\]{},]/</span><span class="s1">.test(value)) {</span>
    <span class="s0">return </span><span class="s1">doubleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(!value || </span><span class="s4">/^[\n\t ,[\]{}#&amp;*!|&gt;'&quot;%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/</span><span class="s1">.test(value)) {</span>
    <span class="s6">// not allowed:</span>
    <span class="s6">// - empty string, '-' or '?'</span>
    <span class="s6">// - start with an indicator character (except [?:-]) or /[?-] /</span>
    <span class="s6">// - '\n ', ': ' or ' \n' anywhere</span>
    <span class="s6">// - '#' not preceded by a non-space char</span>
    <span class="s6">// - end with ' ' or ':'</span>
    <span class="s0">return </span><span class="s1">implicitKey || inFlow || value.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) === -</span><span class="s4">1 </span><span class="s1">? value.indexOf(</span><span class="s3">'&quot;'</span><span class="s1">) !== -</span><span class="s4">1 </span><span class="s1">&amp;&amp; value.indexOf(</span><span class="s3">&quot;'&quot;</span><span class="s1">) === -</span><span class="s4">1 </span><span class="s1">? singleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx) : doubleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx) : blockString(item</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(!implicitKey &amp;&amp; !inFlow &amp;&amp; type !== Type.PLAIN &amp;&amp; value.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) !== -</span><span class="s4">1</span><span class="s1">) {</span>
    <span class="s6">// Where allowed &amp; type not set explicitly, prefer block style for multiline strings</span>
    <span class="s0">return </span><span class="s1">blockString(item</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(indent === </span><span class="s3">'' </span><span class="s1">&amp;&amp; containsDocumentMarker(value)) {</span>
    <span class="s1">ctx.forceBlockIndent = </span><span class="s0">true</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">blockString(item</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">str = value.replace(</span><span class="s4">/\n+/g</span><span class="s2">, </span><span class="s3">&quot;$&amp;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">.concat(indent))</span><span class="s2">; </span><span class="s6">// Verify that output will be parsed as a string, as e.g. plain numbers and</span>
  <span class="s6">// booleans get parsed with those types in v1.2 (e.g. '42', 'true' &amp; '0.9e-3'),</span>
  <span class="s6">// and others in v1.1.</span>

  <span class="s0">if </span><span class="s1">(actualString) {</span>
    <span class="s0">var </span><span class="s1">tags = ctx.doc.schema.tags</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">resolved = resolveScalar(str</span><span class="s2">, </span><span class="s1">tags</span><span class="s2">, </span><span class="s1">tags.scalarFallback).value</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">resolved !== </span><span class="s3">'string'</span><span class="s1">) </span><span class="s0">return </span><span class="s1">doubleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">body = implicitKey ? str : foldFlowLines(str</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">FOLD_FLOW</span><span class="s2">, </span><span class="s1">getFoldOptions(ctx))</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(comment &amp;&amp; !inFlow &amp;&amp; (body.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) !== -</span><span class="s4">1 </span><span class="s1">|| comment.indexOf(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) !== -</span><span class="s4">1</span><span class="s1">)) {</span>
    <span class="s0">if </span><span class="s1">(onComment) onComment()</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">addCommentBefore(body</span><span class="s2">, </span><span class="s1">indent</span><span class="s2">, </span><span class="s1">comment)</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">body</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">stringifyString(item</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep) {</span>
  <span class="s0">var </span><span class="s1">defaultType = strOptions.defaultType</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">implicitKey = ctx.implicitKey</span><span class="s2">,</span>
      <span class="s1">inFlow = ctx.inFlow</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">_item = item</span><span class="s2">,</span>
      <span class="s1">type = _item.type</span><span class="s2">,</span>
      <span class="s1">value = _item.value</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value !== </span><span class="s3">'string'</span><span class="s1">) {</span>
    <span class="s1">value = String(value)</span><span class="s2">;</span>
    <span class="s1">item = Object.assign({}</span><span class="s2">, </span><span class="s1">item</span><span class="s2">, </span><span class="s1">{</span>
      <span class="s1">value: value</span>
    <span class="s1">})</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">_stringify = </span><span class="s0">function </span><span class="s1">_stringify(_type) {</span>
    <span class="s0">switch </span><span class="s1">(_type) {</span>
      <span class="s0">case </span><span class="s1">Type.BLOCK_FOLDED:</span>
      <span class="s0">case </span><span class="s1">Type.BLOCK_LITERAL:</span>
        <span class="s0">return </span><span class="s1">blockString(item</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep)</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s1">Type.QUOTE_DOUBLE:</span>
        <span class="s0">return </span><span class="s1">doubleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s1">Type.QUOTE_SINGLE:</span>
        <span class="s0">return </span><span class="s1">singleQuotedString(value</span><span class="s2">, </span><span class="s1">ctx)</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s1">Type.PLAIN:</span>
        <span class="s0">return </span><span class="s1">plainString(item</span><span class="s2">, </span><span class="s1">ctx</span><span class="s2">, </span><span class="s1">onComment</span><span class="s2">, </span><span class="s1">onChompKeep)</span><span class="s2">;</span>

      <span class="s0">default</span><span class="s1">:</span>
        <span class="s0">return null</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(type !== Type.QUOTE_DOUBLE &amp;&amp; </span><span class="s4">/[\x00-\x08\x0b-\x1f\x7f-\x9f]/</span><span class="s1">.test(value)) {</span>
    <span class="s6">// force double quotes on control characters</span>
    <span class="s1">type = Type.QUOTE_DOUBLE</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">else if </span><span class="s1">((implicitKey || inFlow) &amp;&amp; (type === Type.BLOCK_FOLDED || type === Type.BLOCK_LITERAL)) {</span>
    <span class="s6">// should not happen; blocks are not valid inside flow containers</span>
    <span class="s1">type = Type.QUOTE_DOUBLE</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">res = _stringify(type)</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(res === </span><span class="s0">null</span><span class="s1">) {</span>
    <span class="s1">res = _stringify(defaultType)</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(res === </span><span class="s0">null</span><span class="s1">) </span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">&quot;Unsupported default string type &quot;</span><span class="s1">.concat(defaultType))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">res</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">stringifyNumber(_ref) {</span>
  <span class="s0">var </span><span class="s1">format = _ref.format</span><span class="s2">,</span>
      <span class="s1">minFractionDigits = _ref.minFractionDigits</span><span class="s2">,</span>
      <span class="s1">tag = _ref.tag</span><span class="s2">,</span>
      <span class="s1">value = _ref.value</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">value === </span><span class="s3">'bigint'</span><span class="s1">) </span><span class="s0">return </span><span class="s1">String(value)</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(!isFinite(value)) </span><span class="s0">return </span><span class="s1">isNaN(value) ? </span><span class="s3">'.nan' </span><span class="s1">: value &lt; </span><span class="s4">0 </span><span class="s1">? </span><span class="s3">'-.inf' </span><span class="s1">: </span><span class="s3">'.inf'</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">n = JSON.stringify(value)</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(!format &amp;&amp; minFractionDigits &amp;&amp; (!tag || tag === </span><span class="s3">'tag:yaml.org,2002:float'</span><span class="s1">) &amp;&amp; </span><span class="s4">/^\d/</span><span class="s1">.test(n)) {</span>
    <span class="s0">var </span><span class="s1">i = n.indexOf(</span><span class="s3">'.'</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(i &lt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">i = n.length</span><span class="s2">;</span>
      <span class="s1">n += </span><span class="s3">'.'</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">var </span><span class="s1">d = minFractionDigits - (n.length - i - </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s0">while </span><span class="s1">(d-- &gt; </span><span class="s4">0</span><span class="s1">) {</span>
      <span class="s1">n += </span><span class="s3">'0'</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">n</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">checkFlowCollectionEnd(errors</span><span class="s2">, </span><span class="s1">cst) {</span>
  <span class="s0">var </span><span class="s1">char</span><span class="s2">, </span><span class="s1">name</span><span class="s2">;</span>

  <span class="s0">switch </span><span class="s1">(cst.type) {</span>
    <span class="s0">case </span><span class="s1">Type.FLOW_MAP:</span>
      <span class="s1">char = </span><span class="s3">'}'</span><span class="s2">;</span>
      <span class="s1">name = </span><span class="s3">'flow map'</span><span class="s2">;</span>
      <span class="s0">break</span><span class="s2">;</span>

    <span class="s0">case </span><span class="s1">Type.FLOW_SEQ:</span>
      <span class="s1">char = </span><span class="s3">']'</span><span class="s2">;</span>
      <span class="s1">name = </span><span class="s3">'flow sequence'</span><span class="s2">;</span>
      <span class="s0">break</span><span class="s2">;</span>

    <span class="s0">default</span><span class="s1">:</span>
      <span class="s1">errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(cst</span><span class="s2">, </span><span class="s3">'Not a flow collection!?'</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s0">return</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">lastItem</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = cst.items.length - </span><span class="s4">1</span><span class="s2">; </span><span class="s1">i &gt;= </span><span class="s4">0</span><span class="s2">; </span><span class="s1">--i) {</span>
    <span class="s0">var </span><span class="s1">item = cst.items[i]</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(!item || item.type !== Type.COMMENT) {</span>
      <span class="s1">lastItem = item</span><span class="s2">;</span>
      <span class="s0">break</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(lastItem &amp;&amp; lastItem.char !== char) {</span>
    <span class="s0">var </span><span class="s1">msg = </span><span class="s3">&quot;Expected &quot;</span><span class="s1">.concat(name</span><span class="s2">, </span><span class="s3">&quot; to end with &quot;</span><span class="s1">).concat(char)</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">err</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">lastItem.offset === </span><span class="s3">'number'</span><span class="s1">) {</span>
      <span class="s1">err = </span><span class="s0">new </span><span class="s1">YAMLSemanticError(cst</span><span class="s2">, </span><span class="s1">msg)</span><span class="s2">;</span>
      <span class="s1">err.offset = lastItem.offset + </span><span class="s4">1</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s1">err = </span><span class="s0">new </span><span class="s1">YAMLSemanticError(lastItem</span><span class="s2">, </span><span class="s1">msg)</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(lastItem.range &amp;&amp; lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s1">errors.push(err)</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">checkFlowCommentSpace(errors</span><span class="s2">, </span><span class="s1">comment) {</span>
  <span class="s0">var </span><span class="s1">prev = comment.context.src[comment.range.start - </span><span class="s4">1</span><span class="s1">]</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(prev !== </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">&amp;&amp; prev !== </span><span class="s3">'</span><span class="s2">\t</span><span class="s3">' </span><span class="s1">&amp;&amp; prev !== </span><span class="s3">' '</span><span class="s1">) {</span>
    <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'Comments must be separated from other tokens by white space characters'</span><span class="s2">;</span>
    <span class="s1">errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(comment</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">getLongKeyError(source</span><span class="s2">, </span><span class="s1">key) {</span>
  <span class="s0">var </span><span class="s1">sk = String(key)</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">k = sk.substr(</span><span class="s4">0</span><span class="s2">, </span><span class="s4">8</span><span class="s1">) + </span><span class="s3">'...' </span><span class="s1">+ sk.substr(-</span><span class="s4">8</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s0">return new </span><span class="s1">YAMLSemanticError(source</span><span class="s2">, </span><span class="s3">&quot;The </span><span class="s2">\&quot;</span><span class="s3">&quot;</span><span class="s1">.concat(k</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\&quot; </span><span class="s3">key is too long&quot;</span><span class="s1">))</span><span class="s2">;</span>
<span class="s1">}</span>
<span class="s0">function </span><span class="s1">resolveComments(collection</span><span class="s2">, </span><span class="s1">comments) {</span>
  <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(comments)</span><span class="s2">,</span>
      <span class="s1">_step</span><span class="s2">;</span>

  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">_step$value = _step.value</span><span class="s2">,</span>
          <span class="s1">afterKey = _step$value.afterKey</span><span class="s2">,</span>
          <span class="s1">before = _step$value.before</span><span class="s2">,</span>
          <span class="s1">comment = _step$value.comment</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">item = collection.items[before]</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(!item) {</span>
        <span class="s0">if </span><span class="s1">(comment !== undefined) {</span>
          <span class="s0">if </span><span class="s1">(collection.comment) collection.comment += </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ comment</span><span class="s2">;</span><span class="s0">else </span><span class="s1">collection.comment = comment</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">if </span><span class="s1">(afterKey &amp;&amp; item.value) item = item.value</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(comment === undefined) {</span>
          <span class="s0">if </span><span class="s1">(afterKey || !item.commentBefore) item.spaceBefore = </span><span class="s0">true</span><span class="s2">;</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s0">if </span><span class="s1">(item.commentBefore) item.commentBefore += </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">' </span><span class="s1">+ comment</span><span class="s2">;</span><span class="s0">else </span><span class="s1">item.commentBefore = comment</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
    <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
    <span class="s1">_iterator.f()</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">// on error, will return { str: string, errors: Error[] }</span>
<span class="s0">function </span><span class="s1">resolveString(doc</span><span class="s2">, </span><span class="s1">node) {</span>
  <span class="s0">var </span><span class="s1">res = node.strValue</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(!res) </span><span class="s0">return </span><span class="s3">''</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">res === </span><span class="s3">'string'</span><span class="s1">) </span><span class="s0">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">res.errors.forEach(</span><span class="s0">function </span><span class="s1">(error) {</span>
    <span class="s0">if </span><span class="s1">(!error.source) error.source = node</span><span class="s2">;</span>
    <span class="s1">doc.errors.push(error)</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">res.str</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveTagHandle(doc</span><span class="s2">, </span><span class="s1">node) {</span>
  <span class="s0">var </span><span class="s1">_node$tag = node.tag</span><span class="s2">,</span>
      <span class="s1">handle = _node$tag.handle</span><span class="s2">,</span>
      <span class="s1">suffix = _node$tag.suffix</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">prefix = doc.tagPrefixes.find(</span><span class="s0">function </span><span class="s1">(p) {</span>
    <span class="s0">return </span><span class="s1">p.handle === handle</span><span class="s2">;</span>
  <span class="s1">})</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(!prefix) {</span>
    <span class="s0">var </span><span class="s1">dtp = doc.getDefaults().tagPrefixes</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(dtp) prefix = dtp.find(</span><span class="s0">function </span><span class="s1">(p) {</span>
      <span class="s0">return </span><span class="s1">p.handle === handle</span><span class="s2">;</span>
    <span class="s1">})</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(!prefix) </span><span class="s0">throw new </span><span class="s1">YAMLSemanticError(node</span><span class="s2">, </span><span class="s3">&quot;The &quot;</span><span class="s1">.concat(handle</span><span class="s2">, </span><span class="s3">&quot; tag handle is non-default and was not declared.&quot;</span><span class="s1">))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(!suffix) </span><span class="s0">throw new </span><span class="s1">YAMLSemanticError(node</span><span class="s2">, </span><span class="s3">&quot;The &quot;</span><span class="s1">.concat(handle</span><span class="s2">, </span><span class="s3">&quot; tag has no suffix.&quot;</span><span class="s1">))</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(handle === </span><span class="s3">'!' </span><span class="s1">&amp;&amp; (doc.version || doc.options.version) === </span><span class="s3">'1.0'</span><span class="s1">) {</span>
    <span class="s0">if </span><span class="s1">(suffix[</span><span class="s4">0</span><span class="s1">] === </span><span class="s3">'^'</span><span class="s1">) {</span>
      <span class="s1">doc.warnings.push(</span><span class="s0">new </span><span class="s1">YAMLWarning(node</span><span class="s2">, </span><span class="s3">'YAML 1.0 ^ tag expansion is not supported'</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">suffix</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s4">/[:/]/</span><span class="s1">.test(suffix)) {</span>
      <span class="s6">// word/foo -&gt; tag:word.yaml.org,2002:foo</span>
      <span class="s0">var </span><span class="s1">vocab = suffix.match(</span><span class="s4">/^([a-z0-9-]+)\/(.*)/i</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">vocab ? </span><span class="s3">&quot;tag:&quot;</span><span class="s1">.concat(vocab[</span><span class="s4">1</span><span class="s1">]</span><span class="s2">, </span><span class="s3">&quot;.yaml.org,2002:&quot;</span><span class="s1">).concat(vocab[</span><span class="s4">2</span><span class="s1">]) : </span><span class="s3">&quot;tag:&quot;</span><span class="s1">.concat(suffix)</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">prefix.prefix + decodeURIComponent(suffix)</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveTagName(doc</span><span class="s2">, </span><span class="s1">node) {</span>
  <span class="s0">var </span><span class="s1">tag = node.tag</span><span class="s2">,</span>
      <span class="s1">type = node.type</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">nonSpecific = </span><span class="s0">false</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(tag) {</span>
    <span class="s0">var </span><span class="s1">handle = tag.handle</span><span class="s2">,</span>
        <span class="s1">suffix = tag.suffix</span><span class="s2">,</span>
        <span class="s1">verbatim = tag.verbatim</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(verbatim) {</span>
      <span class="s0">if </span><span class="s1">(verbatim !== </span><span class="s3">'!' </span><span class="s1">&amp;&amp; verbatim !== </span><span class="s3">'!!'</span><span class="s1">) </span><span class="s0">return </span><span class="s1">verbatim</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">msg = </span><span class="s3">&quot;Verbatim tags aren't resolved, so &quot;</span><span class="s1">.concat(verbatim</span><span class="s2">, </span><span class="s3">&quot; is invalid.&quot;</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(node</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(handle === </span><span class="s3">'!' </span><span class="s1">&amp;&amp; !suffix) {</span>
      <span class="s1">nonSpecific = </span><span class="s0">true</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">try </span><span class="s1">{</span>
        <span class="s0">return </span><span class="s1">resolveTagHandle(doc</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
        <span class="s1">doc.errors.push(error)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">switch </span><span class="s1">(type) {</span>
    <span class="s0">case </span><span class="s1">Type.BLOCK_FOLDED:</span>
    <span class="s0">case </span><span class="s1">Type.BLOCK_LITERAL:</span>
    <span class="s0">case </span><span class="s1">Type.QUOTE_DOUBLE:</span>
    <span class="s0">case </span><span class="s1">Type.QUOTE_SINGLE:</span>
      <span class="s0">return </span><span class="s1">defaultTags.STR</span><span class="s2">;</span>

    <span class="s0">case </span><span class="s1">Type.FLOW_MAP:</span>
    <span class="s0">case </span><span class="s1">Type.MAP:</span>
      <span class="s0">return </span><span class="s1">defaultTags.MAP</span><span class="s2">;</span>

    <span class="s0">case </span><span class="s1">Type.FLOW_SEQ:</span>
    <span class="s0">case </span><span class="s1">Type.SEQ:</span>
      <span class="s0">return </span><span class="s1">defaultTags.SEQ</span><span class="s2">;</span>

    <span class="s0">case </span><span class="s1">Type.PLAIN:</span>
      <span class="s0">return </span><span class="s1">nonSpecific ? defaultTags.STR : </span><span class="s0">null</span><span class="s2">;</span>

    <span class="s0">default</span><span class="s1">:</span>
      <span class="s0">return null</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveByTagName(doc</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">tagName) {</span>
  <span class="s0">var </span><span class="s1">tags = doc.schema.tags</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">matchWithTest = []</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(tags)</span><span class="s2">,</span>
      <span class="s1">_step</span><span class="s2">;</span>

  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">tag = _step.value</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(tag.tag === tagName) {</span>
        <span class="s0">if </span><span class="s1">(tag.test) matchWithTest.push(tag)</span><span class="s2">;</span><span class="s0">else </span><span class="s1">{</span>
          <span class="s0">var </span><span class="s1">res = tag.resolve(doc</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
          <span class="s0">return </span><span class="s1">res </span><span class="s0">instanceof </span><span class="s1">Collection ? res : </span><span class="s0">new </span><span class="s1">Scalar(res)</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
    <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
    <span class="s1">_iterator.f()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">str = resolveString(doc</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">str === </span><span class="s3">'string' </span><span class="s1">&amp;&amp; matchWithTest.length &gt; </span><span class="s4">0</span><span class="s1">) </span><span class="s0">return </span><span class="s1">resolveScalar(str</span><span class="s2">, </span><span class="s1">matchWithTest</span><span class="s2">, </span><span class="s1">tags.scalarFallback)</span><span class="s2">;</span>
  <span class="s0">return null</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">getFallbackTagName(_ref) {</span>
  <span class="s0">var </span><span class="s1">type = _ref.type</span><span class="s2">;</span>

  <span class="s0">switch </span><span class="s1">(type) {</span>
    <span class="s0">case </span><span class="s1">Type.FLOW_MAP:</span>
    <span class="s0">case </span><span class="s1">Type.MAP:</span>
      <span class="s0">return </span><span class="s1">defaultTags.MAP</span><span class="s2">;</span>

    <span class="s0">case </span><span class="s1">Type.FLOW_SEQ:</span>
    <span class="s0">case </span><span class="s1">Type.SEQ:</span>
      <span class="s0">return </span><span class="s1">defaultTags.SEQ</span><span class="s2">;</span>

    <span class="s0">default</span><span class="s1">:</span>
      <span class="s0">return </span><span class="s1">defaultTags.STR</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveTag(doc</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">tagName) {</span>
  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">var </span><span class="s1">res = resolveByTagName(doc</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">tagName)</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(res) {</span>
      <span class="s0">if </span><span class="s1">(tagName &amp;&amp; node.tag) res.tag = tagName</span><span class="s2">;</span>
      <span class="s0">return </span><span class="s1">res</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
    <span class="s5">/* istanbul ignore if */</span>
    <span class="s0">if </span><span class="s1">(!error.source) error.source = node</span><span class="s2">;</span>
    <span class="s1">doc.errors.push(error)</span><span class="s2">;</span>
    <span class="s0">return null</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">var </span><span class="s1">fallback = getFallbackTagName(node)</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(!fallback) </span><span class="s0">throw new </span><span class="s1">Error(</span><span class="s3">&quot;The tag &quot;</span><span class="s1">.concat(tagName</span><span class="s2">, </span><span class="s3">&quot; is unavailable&quot;</span><span class="s1">))</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">msg = </span><span class="s3">&quot;The tag &quot;</span><span class="s1">.concat(tagName</span><span class="s2">, </span><span class="s3">&quot; is unavailable, falling back to &quot;</span><span class="s1">).concat(fallback)</span><span class="s2">;</span>
    <span class="s1">doc.warnings.push(</span><span class="s0">new </span><span class="s1">YAMLWarning(node</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>

    <span class="s0">var </span><span class="s1">_res = resolveByTagName(doc</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">fallback)</span><span class="s2">;</span>

    <span class="s1">_res.tag = tagName</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">_res</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
    <span class="s0">var </span><span class="s1">refError = </span><span class="s0">new </span><span class="s1">YAMLReferenceError(node</span><span class="s2">, </span><span class="s1">error.message)</span><span class="s2">;</span>
    <span class="s1">refError.stack = error.stack</span><span class="s2">;</span>
    <span class="s1">doc.errors.push(refError)</span><span class="s2">;</span>
    <span class="s0">return null</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">isCollectionItem = </span><span class="s0">function </span><span class="s1">isCollectionItem(node) {</span>
  <span class="s0">if </span><span class="s1">(!node) </span><span class="s0">return false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">type = node.type</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">type === Type.MAP_KEY || type === Type.MAP_VALUE || type === Type.SEQ_ITEM</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">resolveNodeProps(errors</span><span class="s2">, </span><span class="s1">node) {</span>
  <span class="s0">var </span><span class="s1">comments = {</span>
    <span class="s1">before: []</span><span class="s2">,</span>
    <span class="s1">after: []</span>
  <span class="s1">}</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">hasAnchor = </span><span class="s0">false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">hasTag = </span><span class="s0">false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_iterator = _createForOfIteratorHelper(props)</span><span class="s2">,</span>
      <span class="s1">_step</span><span class="s2">;</span>

  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">for </span><span class="s1">(_iterator.s()</span><span class="s2">; </span><span class="s1">!(_step = _iterator.n()).done</span><span class="s2">;</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">_step$value = _step.value</span><span class="s2">,</span>
          <span class="s1">start = _step$value.start</span><span class="s2">,</span>
          <span class="s1">end = _step$value.end</span><span class="s2">;</span>

      <span class="s0">switch </span><span class="s1">(node.context.src[start]) {</span>
        <span class="s0">case </span><span class="s1">Char.COMMENT:</span>
          <span class="s1">{</span>
            <span class="s0">if </span><span class="s1">(!node.commentHasRequiredWhitespace(start)) {</span>
              <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'Comments must be separated from other tokens by white space characters'</span><span class="s2">;</span>
              <span class="s1">errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(node</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
            <span class="s1">}</span>

            <span class="s0">var </span><span class="s1">header = node.header</span><span class="s2">,</span>
                <span class="s1">valueRange = node.valueRange</span><span class="s2">;</span>
            <span class="s0">var </span><span class="s1">cc = valueRange &amp;&amp; (start &gt; valueRange.start || header &amp;&amp; start &gt; header.start) ? comments.after : comments.before</span><span class="s2">;</span>
            <span class="s1">cc.push(node.context.src.slice(start + </span><span class="s4">1</span><span class="s2">, </span><span class="s1">end))</span><span class="s2">;</span>
            <span class="s0">break</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s6">// Actual anchor &amp; tag resolution is handled by schema, here we just complain</span>

        <span class="s0">case </span><span class="s1">Char.ANCHOR:</span>
          <span class="s0">if </span><span class="s1">(hasAnchor) {</span>
            <span class="s0">var </span><span class="s1">_msg = </span><span class="s3">'A node can have at most one anchor'</span><span class="s2">;</span>
            <span class="s1">errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(node</span><span class="s2">, </span><span class="s1">_msg))</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s1">hasAnchor = </span><span class="s0">true</span><span class="s2">;</span>
          <span class="s0">break</span><span class="s2">;</span>

        <span class="s0">case </span><span class="s1">Char.TAG:</span>
          <span class="s0">if </span><span class="s1">(hasTag) {</span>
            <span class="s0">var </span><span class="s1">_msg2 = </span><span class="s3">'A node can have at most one tag'</span><span class="s2">;</span>
            <span class="s1">errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(node</span><span class="s2">, </span><span class="s1">_msg2))</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s1">hasTag = </span><span class="s0">true</span><span class="s2">;</span>
          <span class="s0">break</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(err) {</span>
    <span class="s1">_iterator.e(err)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">finally </span><span class="s1">{</span>
    <span class="s1">_iterator.f()</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">comments: comments</span><span class="s2">,</span>
    <span class="s1">hasAnchor: hasAnchor</span><span class="s2">,</span>
    <span class="s1">hasTag: hasTag</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveNodeValue(doc</span><span class="s2">, </span><span class="s1">node) {</span>
  <span class="s0">var </span><span class="s1">anchors = doc.anchors</span><span class="s2">,</span>
      <span class="s1">errors = doc.errors</span><span class="s2">,</span>
      <span class="s1">schema = doc.schema</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(node.type === Type.ALIAS) {</span>
    <span class="s0">var </span><span class="s1">name = node.rawValue</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">src = anchors.getNode(name)</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(!src) {</span>
      <span class="s0">var </span><span class="s1">msg = </span><span class="s3">&quot;Aliased anchor not found: &quot;</span><span class="s1">.concat(name)</span><span class="s2">;</span>
      <span class="s1">errors.push(</span><span class="s0">new </span><span class="s1">YAMLReferenceError(node</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
      <span class="s0">return null</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s6">// Lazy resolution for circular references</span>


    <span class="s0">var </span><span class="s1">res = </span><span class="s0">new </span><span class="s1">Alias(src)</span><span class="s2">;</span>

    <span class="s1">anchors._cstAliases.push(res)</span><span class="s2">;</span>

    <span class="s0">return </span><span class="s1">res</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">tagName = resolveTagName(doc</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(tagName) </span><span class="s0">return </span><span class="s1">resolveTag(doc</span><span class="s2">, </span><span class="s1">node</span><span class="s2">, </span><span class="s1">tagName)</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(node.type !== Type.PLAIN) {</span>
    <span class="s0">var </span><span class="s1">_msg3 = </span><span class="s3">&quot;Failed to resolve &quot;</span><span class="s1">.concat(node.type</span><span class="s2">, </span><span class="s3">&quot; node here&quot;</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s1">errors.push(</span><span class="s0">new </span><span class="s1">YAMLSyntaxError(node</span><span class="s2">, </span><span class="s1">_msg3))</span><span class="s2">;</span>
    <span class="s0">return null</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">try </span><span class="s1">{</span>
    <span class="s0">var </span><span class="s1">str = resolveString(doc</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>
    <span class="s0">return </span><span class="s1">resolveScalar(str</span><span class="s2">, </span><span class="s1">schema.tags</span><span class="s2">, </span><span class="s1">schema.tags.scalarFallback)</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">catch </span><span class="s1">(error) {</span>
    <span class="s0">if </span><span class="s1">(!error.source) error.source = node</span><span class="s2">;</span>
    <span class="s1">errors.push(error)</span><span class="s2">;</span>
    <span class="s0">return null</span><span class="s2">;</span>
  <span class="s1">}</span>
<span class="s1">} </span><span class="s6">// sets node.resolved on success</span>


<span class="s0">function </span><span class="s1">resolveNode(doc</span><span class="s2">, </span><span class="s1">node) {</span>
  <span class="s0">if </span><span class="s1">(!node) </span><span class="s0">return null</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(node.error) doc.errors.push(node.error)</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">_resolveNodeProps = resolveNodeProps(doc.errors</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">,</span>
      <span class="s1">comments = _resolveNodeProps.comments</span><span class="s2">,</span>
      <span class="s1">hasAnchor = _resolveNodeProps.hasAnchor</span><span class="s2">,</span>
      <span class="s1">hasTag = _resolveNodeProps.hasTag</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(hasAnchor) {</span>
    <span class="s0">var </span><span class="s1">anchors = doc.anchors</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">name = node.anchor</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">prev = anchors.getNode(name)</span><span class="s2">; </span><span class="s6">// At this point, aliases for any preceding node with the same anchor</span>
    <span class="s6">// name have already been resolved, so it may safely be renamed.</span>

    <span class="s0">if </span><span class="s1">(prev) anchors.map[anchors.newName(name)] = prev</span><span class="s2">; </span><span class="s6">// During parsing, we need to store the CST node in anchors.map as</span>
    <span class="s6">// anchors need to be available during resolution to allow for</span>
    <span class="s6">// circular references.</span>

    <span class="s1">anchors.map[name] = node</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(node.type === Type.ALIAS &amp;&amp; (hasAnchor || hasTag)) {</span>
    <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'An alias node must not specify any properties'</span><span class="s2">;</span>
    <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(node</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">res = resolveNodeValue(doc</span><span class="s2">, </span><span class="s1">node)</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(res) {</span>
    <span class="s1">res.range = [node.range.start</span><span class="s2">, </span><span class="s1">node.range.end]</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(doc.options.keepCstNodes) res.cstNode = node</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(doc.options.keepNodeTypes) res.type = node.type</span><span class="s2">;</span>
    <span class="s0">var </span><span class="s1">cb = comments.before.join(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(cb) {</span>
      <span class="s1">res.commentBefore = res.commentBefore ? </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(res.commentBefore</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">).concat(cb) : cb</span><span class="s2">;</span>
    <span class="s1">}</span>

    <span class="s0">var </span><span class="s1">ca = comments.after.join(</span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(ca) res.comment = res.comment ? </span><span class="s3">&quot;&quot;</span><span class="s1">.concat(res.comment</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">).concat(ca) : ca</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">node.resolved = res</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveMap(doc</span><span class="s2">, </span><span class="s1">cst) {</span>
  <span class="s0">if </span><span class="s1">(cst.type !== Type.MAP &amp;&amp; cst.type !== Type.FLOW_MAP) {</span>
    <span class="s0">var </span><span class="s1">msg = </span><span class="s3">&quot;A &quot;</span><span class="s1">.concat(cst.type</span><span class="s2">, </span><span class="s3">&quot; node cannot be resolved as a mapping&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSyntaxError(cst</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
    <span class="s0">return null</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">_ref = cst.type === Type.FLOW_MAP ? resolveFlowMapItems(doc</span><span class="s2">, </span><span class="s1">cst) : resolveBlockMapItems(doc</span><span class="s2">, </span><span class="s1">cst)</span><span class="s2">,</span>
      <span class="s1">comments = _ref.comments</span><span class="s2">,</span>
      <span class="s1">items = _ref.items</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">map = </span><span class="s0">new </span><span class="s1">YAMLMap()</span><span class="s2">;</span>
  <span class="s1">map.items = items</span><span class="s2">;</span>
  <span class="s1">resolveComments(map</span><span class="s2">, </span><span class="s1">comments)</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">hasCollectionKey = </span><span class="s0">false</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; items.length</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s0">var </span><span class="s1">iKey = items[i].key</span><span class="s2">;</span>
    <span class="s0">if </span><span class="s1">(iKey </span><span class="s0">instanceof </span><span class="s1">Collection) hasCollectionKey = </span><span class="s0">true</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(doc.schema.merge &amp;&amp; iKey &amp;&amp; iKey.value === MERGE_KEY) {</span>
      <span class="s1">items[i] = </span><span class="s0">new </span><span class="s1">Merge(items[i])</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">sources = items[i].value.items</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">error = </span><span class="s0">null</span><span class="s2">;</span>
      <span class="s1">sources.some(</span><span class="s0">function </span><span class="s1">(node) {</span>
        <span class="s0">if </span><span class="s1">(node </span><span class="s0">instanceof </span><span class="s1">Alias) {</span>
          <span class="s6">// During parsing, alias sources are CST nodes; to account for</span>
          <span class="s6">// circular references their resolved values can't be used here.</span>
          <span class="s0">var </span><span class="s1">type = node.source.type</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(type === Type.MAP || type === Type.FLOW_MAP) </span><span class="s0">return false</span><span class="s2">;</span>
          <span class="s0">return </span><span class="s1">error = </span><span class="s3">'Merge nodes aliases can only point to maps'</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">return </span><span class="s1">error = </span><span class="s3">'Merge nodes can only have Alias nodes as values'</span><span class="s2">;</span>
      <span class="s1">})</span><span class="s2">;</span>
      <span class="s0">if </span><span class="s1">(error) doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(cst</span><span class="s2">, </span><span class="s1">error))</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s2">; </span><span class="s1">j &lt; items.length</span><span class="s2">; </span><span class="s1">++j) {</span>
        <span class="s0">var </span><span class="s1">jKey = items[j].key</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(iKey === jKey || iKey &amp;&amp; jKey &amp;&amp; Object.prototype.hasOwnProperty.call(iKey</span><span class="s2">, </span><span class="s3">'value'</span><span class="s1">) &amp;&amp; iKey.value === jKey.value) {</span>
          <span class="s0">var </span><span class="s1">_msg = </span><span class="s3">&quot;Map keys must be unique; </span><span class="s2">\&quot;</span><span class="s3">&quot;</span><span class="s1">.concat(iKey</span><span class="s2">, </span><span class="s3">&quot;</span><span class="s2">\&quot; </span><span class="s3">is repeated&quot;</span><span class="s1">)</span><span class="s2">;</span>

          <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(cst</span><span class="s2">, </span><span class="s1">_msg))</span><span class="s2">;</span>
          <span class="s0">break</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(hasCollectionKey &amp;&amp; !doc.options.mapAsMap) {</span>
    <span class="s0">var </span><span class="s1">warn = </span><span class="s3">'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.'</span><span class="s2">;</span>
    <span class="s1">doc.warnings.push(</span><span class="s0">new </span><span class="s1">YAMLWarning(cst</span><span class="s2">, </span><span class="s1">warn))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">cst.resolved = map</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">map</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">var </span><span class="s1">valueHasPairComment = </span><span class="s0">function </span><span class="s1">valueHasPairComment(_ref2) {</span>
  <span class="s0">var </span><span class="s1">_ref2$context = _ref2.context</span><span class="s2">,</span>
      <span class="s1">lineStart = _ref2$context.lineStart</span><span class="s2">,</span>
      <span class="s1">node = _ref2$context.node</span><span class="s2">,</span>
      <span class="s1">src = _ref2$context.src</span><span class="s2">,</span>
      <span class="s1">props = _ref2.props</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(props.length === </span><span class="s4">0</span><span class="s1">) </span><span class="s0">return false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">start = props[</span><span class="s4">0</span><span class="s1">].start</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(node &amp;&amp; start &gt; node.valueRange.start) </span><span class="s0">return false</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(src[start] !== Char.COMMENT) </span><span class="s0">return false</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = lineStart</span><span class="s2">; </span><span class="s1">i &lt; start</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s0">if </span><span class="s1">(src[i] === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) </span><span class="s0">return false</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">return true</span><span class="s2">;</span>
<span class="s1">}</span><span class="s2">;</span>

<span class="s0">function </span><span class="s1">resolvePairComment(item</span><span class="s2">, </span><span class="s1">pair) {</span>
  <span class="s0">if </span><span class="s1">(!valueHasPairComment(item)) </span><span class="s0">return</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">comment = item.getPropValue(</span><span class="s4">0</span><span class="s2">, </span><span class="s1">Char.COMMENT</span><span class="s2">, </span><span class="s0">true</span><span class="s1">)</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">found = </span><span class="s0">false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">cb = pair.value.commentBefore</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(cb &amp;&amp; cb.startsWith(comment)) {</span>
    <span class="s1">pair.value.commentBefore = cb.substr(comment.length + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">found = </span><span class="s0">true</span><span class="s2">;</span>
  <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
    <span class="s0">var </span><span class="s1">cc = pair.value.comment</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(!item.node &amp;&amp; cc &amp;&amp; cc.startsWith(comment)) {</span>
      <span class="s1">pair.value.comment = cc.substr(comment.length + </span><span class="s4">1</span><span class="s1">)</span><span class="s2">;</span>
      <span class="s1">found = </span><span class="s0">true</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(found) pair.comment = comment</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveBlockMapItems(doc</span><span class="s2">, </span><span class="s1">cst) {</span>
  <span class="s0">var </span><span class="s1">comments = []</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">items = []</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">key = undefined</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">keyStart = </span><span class="s0">null</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; cst.items.length</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s0">var </span><span class="s1">item = cst.items[i]</span><span class="s2">;</span>

    <span class="s0">switch </span><span class="s1">(item.type) {</span>
      <span class="s0">case </span><span class="s1">Type.BLANK_LINE:</span>
        <span class="s1">comments.push({</span>
          <span class="s1">afterKey: !!key</span><span class="s2">,</span>
          <span class="s1">before: items.length</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s1">Type.COMMENT:</span>
        <span class="s1">comments.push({</span>
          <span class="s1">afterKey: !!key</span><span class="s2">,</span>
          <span class="s1">before: items.length</span><span class="s2">,</span>
          <span class="s1">comment: item.comment</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s1">Type.MAP_KEY:</span>
        <span class="s0">if </span><span class="s1">(key !== undefined) items.push(</span><span class="s0">new </span><span class="s1">Pair(key))</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(item.error) doc.errors.push(item.error)</span><span class="s2">;</span>
        <span class="s1">key = resolveNode(doc</span><span class="s2">, </span><span class="s1">item.node)</span><span class="s2">;</span>
        <span class="s1">keyStart = </span><span class="s0">null</span><span class="s2">;</span>
        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s1">Type.MAP_VALUE:</span>
        <span class="s1">{</span>
          <span class="s0">if </span><span class="s1">(key === undefined) key = </span><span class="s0">null</span><span class="s2">;</span>
          <span class="s0">if </span><span class="s1">(item.error) doc.errors.push(item.error)</span><span class="s2">;</span>

          <span class="s0">if </span><span class="s1">(!item.context.atLineStart &amp;&amp; item.node &amp;&amp; item.node.type === Type.MAP &amp;&amp; !item.node.context.atLineStart) {</span>
            <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'Nested mappings are not allowed in compact mappings'</span><span class="s2">;</span>
            <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(item.node</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s0">var </span><span class="s1">valueNode = item.node</span><span class="s2">;</span>

          <span class="s0">if </span><span class="s1">(!valueNode &amp;&amp; item.props.length &gt; </span><span class="s4">0</span><span class="s1">) {</span>
            <span class="s6">// Comments on an empty mapping value need to be preserved, so we</span>
            <span class="s6">// need to construct a minimal empty node here to use instead of the</span>
            <span class="s6">// missing `item.node`. -- eemeli/yaml#19</span>
            <span class="s1">valueNode = </span><span class="s0">new </span><span class="s1">PlainValue(Type.PLAIN</span><span class="s2">, </span><span class="s1">[])</span><span class="s2">;</span>
            <span class="s1">valueNode.context = {</span>
              <span class="s1">parent: item</span><span class="s2">,</span>
              <span class="s1">src: item.context.src</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s0">var </span><span class="s1">pos = item.range.start + </span><span class="s4">1</span><span class="s2">;</span>
            <span class="s1">valueNode.range = {</span>
              <span class="s1">start: pos</span><span class="s2">,</span>
              <span class="s1">end: pos</span>
            <span class="s1">}</span><span class="s2">;</span>
            <span class="s1">valueNode.valueRange = {</span>
              <span class="s1">start: pos</span><span class="s2">,</span>
              <span class="s1">end: pos</span>
            <span class="s1">}</span><span class="s2">;</span>

            <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">item.range.origStart === </span><span class="s3">'number'</span><span class="s1">) {</span>
              <span class="s0">var </span><span class="s1">origPos = item.range.origStart + </span><span class="s4">1</span><span class="s2">;</span>
              <span class="s1">valueNode.range.origStart = valueNode.range.origEnd = origPos</span><span class="s2">;</span>
              <span class="s1">valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos</span><span class="s2">;</span>
            <span class="s1">}</span>
          <span class="s1">}</span>

          <span class="s0">var </span><span class="s1">pair = </span><span class="s0">new </span><span class="s1">Pair(key</span><span class="s2">, </span><span class="s1">resolveNode(doc</span><span class="s2">, </span><span class="s1">valueNode))</span><span class="s2">;</span>
          <span class="s1">resolvePairComment(item</span><span class="s2">, </span><span class="s1">pair)</span><span class="s2">;</span>
          <span class="s1">items.push(pair)</span><span class="s2">;</span>

          <span class="s0">if </span><span class="s1">(key &amp;&amp; </span><span class="s0">typeof </span><span class="s1">keyStart === </span><span class="s3">'number'</span><span class="s1">) {</span>
            <span class="s0">if </span><span class="s1">(item.range.start &gt; keyStart + </span><span class="s4">1024</span><span class="s1">) doc.errors.push(getLongKeyError(cst</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s1">key = undefined</span><span class="s2">;</span>
          <span class="s1">keyStart = </span><span class="s0">null</span><span class="s2">;</span>
        <span class="s1">}</span>
        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">default</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">(key !== undefined) items.push(</span><span class="s0">new </span><span class="s1">Pair(key))</span><span class="s2">;</span>
        <span class="s1">key = resolveNode(doc</span><span class="s2">, </span><span class="s1">item)</span><span class="s2">;</span>
        <span class="s1">keyStart = item.range.start</span><span class="s2">;</span>
        <span class="s0">if </span><span class="s1">(item.error) doc.errors.push(item.error)</span><span class="s2">;</span>

        <span class="s1">next: </span><span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">j = i + </span><span class="s4">1</span><span class="s2">;; </span><span class="s1">++j) {</span>
          <span class="s0">var </span><span class="s1">nextItem = cst.items[j]</span><span class="s2">;</span>

          <span class="s0">switch </span><span class="s1">(nextItem &amp;&amp; nextItem.type) {</span>
            <span class="s0">case </span><span class="s1">Type.BLANK_LINE:</span>
            <span class="s0">case </span><span class="s1">Type.COMMENT:</span>
              <span class="s0">continue </span><span class="s1">next</span><span class="s2">;</span>

            <span class="s0">case </span><span class="s1">Type.MAP_VALUE:</span>
              <span class="s0">break </span><span class="s1">next</span><span class="s2">;</span>

            <span class="s0">default</span><span class="s1">:</span>
              <span class="s1">{</span>
                <span class="s0">var </span><span class="s1">_msg2 = </span><span class="s3">'Implicit map keys need to be followed by map values'</span><span class="s2">;</span>
                <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(item</span><span class="s2">, </span><span class="s1">_msg2))</span><span class="s2">;</span>
                <span class="s0">break </span><span class="s1">next</span><span class="s2">;</span>
              <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">}</span>

        <span class="s0">if </span><span class="s1">(item.valueRangeContainsNewline) {</span>
          <span class="s0">var </span><span class="s1">_msg3 = </span><span class="s3">'Implicit map keys need to be on a single line'</span><span class="s2">;</span>
          <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(item</span><span class="s2">, </span><span class="s1">_msg3))</span><span class="s2">;</span>
        <span class="s1">}</span>

    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">if </span><span class="s1">(key !== undefined) items.push(</span><span class="s0">new </span><span class="s1">Pair(key))</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">comments: comments</span><span class="s2">,</span>
    <span class="s1">items: items</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveFlowMapItems(doc</span><span class="s2">, </span><span class="s1">cst) {</span>
  <span class="s0">var </span><span class="s1">comments = []</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">items = []</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">key = undefined</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">explicitKey = </span><span class="s0">false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">next = </span><span class="s3">'{'</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; cst.items.length</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s0">var </span><span class="s1">item = cst.items[i]</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">item.char === </span><span class="s3">'string'</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">char = item.char</span><span class="s2">,</span>
          <span class="s1">offset = item.offset</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(char === </span><span class="s3">'?' </span><span class="s1">&amp;&amp; key === undefined &amp;&amp; !explicitKey) {</span>
        <span class="s1">explicitKey = </span><span class="s0">true</span><span class="s2">;</span>
        <span class="s1">next = </span><span class="s3">':'</span><span class="s2">;</span>
        <span class="s0">continue</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(char === </span><span class="s3">':'</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(key === undefined) key = </span><span class="s0">null</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(next === </span><span class="s3">':'</span><span class="s1">) {</span>
          <span class="s1">next = </span><span class="s3">','</span><span class="s2">;</span>
          <span class="s0">continue</span><span class="s2">;</span>
        <span class="s1">}</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s0">if </span><span class="s1">(explicitKey) {</span>
          <span class="s0">if </span><span class="s1">(key === undefined &amp;&amp; char !== </span><span class="s3">','</span><span class="s1">) key = </span><span class="s0">null</span><span class="s2">;</span>
          <span class="s1">explicitKey = </span><span class="s0">false</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">if </span><span class="s1">(key !== undefined) {</span>
          <span class="s1">items.push(</span><span class="s0">new </span><span class="s1">Pair(key))</span><span class="s2">;</span>
          <span class="s1">key = undefined</span><span class="s2">;</span>

          <span class="s0">if </span><span class="s1">(char === </span><span class="s3">','</span><span class="s1">) {</span>
            <span class="s1">next = </span><span class="s3">':'</span><span class="s2">;</span>
            <span class="s0">continue</span><span class="s2">;</span>
          <span class="s1">}</span>
        <span class="s1">}</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(char === </span><span class="s3">'}'</span><span class="s1">) {</span>
        <span class="s0">if </span><span class="s1">(i === cst.items.length - </span><span class="s4">1</span><span class="s1">) </span><span class="s0">continue</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(char === next) {</span>
        <span class="s1">next = </span><span class="s3">':'</span><span class="s2">;</span>
        <span class="s0">continue</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">var </span><span class="s1">msg = </span><span class="s3">&quot;Flow map contains an unexpected &quot;</span><span class="s1">.concat(char)</span><span class="s2">;</span>
      <span class="s0">var </span><span class="s1">err = </span><span class="s0">new </span><span class="s1">YAMLSyntaxError(cst</span><span class="s2">, </span><span class="s1">msg)</span><span class="s2">;</span>
      <span class="s1">err.offset = offset</span><span class="s2">;</span>
      <span class="s1">doc.errors.push(err)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(item.type === Type.BLANK_LINE) {</span>
      <span class="s1">comments.push({</span>
        <span class="s1">afterKey: !!key</span><span class="s2">,</span>
        <span class="s1">before: items.length</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(item.type === Type.COMMENT) {</span>
      <span class="s1">checkFlowCommentSpace(doc.errors</span><span class="s2">, </span><span class="s1">item)</span><span class="s2">;</span>
      <span class="s1">comments.push({</span>
        <span class="s1">afterKey: !!key</span><span class="s2">,</span>
        <span class="s1">before: items.length</span><span class="s2">,</span>
        <span class="s1">comment: item.comment</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(key === undefined) {</span>
      <span class="s0">if </span><span class="s1">(next === </span><span class="s3">','</span><span class="s1">) doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(item</span><span class="s2">, </span><span class="s3">'Separator , missing in flow map'</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">key = resolveNode(doc</span><span class="s2">, </span><span class="s1">item)</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">if </span><span class="s1">(next !== </span><span class="s3">','</span><span class="s1">) doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(item</span><span class="s2">, </span><span class="s3">'Indicator : missing in flow map entry'</span><span class="s1">))</span><span class="s2">;</span>
      <span class="s1">items.push(</span><span class="s0">new </span><span class="s1">Pair(key</span><span class="s2">, </span><span class="s1">resolveNode(doc</span><span class="s2">, </span><span class="s1">item)))</span><span class="s2">;</span>
      <span class="s1">key = undefined</span><span class="s2">;</span>
      <span class="s1">explicitKey = </span><span class="s0">false</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">checkFlowCollectionEnd(doc.errors</span><span class="s2">, </span><span class="s1">cst)</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(key !== undefined) items.push(</span><span class="s0">new </span><span class="s1">Pair(key))</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">comments: comments</span><span class="s2">,</span>
    <span class="s1">items: items</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveSeq(doc</span><span class="s2">, </span><span class="s1">cst) {</span>
  <span class="s0">if </span><span class="s1">(cst.type !== Type.SEQ &amp;&amp; cst.type !== Type.FLOW_SEQ) {</span>
    <span class="s0">var </span><span class="s1">msg = </span><span class="s3">&quot;A &quot;</span><span class="s1">.concat(cst.type</span><span class="s2">, </span><span class="s3">&quot; node cannot be resolved as a sequence&quot;</span><span class="s1">)</span><span class="s2">;</span>
    <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSyntaxError(cst</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
    <span class="s0">return null</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s0">var </span><span class="s1">_ref = cst.type === Type.FLOW_SEQ ? resolveFlowSeqItems(doc</span><span class="s2">, </span><span class="s1">cst) : resolveBlockSeqItems(doc</span><span class="s2">, </span><span class="s1">cst)</span><span class="s2">,</span>
      <span class="s1">comments = _ref.comments</span><span class="s2">,</span>
      <span class="s1">items = _ref.items</span><span class="s2">;</span>

  <span class="s0">var </span><span class="s1">seq = </span><span class="s0">new </span><span class="s1">YAMLSeq()</span><span class="s2">;</span>
  <span class="s1">seq.items = items</span><span class="s2">;</span>
  <span class="s1">resolveComments(seq</span><span class="s2">, </span><span class="s1">comments)</span><span class="s2">;</span>

  <span class="s0">if </span><span class="s1">(!doc.options.mapAsMap &amp;&amp; items.some(</span><span class="s0">function </span><span class="s1">(it) {</span>
    <span class="s0">return </span><span class="s1">it </span><span class="s0">instanceof </span><span class="s1">Pair &amp;&amp; it.key </span><span class="s0">instanceof </span><span class="s1">Collection</span><span class="s2">;</span>
  <span class="s1">})) {</span>
    <span class="s0">var </span><span class="s1">warn = </span><span class="s3">'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.'</span><span class="s2">;</span>
    <span class="s1">doc.warnings.push(</span><span class="s0">new </span><span class="s1">YAMLWarning(cst</span><span class="s2">, </span><span class="s1">warn))</span><span class="s2">;</span>
  <span class="s1">}</span>

  <span class="s1">cst.resolved = seq</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">seq</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveBlockSeqItems(doc</span><span class="s2">, </span><span class="s1">cst) {</span>
  <span class="s0">var </span><span class="s1">comments = []</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">items = []</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; cst.items.length</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s0">var </span><span class="s1">item = cst.items[i]</span><span class="s2">;</span>

    <span class="s0">switch </span><span class="s1">(item.type) {</span>
      <span class="s0">case </span><span class="s1">Type.BLANK_LINE:</span>
        <span class="s1">comments.push({</span>
          <span class="s1">before: items.length</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s1">Type.COMMENT:</span>
        <span class="s1">comments.push({</span>
          <span class="s1">comment: item.comment</span><span class="s2">,</span>
          <span class="s1">before: items.length</span>
        <span class="s1">})</span><span class="s2">;</span>
        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">case </span><span class="s1">Type.SEQ_ITEM:</span>
        <span class="s0">if </span><span class="s1">(item.error) doc.errors.push(item.error)</span><span class="s2">;</span>
        <span class="s1">items.push(resolveNode(doc</span><span class="s2">, </span><span class="s1">item.node))</span><span class="s2">;</span>

        <span class="s0">if </span><span class="s1">(item.hasProps) {</span>
          <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'Sequence items cannot have tags or anchors before the - indicator'</span><span class="s2">;</span>
          <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(item</span><span class="s2">, </span><span class="s1">msg))</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s0">break</span><span class="s2">;</span>

      <span class="s0">default</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">(item.error) doc.errors.push(item.error)</span><span class="s2">;</span>
        <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSyntaxError(item</span><span class="s2">, </span><span class="s3">&quot;Unexpected &quot;</span><span class="s1">.concat(item.type</span><span class="s2">, </span><span class="s3">&quot; node in sequence&quot;</span><span class="s1">)))</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">comments: comments</span><span class="s2">,</span>
    <span class="s1">items: items</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">function </span><span class="s1">resolveFlowSeqItems(doc</span><span class="s2">, </span><span class="s1">cst) {</span>
  <span class="s0">var </span><span class="s1">comments = []</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">items = []</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">explicitKey = </span><span class="s0">false</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">key = undefined</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">keyStart = </span><span class="s0">null</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">next = </span><span class="s3">'['</span><span class="s2">;</span>
  <span class="s0">var </span><span class="s1">prevItem = </span><span class="s0">null</span><span class="s2">;</span>

  <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">i = </span><span class="s4">0</span><span class="s2">; </span><span class="s1">i &lt; cst.items.length</span><span class="s2">; </span><span class="s1">++i) {</span>
    <span class="s0">var </span><span class="s1">item = cst.items[i]</span><span class="s2">;</span>

    <span class="s0">if </span><span class="s1">(</span><span class="s0">typeof </span><span class="s1">item.char === </span><span class="s3">'string'</span><span class="s1">) {</span>
      <span class="s0">var </span><span class="s1">char = item.char</span><span class="s2">,</span>
          <span class="s1">offset = item.offset</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(char !== </span><span class="s3">':' </span><span class="s1">&amp;&amp; (explicitKey || key !== undefined)) {</span>
        <span class="s0">if </span><span class="s1">(explicitKey &amp;&amp; key === undefined) key = next ? items.pop() : </span><span class="s0">null</span><span class="s2">;</span>
        <span class="s1">items.push(</span><span class="s0">new </span><span class="s1">Pair(key))</span><span class="s2">;</span>
        <span class="s1">explicitKey = </span><span class="s0">false</span><span class="s2">;</span>
        <span class="s1">key = undefined</span><span class="s2">;</span>
        <span class="s1">keyStart = </span><span class="s0">null</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">if </span><span class="s1">(char === next) {</span>
        <span class="s1">next = </span><span class="s0">null</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(!next &amp;&amp; char === </span><span class="s3">'?'</span><span class="s1">) {</span>
        <span class="s1">explicitKey = </span><span class="s0">true</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(next !== </span><span class="s3">'[' </span><span class="s1">&amp;&amp; char === </span><span class="s3">':' </span><span class="s1">&amp;&amp; key === undefined) {</span>
        <span class="s0">if </span><span class="s1">(next === </span><span class="s3">','</span><span class="s1">) {</span>
          <span class="s1">key = items.pop()</span><span class="s2">;</span>

          <span class="s0">if </span><span class="s1">(key </span><span class="s0">instanceof </span><span class="s1">Pair) {</span>
            <span class="s0">var </span><span class="s1">msg = </span><span class="s3">'Chaining flow sequence pairs is invalid'</span><span class="s2">;</span>
            <span class="s0">var </span><span class="s1">err = </span><span class="s0">new </span><span class="s1">YAMLSemanticError(cst</span><span class="s2">, </span><span class="s1">msg)</span><span class="s2">;</span>
            <span class="s1">err.offset = offset</span><span class="s2">;</span>
            <span class="s1">doc.errors.push(err)</span><span class="s2">;</span>
          <span class="s1">}</span>

          <span class="s0">if </span><span class="s1">(!explicitKey &amp;&amp; </span><span class="s0">typeof </span><span class="s1">keyStart === </span><span class="s3">'number'</span><span class="s1">) {</span>
            <span class="s0">var </span><span class="s1">keyEnd = item.range ? item.range.start : item.offset</span><span class="s2">;</span>
            <span class="s0">if </span><span class="s1">(keyEnd &gt; keyStart + </span><span class="s4">1024</span><span class="s1">) doc.errors.push(getLongKeyError(cst</span><span class="s2">, </span><span class="s1">key))</span><span class="s2">;</span>
            <span class="s0">var </span><span class="s1">src = prevItem.context.src</span><span class="s2">;</span>

            <span class="s0">for </span><span class="s1">(</span><span class="s0">var </span><span class="s1">_i = keyStart</span><span class="s2">; </span><span class="s1">_i &lt; keyEnd</span><span class="s2">; </span><span class="s1">++_i) {</span>
              <span class="s0">if </span><span class="s1">(src[_i] === </span><span class="s3">'</span><span class="s2">\n</span><span class="s3">'</span><span class="s1">) {</span>
                <span class="s0">var </span><span class="s1">_msg = </span><span class="s3">'Implicit keys of flow sequence pairs need to be on a single line'</span><span class="s2">;</span>
                <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(prevItem</span><span class="s2">, </span><span class="s1">_msg))</span><span class="s2">;</span>
                <span class="s0">break</span><span class="s2">;</span>
              <span class="s1">}</span>
            <span class="s1">}</span>
          <span class="s1">}</span>
        <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
          <span class="s1">key = </span><span class="s0">null</span><span class="s2">;</span>
        <span class="s1">}</span>

        <span class="s1">keyStart = </span><span class="s0">null</span><span class="s2">;</span>
        <span class="s1">explicitKey = </span><span class="s0">false</span><span class="s2">;</span>
        <span class="s1">next = </span><span class="s0">null</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else if </span><span class="s1">(next === </span><span class="s3">'[' </span><span class="s1">|| char !== </span><span class="s3">']' </span><span class="s1">|| i &lt; cst.items.length - </span><span class="s4">1</span><span class="s1">) {</span>
        <span class="s0">var </span><span class="s1">_msg2 = </span><span class="s3">&quot;Flow sequence contains an unexpected &quot;</span><span class="s1">.concat(char)</span><span class="s2">;</span>

        <span class="s0">var </span><span class="s1">_err = </span><span class="s0">new </span><span class="s1">YAMLSyntaxError(cst</span><span class="s2">, </span><span class="s1">_msg2)</span><span class="s2">;</span>

        <span class="s1">_err.offset = offset</span><span class="s2">;</span>
        <span class="s1">doc.errors.push(_err)</span><span class="s2">;</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(item.type === Type.BLANK_LINE) {</span>
      <span class="s1">comments.push({</span>
        <span class="s1">before: items.length</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else if </span><span class="s1">(item.type === Type.COMMENT) {</span>
      <span class="s1">checkFlowCommentSpace(doc.errors</span><span class="s2">, </span><span class="s1">item)</span><span class="s2">;</span>
      <span class="s1">comments.push({</span>
        <span class="s1">comment: item.comment</span><span class="s2">,</span>
        <span class="s1">before: items.length</span>
      <span class="s1">})</span><span class="s2">;</span>
    <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
      <span class="s0">if </span><span class="s1">(next) {</span>
        <span class="s0">var </span><span class="s1">_msg3 = </span><span class="s3">&quot;Expected a &quot;</span><span class="s1">.concat(next</span><span class="s2">, </span><span class="s3">&quot; in flow sequence&quot;</span><span class="s1">)</span><span class="s2">;</span>

        <span class="s1">doc.errors.push(</span><span class="s0">new </span><span class="s1">YAMLSemanticError(item</span><span class="s2">, </span><span class="s1">_msg3))</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s0">var </span><span class="s1">value = resolveNode(doc</span><span class="s2">, </span><span class="s1">item)</span><span class="s2">;</span>

      <span class="s0">if </span><span class="s1">(key === undefined) {</span>
        <span class="s1">items.push(value)</span><span class="s2">;</span>
        <span class="s1">prevItem = item</span><span class="s2">;</span>
      <span class="s1">} </span><span class="s0">else </span><span class="s1">{</span>
        <span class="s1">items.push(</span><span class="s0">new </span><span class="s1">Pair(key</span><span class="s2">, </span><span class="s1">value))</span><span class="s2">;</span>
        <span class="s1">key = undefined</span><span class="s2">;</span>
      <span class="s1">}</span>

      <span class="s1">keyStart = item.range.start</span><span class="s2">;</span>
      <span class="s1">next = </span><span class="s3">','</span><span class="s2">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s1">checkFlowCollectionEnd(doc.errors</span><span class="s2">, </span><span class="s1">cst)</span><span class="s2">;</span>
  <span class="s0">if </span><span class="s1">(key !== undefined) items.push(</span><span class="s0">new </span><span class="s1">Pair(key))</span><span class="s2">;</span>
  <span class="s0">return </span><span class="s1">{</span>
    <span class="s1">comments: comments</span><span class="s2">,</span>
    <span class="s1">items: items</span>
  <span class="s1">}</span><span class="s2">;</span>
<span class="s1">}</span>

<span class="s0">export </span><span class="s1">{ Alias as A</span><span class="s2">, </span><span class="s1">Collection as C</span><span class="s2">, </span><span class="s1">Merge as M</span><span class="s2">, </span><span class="s1">Node as N</span><span class="s2">, </span><span class="s1">Pair as P</span><span class="s2">, </span><span class="s1">Scalar as S</span><span class="s2">, </span><span class="s1">YAMLSeq as Y</span><span class="s2">, </span><span class="s1">boolOptions as a</span><span class="s2">, </span><span class="s1">binaryOptions as b</span><span class="s2">, </span><span class="s1">stringifyString as c</span><span class="s2">, </span><span class="s1">YAMLMap as d</span><span class="s2">, </span><span class="s1">isEmptyPath as e</span><span class="s2">, </span><span class="s1">addComment as f</span><span class="s2">, </span><span class="s1">resolveMap as g</span><span class="s2">, </span><span class="s1">resolveSeq as h</span><span class="s2">, </span><span class="s1">intOptions as i</span><span class="s2">, </span><span class="s1">resolveString as j</span><span class="s2">, </span><span class="s1">stringifyNumber as k</span><span class="s2">, </span><span class="s1">findPair as l</span><span class="s2">, </span><span class="s1">nullOptions as n</span><span class="s2">, </span><span class="s1">resolveNode as r</span><span class="s2">, </span><span class="s1">strOptions as s</span><span class="s2">, </span><span class="s1">toJSON as t }</span><span class="s2">;</span>
</pre>
</body>
</html>