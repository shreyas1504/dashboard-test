<html>
<head>
<title>resolveSeq-d03cb037.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8ea765;}
.s1 { color: #cc7832;}
.s2 { color: #cfd2d5;}
.s3 { color: #cc7832; font-weight: bold;}
.s4 { color: #6897bb;}
.s5 { color: #808080;}
.s6 { color: #8a8a8a;}
.s7 { color: #8a8a8a; font-style: italic;}
.s8 { color: #8a8a8a; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#1c1c1c">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
resolveSeq-d03cb037.js</font>
</center></td></tr></table>
<pre><span class="s0">'use strict'</span><span class="s1">;</span>

<span class="s3">var </span><span class="s2">PlainValue = require(</span><span class="s0">'./PlainValue-ec8e588e.js'</span><span class="s2">)</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">addCommentBefore(str</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">comment) {</span>
  <span class="s3">if </span><span class="s2">(!comment) </span><span class="s3">return </span><span class="s2">str</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">cc = comment.replace(</span><span class="s4">/[\s\S]^/gm</span><span class="s1">, </span><span class="s0">`$&amp;</span><span class="s2">${indent}</span><span class="s0">#`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s0">`#</span><span class="s2">${cc}</span><span class="s1">\n</span><span class="s2">${indent}${str}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">addComment(str</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">comment) {</span>
  <span class="s3">return </span><span class="s2">!comment ? str : comment.indexOf(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) === -</span><span class="s4">1 </span><span class="s2">? </span><span class="s0">`</span><span class="s2">${str} </span><span class="s0">#</span><span class="s2">${comment}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">`</span><span class="s2">${str}</span><span class="s1">\n</span><span class="s0">` </span><span class="s2">+ comment.replace(</span><span class="s4">/^/gm</span><span class="s1">, </span><span class="s0">`</span><span class="s2">${indent || </span><span class="s0">''</span><span class="s2">}</span><span class="s0">#`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">class </span><span class="s2">Node {}</span>

<span class="s3">function </span><span class="s2">toJSON(value</span><span class="s1">, </span><span class="s2">arg</span><span class="s1">, </span><span class="s2">ctx) {</span>
  <span class="s3">if </span><span class="s2">(Array.isArray(value)) </span><span class="s3">return </span><span class="s2">value.map((v</span><span class="s1">, </span><span class="s2">i) =&gt; toJSON(v</span><span class="s1">, </span><span class="s2">String(i)</span><span class="s1">, </span><span class="s2">ctx))</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(value &amp;&amp; </span><span class="s3">typeof </span><span class="s2">value.toJSON === </span><span class="s0">'function'</span><span class="s2">) {</span>
    <span class="s3">const </span><span class="s2">anchor = ctx &amp;&amp; ctx.anchors &amp;&amp; ctx.anchors.get(value)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(anchor) ctx.onCreate = res =&gt; {</span>
      <span class="s2">anchor.res = res</span><span class="s1">;</span>
      <span class="s3">delete </span><span class="s2">ctx.onCreate</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">res = value.toJSON(arg</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(anchor &amp;&amp; ctx.onCreate) ctx.onCreate(res)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">res</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">((!ctx || !ctx.keep) &amp;&amp; </span><span class="s3">typeof </span><span class="s2">value === </span><span class="s0">'bigint'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">Number(value)</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">value</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">class </span><span class="s2">Scalar </span><span class="s3">extends </span><span class="s2">Node {</span>
  <span class="s2">constructor(value) {</span>
    <span class="s3">super</span><span class="s2">()</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.value = value</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toJSON(arg</span><span class="s1">, </span><span class="s2">ctx) {</span>
    <span class="s3">return </span><span class="s2">ctx &amp;&amp; ctx.keep ? </span><span class="s3">this</span><span class="s2">.value : toJSON(</span><span class="s3">this</span><span class="s2">.value</span><span class="s1">, </span><span class="s2">arg</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toString() {</span>
    <span class="s3">return </span><span class="s2">String(</span><span class="s3">this</span><span class="s2">.value)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s3">function </span><span class="s2">collectionFromPath(schema</span><span class="s1">, </span><span class="s2">path</span><span class="s1">, </span><span class="s2">value) {</span>
  <span class="s3">let </span><span class="s2">v = value</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = path.length - </span><span class="s4">1</span><span class="s1">; </span><span class="s2">i &gt;= </span><span class="s4">0</span><span class="s1">; </span><span class="s2">--i) {</span>
    <span class="s3">const </span><span class="s2">k = path[i]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(Number.isInteger(k) &amp;&amp; k &gt;= </span><span class="s4">0</span><span class="s2">) {</span>
      <span class="s3">const </span><span class="s2">a = []</span><span class="s1">;</span>
      <span class="s2">a[k] = v</span><span class="s1">;</span>
      <span class="s2">v = a</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">const </span><span class="s2">o = {}</span><span class="s1">;</span>
      <span class="s2">Object.defineProperty(o</span><span class="s1">, </span><span class="s2">k</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">value: v</span><span class="s1">,</span>
        <span class="s2">writable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s2">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s2">configurable: </span><span class="s3">true</span>
      <span class="s2">})</span><span class="s1">;</span>
      <span class="s2">v = o</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">schema.createNode(v</span><span class="s1">, </span><span class="s3">false</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">} </span><span class="s5">// null, undefined, or an empty non-string iterable (e.g. [])</span>


<span class="s3">const </span><span class="s2">isEmptyPath = path =&gt; path == </span><span class="s3">null </span><span class="s2">|| </span><span class="s3">typeof </span><span class="s2">path === </span><span class="s0">'object' </span><span class="s2">&amp;&amp; path[Symbol.iterator]().next().done</span><span class="s1">;</span>
<span class="s3">class </span><span class="s2">Collection </span><span class="s3">extends </span><span class="s2">Node {</span>
  <span class="s2">constructor(schema) {</span>
    <span class="s3">super</span><span class="s2">()</span><span class="s1">;</span>

    <span class="s2">PlainValue._defineProperty(</span><span class="s3">this</span><span class="s1">, </span><span class="s0">&quot;items&quot;</span><span class="s1">, </span><span class="s2">[])</span><span class="s1">;</span>

    <span class="s3">this</span><span class="s2">.schema = schema</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">addIn(path</span><span class="s1">, </span><span class="s2">value) {</span>
    <span class="s3">if </span><span class="s2">(isEmptyPath(path)) </span><span class="s3">this</span><span class="s2">.add(value)</span><span class="s1">;</span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">const </span><span class="s2">[key</span><span class="s1">, </span><span class="s2">...rest] = path</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">node = </span><span class="s3">this</span><span class="s2">.get(key</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(node </span><span class="s3">instanceof </span><span class="s2">Collection) node.addIn(rest</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span><span class="s3">else if </span><span class="s2">(node === undefined &amp;&amp; </span><span class="s3">this</span><span class="s2">.schema) </span><span class="s3">this</span><span class="s2">.set(key</span><span class="s1">, </span><span class="s2">collectionFromPath(</span><span class="s3">this</span><span class="s2">.schema</span><span class="s1">, </span><span class="s2">rest</span><span class="s1">, </span><span class="s2">value))</span><span class="s1">;</span><span class="s3">else throw new </span><span class="s2">Error(</span><span class="s0">`Expected YAML collection at </span><span class="s2">${key}</span><span class="s0">. Remaining path: </span><span class="s2">${rest}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s2">deleteIn([key</span><span class="s1">, </span><span class="s2">...rest]) {</span>
    <span class="s3">if </span><span class="s2">(rest.length === </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return this</span><span class="s2">.delete(key)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">node = </span><span class="s3">this</span><span class="s2">.get(key</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(node </span><span class="s3">instanceof </span><span class="s2">Collection) </span><span class="s3">return </span><span class="s2">node.deleteIn(rest)</span><span class="s1">;</span><span class="s3">else throw new </span><span class="s2">Error(</span><span class="s0">`Expected YAML collection at </span><span class="s2">${key}</span><span class="s0">. Remaining path: </span><span class="s2">${rest}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">getIn([key</span><span class="s1">, </span><span class="s2">...rest]</span><span class="s1">, </span><span class="s2">keepScalar) {</span>
    <span class="s3">const </span><span class="s2">node = </span><span class="s3">this</span><span class="s2">.get(key</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(rest.length === </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return </span><span class="s2">!keepScalar &amp;&amp; node </span><span class="s3">instanceof </span><span class="s2">Scalar ? node.value : node</span><span class="s1">;</span><span class="s3">else return </span><span class="s2">node </span><span class="s3">instanceof </span><span class="s2">Collection ? node.getIn(rest</span><span class="s1">, </span><span class="s2">keepScalar) : undefined</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">hasAllNullValues() {</span>
    <span class="s3">return this</span><span class="s2">.items.every(node =&gt; {</span>
      <span class="s3">if </span><span class="s2">(!node || node.type !== </span><span class="s0">'PAIR'</span><span class="s2">) </span><span class="s3">return false</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">n = node.value</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s2">n == </span><span class="s3">null </span><span class="s2">|| n </span><span class="s3">instanceof </span><span class="s2">Scalar &amp;&amp; n.value == </span><span class="s3">null </span><span class="s2">&amp;&amp; !n.commentBefore &amp;&amp; !n.comment &amp;&amp; !n.tag</span><span class="s1">;</span>
    <span class="s2">})</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">hasIn([key</span><span class="s1">, </span><span class="s2">...rest]) {</span>
    <span class="s3">if </span><span class="s2">(rest.length === </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return this</span><span class="s2">.has(key)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">node = </span><span class="s3">this</span><span class="s2">.get(key</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">node </span><span class="s3">instanceof </span><span class="s2">Collection ? node.hasIn(rest) : </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">setIn([key</span><span class="s1">, </span><span class="s2">...rest]</span><span class="s1">, </span><span class="s2">value) {</span>
    <span class="s3">if </span><span class="s2">(rest.length === </span><span class="s4">0</span><span class="s2">) {</span>
      <span class="s3">this</span><span class="s2">.set(key</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">const </span><span class="s2">node = </span><span class="s3">this</span><span class="s2">.get(key</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(node </span><span class="s3">instanceof </span><span class="s2">Collection) node.setIn(rest</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span><span class="s3">else if </span><span class="s2">(node === undefined &amp;&amp; </span><span class="s3">this</span><span class="s2">.schema) </span><span class="s3">this</span><span class="s2">.set(key</span><span class="s1">, </span><span class="s2">collectionFromPath(</span><span class="s3">this</span><span class="s2">.schema</span><span class="s1">, </span><span class="s2">rest</span><span class="s1">, </span><span class="s2">value))</span><span class="s1">;</span><span class="s3">else throw new </span><span class="s2">Error(</span><span class="s0">`Expected YAML collection at </span><span class="s2">${key}</span><span class="s0">. Remaining path: </span><span class="s2">${rest}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s5">// overridden in implementations</span>

  <span class="s6">/* istanbul ignore next */</span>


  <span class="s2">toJSON() {</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toString(ctx</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">blockItem</span><span class="s1">,</span>
    <span class="s2">flowChars</span><span class="s1">,</span>
    <span class="s2">isMap</span><span class="s1">,</span>
    <span class="s2">itemIndent</span>
  <span class="s2">}</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">indent</span><span class="s1">,</span>
      <span class="s2">indentStep</span><span class="s1">,</span>
      <span class="s2">stringify</span>
    <span class="s2">} = ctx</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">inFlow = </span><span class="s3">this</span><span class="s2">.type === PlainValue.Type.FLOW_MAP || </span><span class="s3">this</span><span class="s2">.type === PlainValue.Type.FLOW_SEQ || ctx.inFlow</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(inFlow) itemIndent += indentStep</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">allNullValues = isMap &amp;&amp; </span><span class="s3">this</span><span class="s2">.hasAllNullValues()</span><span class="s1">;</span>
    <span class="s2">ctx = Object.assign({}</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">{</span>
      <span class="s2">allNullValues</span><span class="s1">,</span>
      <span class="s2">indent: itemIndent</span><span class="s1">,</span>
      <span class="s2">inFlow</span><span class="s1">,</span>
      <span class="s2">type: </span><span class="s3">null</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">chompKeep = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">hasItemWithNewLine = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">nodes = </span><span class="s3">this</span><span class="s2">.items.reduce((nodes</span><span class="s1">, </span><span class="s2">item</span><span class="s1">, </span><span class="s2">i) =&gt; {</span>
      <span class="s3">let </span><span class="s2">comment</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(item) {</span>
        <span class="s3">if </span><span class="s2">(!chompKeep &amp;&amp; item.spaceBefore) nodes.push({</span>
          <span class="s2">type: </span><span class="s0">'comment'</span><span class="s1">,</span>
          <span class="s2">str: </span><span class="s0">''</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(item.commentBefore) item.commentBefore.match(</span><span class="s4">/^.*$/gm</span><span class="s2">).forEach(line =&gt; {</span>
          <span class="s2">nodes.push({</span>
            <span class="s2">type: </span><span class="s0">'comment'</span><span class="s1">,</span>
            <span class="s2">str: </span><span class="s0">`#</span><span class="s2">${line}</span><span class="s0">`</span>
          <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(item.comment) comment = item.comment</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(inFlow &amp;&amp; (!chompKeep &amp;&amp; item.spaceBefore || item.commentBefore || item.comment || item.key &amp;&amp; (item.key.commentBefore || item.key.comment) || item.value &amp;&amp; (item.value.commentBefore || item.value.comment))) hasItemWithNewLine = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">chompKeep = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s3">let </span><span class="s2">str = stringify(item</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">() =&gt; comment = </span><span class="s3">null</span><span class="s1">, </span><span class="s2">() =&gt; chompKeep = </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(inFlow &amp;&amp; !hasItemWithNewLine &amp;&amp; str.includes(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)) hasItemWithNewLine = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(inFlow &amp;&amp; i &lt; </span><span class="s3">this</span><span class="s2">.items.length - </span><span class="s4">1</span><span class="s2">) str += </span><span class="s0">','</span><span class="s1">;</span>
      <span class="s2">str = addComment(str</span><span class="s1">, </span><span class="s2">itemIndent</span><span class="s1">, </span><span class="s2">comment)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(chompKeep &amp;&amp; (comment || inFlow)) chompKeep = </span><span class="s3">false</span><span class="s1">;</span>
      <span class="s2">nodes.push({</span>
        <span class="s2">type: </span><span class="s0">'item'</span><span class="s1">,</span>
        <span class="s2">str</span>
      <span class="s2">})</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s2">nodes</span><span class="s1">;</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">[])</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">str</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(nodes.length === </span><span class="s4">0</span><span class="s2">) {</span>
      <span class="s2">str = flowChars.start + flowChars.end</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(inFlow) {</span>
      <span class="s3">const </span><span class="s2">{</span>
        <span class="s2">start</span><span class="s1">,</span>
        <span class="s2">end</span>
      <span class="s2">} = flowChars</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">strings = nodes.map(n =&gt; n.str)</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(hasItemWithNewLine || strings.reduce((sum</span><span class="s1">, </span><span class="s2">str) =&gt; sum + str.length + </span><span class="s4">2</span><span class="s1">, </span><span class="s4">2</span><span class="s2">) &gt; Collection.maxFlowStringSingleLineLength) {</span>
        <span class="s2">str = start</span><span class="s1">;</span>

        <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">s of strings) {</span>
          <span class="s2">str += s ? </span><span class="s0">`</span><span class="s1">\n</span><span class="s2">${indentStep}${indent}${s}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s2">str += </span><span class="s0">`</span><span class="s1">\n</span><span class="s2">${indent}${end}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s2">str = </span><span class="s0">`</span><span class="s2">${start} ${strings.join(</span><span class="s0">' '</span><span class="s2">)} ${end}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">const </span><span class="s2">strings = nodes.map(blockItem)</span><span class="s1">;</span>
      <span class="s2">str = strings.shift()</span><span class="s1">;</span>

      <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">s of strings) str += s ? </span><span class="s0">`</span><span class="s1">\n</span><span class="s2">${indent}${s}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.comment) {</span>
      <span class="s2">str += </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">+ </span><span class="s3">this</span><span class="s2">.comment.replace(</span><span class="s4">/^/gm</span><span class="s1">, </span><span class="s0">`</span><span class="s2">${indent}</span><span class="s0">#`</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(onComment) onComment()</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(chompKeep &amp;&amp; onChompKeep) onChompKeep()</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s2">str</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s2">PlainValue._defineProperty(Collection</span><span class="s1">, </span><span class="s0">&quot;maxFlowStringSingleLineLength&quot;</span><span class="s1">, </span><span class="s4">60</span><span class="s2">)</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">asItemIndex(key) {</span>
  <span class="s3">let </span><span class="s2">idx = key </span><span class="s3">instanceof </span><span class="s2">Scalar ? key.value : key</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(idx &amp;&amp; </span><span class="s3">typeof </span><span class="s2">idx === </span><span class="s0">'string'</span><span class="s2">) idx = Number(idx)</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">Number.isInteger(idx) &amp;&amp; idx &gt;= </span><span class="s4">0 </span><span class="s2">? idx : </span><span class="s3">null</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">class </span><span class="s2">YAMLSeq </span><span class="s3">extends </span><span class="s2">Collection {</span>
  <span class="s2">add(value) {</span>
    <span class="s3">this</span><span class="s2">.items.push(value)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">delete</span><span class="s2">(key) {</span>
    <span class="s3">const </span><span class="s2">idx = asItemIndex(key)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">idx !== </span><span class="s0">'number'</span><span class="s2">) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">del = </span><span class="s3">this</span><span class="s2">.items.splice(idx</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">del.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get(key</span><span class="s1">, </span><span class="s2">keepScalar) {</span>
    <span class="s3">const </span><span class="s2">idx = asItemIndex(key)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">idx !== </span><span class="s0">'number'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">undefined</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">it = </span><span class="s3">this</span><span class="s2">.items[idx]</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">!keepScalar &amp;&amp; it </span><span class="s3">instanceof </span><span class="s2">Scalar ? it.value : it</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">has(key) {</span>
    <span class="s3">const </span><span class="s2">idx = asItemIndex(key)</span><span class="s1">;</span>
    <span class="s3">return typeof </span><span class="s2">idx === </span><span class="s0">'number' </span><span class="s2">&amp;&amp; idx &lt; </span><span class="s3">this</span><span class="s2">.items.length</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">set(key</span><span class="s1">, </span><span class="s2">value) {</span>
    <span class="s3">const </span><span class="s2">idx = asItemIndex(key)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">idx !== </span><span class="s0">'number'</span><span class="s2">) </span><span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">`Expected a valid index, not </span><span class="s2">${key}</span><span class="s0">.`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.items[idx] = value</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toJSON(_</span><span class="s1">, </span><span class="s2">ctx) {</span>
    <span class="s3">const </span><span class="s2">seq = []</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(ctx &amp;&amp; ctx.onCreate) ctx.onCreate(seq)</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">item of </span><span class="s3">this</span><span class="s2">.items) seq.push(toJSON(item</span><span class="s1">, </span><span class="s2">String(i++)</span><span class="s1">, </span><span class="s2">ctx))</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s2">seq</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toString(ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep) {</span>
    <span class="s3">if </span><span class="s2">(!ctx) </span><span class="s3">return </span><span class="s2">JSON.stringify(</span><span class="s3">this</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">return super</span><span class="s2">.toString(ctx</span><span class="s1">, </span><span class="s2">{</span>
      <span class="s2">blockItem: n =&gt; n.type === </span><span class="s0">'comment' </span><span class="s2">? n.str : </span><span class="s0">`- </span><span class="s2">${n.str}</span><span class="s0">`</span><span class="s1">,</span>
      <span class="s2">flowChars: {</span>
        <span class="s2">start: </span><span class="s0">'['</span><span class="s1">,</span>
        <span class="s2">end: </span><span class="s0">']'</span>
      <span class="s2">}</span><span class="s1">,</span>
      <span class="s2">isMap: </span><span class="s3">false</span><span class="s1">,</span>
      <span class="s2">itemIndent: (ctx.indent || </span><span class="s0">''</span><span class="s2">) + </span><span class="s0">'  '</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s3">const </span><span class="s2">stringifyKey = (key</span><span class="s1">, </span><span class="s2">jsKey</span><span class="s1">, </span><span class="s2">ctx) =&gt; {</span>
  <span class="s3">if </span><span class="s2">(jsKey === </span><span class="s3">null</span><span class="s2">) </span><span class="s3">return </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">jsKey !== </span><span class="s0">'object'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">String(jsKey)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(key </span><span class="s3">instanceof </span><span class="s2">Node &amp;&amp; ctx &amp;&amp; ctx.doc) </span><span class="s3">return </span><span class="s2">key.toString({</span>
    <span class="s2">anchors: Object.create(</span><span class="s3">null</span><span class="s2">)</span><span class="s1">,</span>
    <span class="s2">doc: ctx.doc</span><span class="s1">,</span>
    <span class="s2">indent: </span><span class="s0">''</span><span class="s1">,</span>
    <span class="s2">indentStep: ctx.indentStep</span><span class="s1">,</span>
    <span class="s2">inFlow: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s2">inStringifyKey: </span><span class="s3">true</span><span class="s1">,</span>
    <span class="s2">stringify: ctx.stringify</span>
  <span class="s2">})</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">JSON.stringify(jsKey)</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">class </span><span class="s2">Pair </span><span class="s3">extends </span><span class="s2">Node {</span>
  <span class="s2">constructor(key</span><span class="s1">, </span><span class="s2">value = </span><span class="s3">null</span><span class="s2">) {</span>
    <span class="s3">super</span><span class="s2">()</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.key = key</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.value = value</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.type = Pair.Type.PAIR</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get commentBefore() {</span>
    <span class="s3">return this</span><span class="s2">.key </span><span class="s3">instanceof </span><span class="s2">Node ? </span><span class="s3">this</span><span class="s2">.key.commentBefore : undefined</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">set commentBefore(cb) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.key == </span><span class="s3">null</span><span class="s2">) </span><span class="s3">this</span><span class="s2">.key = </span><span class="s3">new </span><span class="s2">Scalar(</span><span class="s3">null</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.key </span><span class="s3">instanceof </span><span class="s2">Node) </span><span class="s3">this</span><span class="s2">.key.commentBefore = cb</span><span class="s1">;</span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Pair.commentBefore is an alias for Pair.key.commentBefore. To set it, the key must be a Node.'</span><span class="s1">;</span>
      <span class="s3">throw new </span><span class="s2">Error(msg)</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s2">addToJSMap(ctx</span><span class="s1">, </span><span class="s2">map) {</span>
    <span class="s3">const </span><span class="s2">key = toJSON(</span><span class="s3">this</span><span class="s2">.key</span><span class="s1">, </span><span class="s0">''</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(map </span><span class="s3">instanceof </span><span class="s2">Map) {</span>
      <span class="s3">const </span><span class="s2">value = toJSON(</span><span class="s3">this</span><span class="s2">.value</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
      <span class="s2">map.set(key</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(map </span><span class="s3">instanceof </span><span class="s2">Set) {</span>
      <span class="s2">map.add(key)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">const </span><span class="s2">stringKey = stringifyKey(</span><span class="s3">this</span><span class="s2">.key</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">value = toJSON(</span><span class="s3">this</span><span class="s2">.value</span><span class="s1">, </span><span class="s2">stringKey</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(stringKey </span><span class="s3">in </span><span class="s2">map) Object.defineProperty(map</span><span class="s1">, </span><span class="s2">stringKey</span><span class="s1">, </span><span class="s2">{</span>
        <span class="s2">value</span><span class="s1">,</span>
        <span class="s2">writable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s2">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
        <span class="s2">configurable: </span><span class="s3">true</span>
      <span class="s2">})</span><span class="s1">;</span><span class="s3">else </span><span class="s2">map[stringKey] = value</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">map</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toJSON(_</span><span class="s1">, </span><span class="s2">ctx) {</span>
    <span class="s3">const </span><span class="s2">pair = ctx &amp;&amp; ctx.mapAsMap ? </span><span class="s3">new </span><span class="s2">Map() : {}</span><span class="s1">;</span>
    <span class="s3">return this</span><span class="s2">.addToJSMap(ctx</span><span class="s1">, </span><span class="s2">pair)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toString(ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep) {</span>
    <span class="s3">if </span><span class="s2">(!ctx || !ctx.doc) </span><span class="s3">return </span><span class="s2">JSON.stringify(</span><span class="s3">this</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">indent: indentSize</span><span class="s1">,</span>
      <span class="s2">indentSeq</span><span class="s1">,</span>
      <span class="s2">simpleKeys</span>
    <span class="s2">} = ctx.doc.options</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">{</span>
      <span class="s2">key</span><span class="s1">,</span>
      <span class="s2">value</span>
    <span class="s2">} = </span><span class="s3">this</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">keyComment = key </span><span class="s3">instanceof </span><span class="s2">Node &amp;&amp; key.comment</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(simpleKeys) {</span>
      <span class="s3">if </span><span class="s2">(keyComment) {</span>
        <span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">'With simple keys, key nodes cannot have comments'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(key </span><span class="s3">instanceof </span><span class="s2">Collection) {</span>
        <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'With simple keys, collection cannot be used as a key value'</span><span class="s1">;</span>
        <span class="s3">throw new </span><span class="s2">Error(msg)</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">let </span><span class="s2">explicitKey = !simpleKeys &amp;&amp; (!key || keyComment || (key </span><span class="s3">instanceof </span><span class="s2">Node ? key </span><span class="s3">instanceof </span><span class="s2">Collection || key.type === PlainValue.Type.BLOCK_FOLDED || key.type === PlainValue.Type.BLOCK_LITERAL : </span><span class="s3">typeof </span><span class="s2">key === </span><span class="s0">'object'</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">doc</span><span class="s1">,</span>
      <span class="s2">indent</span><span class="s1">,</span>
      <span class="s2">indentStep</span><span class="s1">,</span>
      <span class="s2">stringify</span>
    <span class="s2">} = ctx</span><span class="s1">;</span>
    <span class="s2">ctx = Object.assign({}</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">{</span>
      <span class="s2">implicitKey: !explicitKey</span><span class="s1">,</span>
      <span class="s2">indent: indent + indentStep</span>
    <span class="s2">})</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">chompKeep = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">str = stringify(key</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">() =&gt; keyComment = </span><span class="s3">null</span><span class="s1">, </span><span class="s2">() =&gt; chompKeep = </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">str = addComment(str</span><span class="s1">, </span><span class="s2">ctx.indent</span><span class="s1">, </span><span class="s2">keyComment)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(!explicitKey &amp;&amp; str.length &gt; </span><span class="s4">1024</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(simpleKeys) </span><span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">'With simple keys, single line scalar must not span more than 1024 characters'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">explicitKey = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(ctx.allNullValues &amp;&amp; !simpleKeys) {</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.comment) {</span>
        <span class="s2">str = addComment(str</span><span class="s1">, </span><span class="s2">ctx.indent</span><span class="s1">, </span><span class="s3">this</span><span class="s2">.comment)</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(onComment) onComment()</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(chompKeep &amp;&amp; !keyComment &amp;&amp; onChompKeep) onChompKeep()</span><span class="s1">;</span>

      <span class="s3">return </span><span class="s2">ctx.inFlow &amp;&amp; !explicitKey ? str : </span><span class="s0">`? </span><span class="s2">${str}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s2">str = explicitKey ? </span><span class="s0">`? </span><span class="s2">${str}</span><span class="s1">\n</span><span class="s2">${indent}</span><span class="s0">:` </span><span class="s2">: </span><span class="s0">`</span><span class="s2">${str}</span><span class="s0">:`</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.comment) {</span>
      <span class="s5">// expected (but not strictly required) to be a single-line comment</span>
      <span class="s2">str = addComment(str</span><span class="s1">, </span><span class="s2">ctx.indent</span><span class="s1">, </span><span class="s3">this</span><span class="s2">.comment)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(onComment) onComment()</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">let </span><span class="s2">vcb = </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">valueComment = </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(value </span><span class="s3">instanceof </span><span class="s2">Node) {</span>
      <span class="s3">if </span><span class="s2">(value.spaceBefore) vcb = </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(value.commentBefore) {</span>
        <span class="s3">const </span><span class="s2">cs = value.commentBefore.replace(</span><span class="s4">/^/gm</span><span class="s1">, </span><span class="s0">`</span><span class="s2">${ctx.indent}</span><span class="s0">#`</span><span class="s2">)</span><span class="s1">;</span>
        <span class="s2">vcb += </span><span class="s0">`</span><span class="s1">\n</span><span class="s2">${cs}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">valueComment = value.comment</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(value &amp;&amp; </span><span class="s3">typeof </span><span class="s2">value === </span><span class="s0">'object'</span><span class="s2">) {</span>
      <span class="s2">value = doc.schema.createNode(value</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s2">ctx.implicitKey = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(!explicitKey &amp;&amp; !</span><span class="s3">this</span><span class="s2">.comment &amp;&amp; value </span><span class="s3">instanceof </span><span class="s2">Scalar) ctx.indentAtStart = str.length + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">chompKeep = </span><span class="s3">false</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(!indentSeq &amp;&amp; indentSize &gt;= </span><span class="s4">2 </span><span class="s2">&amp;&amp; !ctx.inFlow &amp;&amp; !explicitKey &amp;&amp; value </span><span class="s3">instanceof </span><span class="s2">YAMLSeq &amp;&amp; value.type !== PlainValue.Type.FLOW_SEQ &amp;&amp; !value.tag &amp;&amp; !doc.anchors.getName(value)) {</span>
      <span class="s5">// If indentSeq === false, consider '- ' as part of indentation where possible</span>
      <span class="s2">ctx.indent = ctx.indent.substr(</span><span class="s4">2</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">const </span><span class="s2">valueStr = stringify(value</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">() =&gt; valueComment = </span><span class="s3">null</span><span class="s1">, </span><span class="s2">() =&gt; chompKeep = </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">ws = </span><span class="s0">' '</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(vcb || </span><span class="s3">this</span><span class="s2">.comment) {</span>
      <span class="s2">ws = </span><span class="s0">`</span><span class="s2">${vcb}</span><span class="s1">\n</span><span class="s2">${ctx.indent}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(!explicitKey &amp;&amp; value </span><span class="s3">instanceof </span><span class="s2">Collection) {</span>
      <span class="s3">const </span><span class="s2">flow = valueStr[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">'[' </span><span class="s2">|| valueStr[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">'{'</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(!flow || valueStr.includes(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)) ws = </span><span class="s0">`</span><span class="s1">\n</span><span class="s2">${ctx.indent}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(valueStr[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) ws = </span><span class="s0">''</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(chompKeep &amp;&amp; !valueComment &amp;&amp; onChompKeep) onChompKeep()</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">addComment(str + ws + valueStr</span><span class="s1">, </span><span class="s2">ctx.indent</span><span class="s1">, </span><span class="s2">valueComment)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s2">PlainValue._defineProperty(Pair</span><span class="s1">, </span><span class="s0">&quot;Type&quot;</span><span class="s1">, </span><span class="s2">{</span>
  <span class="s2">PAIR: </span><span class="s0">'PAIR'</span><span class="s1">,</span>
  <span class="s2">MERGE_PAIR: </span><span class="s0">'MERGE_PAIR'</span>
<span class="s2">})</span><span class="s1">;</span>

<span class="s3">const </span><span class="s2">getAliasCount = (node</span><span class="s1">, </span><span class="s2">anchors) =&gt; {</span>
  <span class="s3">if </span><span class="s2">(node </span><span class="s3">instanceof </span><span class="s2">Alias) {</span>
    <span class="s3">const </span><span class="s2">anchor = anchors.get(node.source)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">anchor.count * anchor.aliasCount</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">else if </span><span class="s2">(node </span><span class="s3">instanceof </span><span class="s2">Collection) {</span>
    <span class="s3">let </span><span class="s2">count = </span><span class="s4">0</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">item of node.items) {</span>
      <span class="s3">const </span><span class="s2">c = getAliasCount(item</span><span class="s1">, </span><span class="s2">anchors)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(c &gt; count) count = c</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">count</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">else if </span><span class="s2">(node </span><span class="s3">instanceof </span><span class="s2">Pair) {</span>
    <span class="s3">const </span><span class="s2">kc = getAliasCount(node.key</span><span class="s1">, </span><span class="s2">anchors)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">vc = getAliasCount(node.value</span><span class="s1">, </span><span class="s2">anchors)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">Math.max(kc</span><span class="s1">, </span><span class="s2">vc)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s4">1</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">class </span><span class="s2">Alias </span><span class="s3">extends </span><span class="s2">Node {</span>
  <span class="s3">static </span><span class="s2">stringify({</span>
    <span class="s2">range</span><span class="s1">,</span>
    <span class="s2">source</span>
  <span class="s2">}</span><span class="s1">, </span><span class="s2">{</span>
    <span class="s2">anchors</span><span class="s1">,</span>
    <span class="s2">doc</span><span class="s1">,</span>
    <span class="s2">implicitKey</span><span class="s1">,</span>
    <span class="s2">inStringifyKey</span>
  <span class="s2">}) {</span>
    <span class="s3">let </span><span class="s2">anchor = Object.keys(anchors).find(a =&gt; anchors[a] === source)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(!anchor &amp;&amp; inStringifyKey) anchor = doc.anchors.getName(source) || doc.anchors.newName()</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(anchor) </span><span class="s3">return </span><span class="s0">`*</span><span class="s2">${anchor}${implicitKey ? </span><span class="s0">' ' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">msg = doc.anchors.getName(source) ? </span><span class="s0">'Alias node must be after source node' </span><span class="s2">: </span><span class="s0">'Source node not found for alias node'</span><span class="s1">;</span>
    <span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">`</span><span class="s2">${msg} </span><span class="s0">[</span><span class="s2">${range}</span><span class="s0">]`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">constructor(source) {</span>
    <span class="s3">super</span><span class="s2">()</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.source = source</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.type = PlainValue.Type.ALIAS</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">set tag(t) {</span>
    <span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">'Alias nodes cannot have tags'</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toJSON(arg</span><span class="s1">, </span><span class="s2">ctx) {</span>
    <span class="s3">if </span><span class="s2">(!ctx) </span><span class="s3">return </span><span class="s2">toJSON(</span><span class="s3">this</span><span class="s2">.source</span><span class="s1">, </span><span class="s2">arg</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">anchors</span><span class="s1">,</span>
      <span class="s2">maxAliasCount</span>
    <span class="s2">} = ctx</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">anchor = anchors.get(</span><span class="s3">this</span><span class="s2">.source)</span><span class="s1">;</span>
    <span class="s6">/* istanbul ignore if */</span>

    <span class="s3">if </span><span class="s2">(!anchor || anchor.res === undefined) {</span>
      <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'This should not happen: Alias anchor was not resolved?'</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.cstNode) </span><span class="s3">throw new </span><span class="s2">PlainValue.YAMLReferenceError(</span><span class="s3">this</span><span class="s2">.cstNode</span><span class="s1">, </span><span class="s2">msg)</span><span class="s1">;</span><span class="s3">else throw new </span><span class="s2">ReferenceError(msg)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(maxAliasCount &gt;= </span><span class="s4">0</span><span class="s2">) {</span>
      <span class="s2">anchor.count += </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(anchor.aliasCount === </span><span class="s4">0</span><span class="s2">) anchor.aliasCount = getAliasCount(</span><span class="s3">this</span><span class="s2">.source</span><span class="s1">, </span><span class="s2">anchors)</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(anchor.count * anchor.aliasCount &gt; maxAliasCount) {</span>
        <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Excessive alias count indicates a resource exhaustion attack'</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(</span><span class="s3">this</span><span class="s2">.cstNode) </span><span class="s3">throw new </span><span class="s2">PlainValue.YAMLReferenceError(</span><span class="s3">this</span><span class="s2">.cstNode</span><span class="s1">, </span><span class="s2">msg)</span><span class="s1">;</span><span class="s3">else throw new </span><span class="s2">ReferenceError(msg)</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">anchor.res</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s5">// Only called when stringifying an alias mapping key while constructing</span>
  <span class="s5">// Object output.</span>


  <span class="s2">toString(ctx) {</span>
    <span class="s3">return </span><span class="s2">Alias.stringify(</span><span class="s3">this</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s2">PlainValue._defineProperty(Alias</span><span class="s1">, </span><span class="s0">&quot;default&quot;</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">findPair(items</span><span class="s1">, </span><span class="s2">key) {</span>
  <span class="s3">const </span><span class="s2">k = key </span><span class="s3">instanceof </span><span class="s2">Scalar ? key.value : key</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">it of items) {</span>
    <span class="s3">if </span><span class="s2">(it </span><span class="s3">instanceof </span><span class="s2">Pair) {</span>
      <span class="s3">if </span><span class="s2">(it.key === key || it.key === k) </span><span class="s3">return </span><span class="s2">it</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(it.key &amp;&amp; it.key.value === k) </span><span class="s3">return </span><span class="s2">it</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">undefined</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">class </span><span class="s2">YAMLMap </span><span class="s3">extends </span><span class="s2">Collection {</span>
  <span class="s2">add(pair</span><span class="s1">, </span><span class="s2">overwrite) {</span>
    <span class="s3">if </span><span class="s2">(!pair) pair = </span><span class="s3">new </span><span class="s2">Pair(pair)</span><span class="s1">;</span><span class="s3">else if </span><span class="s2">(!(pair </span><span class="s3">instanceof </span><span class="s2">Pair)) pair = </span><span class="s3">new </span><span class="s2">Pair(pair.key || pair</span><span class="s1">, </span><span class="s2">pair.value)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">prev = findPair(</span><span class="s3">this</span><span class="s2">.items</span><span class="s1">, </span><span class="s2">pair.key)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">sortEntries = </span><span class="s3">this</span><span class="s2">.schema &amp;&amp; </span><span class="s3">this</span><span class="s2">.schema.sortMapEntries</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(prev) {</span>
      <span class="s3">if </span><span class="s2">(overwrite) prev.value = pair.value</span><span class="s1">;</span><span class="s3">else throw new </span><span class="s2">Error(</span><span class="s0">`Key </span><span class="s2">${pair.key} </span><span class="s0">already set`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(sortEntries) {</span>
      <span class="s3">const </span><span class="s2">i = </span><span class="s3">this</span><span class="s2">.items.findIndex(item =&gt; sortEntries(pair</span><span class="s1">, </span><span class="s2">item) &lt; </span><span class="s4">0</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(i === -</span><span class="s4">1</span><span class="s2">) </span><span class="s3">this</span><span class="s2">.items.push(pair)</span><span class="s1">;</span><span class="s3">else this</span><span class="s2">.items.splice(i</span><span class="s1">, </span><span class="s4">0</span><span class="s1">, </span><span class="s2">pair)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">this</span><span class="s2">.items.push(pair)</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">delete</span><span class="s2">(key) {</span>
    <span class="s3">const </span><span class="s2">it = findPair(</span><span class="s3">this</span><span class="s2">.items</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(!it) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">del = </span><span class="s3">this</span><span class="s2">.items.splice(</span><span class="s3">this</span><span class="s2">.items.indexOf(it)</span><span class="s1">, </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">del.length &gt; </span><span class="s4">0</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">get(key</span><span class="s1">, </span><span class="s2">keepScalar) {</span>
    <span class="s3">const </span><span class="s2">it = findPair(</span><span class="s3">this</span><span class="s2">.items</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">node = it &amp;&amp; it.value</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">!keepScalar &amp;&amp; node </span><span class="s3">instanceof </span><span class="s2">Scalar ? node.value : node</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">has(key) {</span>
    <span class="s3">return </span><span class="s2">!!findPair(</span><span class="s3">this</span><span class="s2">.items</span><span class="s1">, </span><span class="s2">key)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">set(key</span><span class="s1">, </span><span class="s2">value) {</span>
    <span class="s3">this</span><span class="s2">.add(</span><span class="s3">new </span><span class="s2">Pair(key</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>
  <span class="s7">/**</span>
   <span class="s7">* </span><span class="s8">@param </span><span class="s7">{*} arg ignored</span>
   <span class="s7">* </span><span class="s8">@param </span><span class="s7">{*} ctx Conversion context, originally set in Document#toJSON()</span>
   <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Class} Type If set, forces the returned collection type</span>
   <span class="s7">* </span><span class="s8">@returns </span><span class="s7">{*} Instance of Type, Map, or Object</span>
   <span class="s7">*/</span>


  <span class="s2">toJSON(_</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">Type) {</span>
    <span class="s3">const </span><span class="s2">map = Type ? </span><span class="s3">new </span><span class="s2">Type() : ctx &amp;&amp; ctx.mapAsMap ? </span><span class="s3">new </span><span class="s2">Map() : {}</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(ctx &amp;&amp; ctx.onCreate) ctx.onCreate(map)</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">item of </span><span class="s3">this</span><span class="s2">.items) item.addToJSMap(ctx</span><span class="s1">, </span><span class="s2">map)</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s2">map</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toString(ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep) {</span>
    <span class="s3">if </span><span class="s2">(!ctx) </span><span class="s3">return </span><span class="s2">JSON.stringify(</span><span class="s3">this</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">item of </span><span class="s3">this</span><span class="s2">.items) {</span>
      <span class="s3">if </span><span class="s2">(!(item </span><span class="s3">instanceof </span><span class="s2">Pair)) </span><span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">`Map items must all be pairs; found </span><span class="s2">${JSON.stringify(item)} </span><span class="s0">instead`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">return super</span><span class="s2">.toString(ctx</span><span class="s1">, </span><span class="s2">{</span>
      <span class="s2">blockItem: n =&gt; n.str</span><span class="s1">,</span>
      <span class="s2">flowChars: {</span>
        <span class="s2">start: </span><span class="s0">'{'</span><span class="s1">,</span>
        <span class="s2">end: </span><span class="s0">'}'</span>
      <span class="s2">}</span><span class="s1">,</span>
      <span class="s2">isMap: </span><span class="s3">true</span><span class="s1">,</span>
      <span class="s2">itemIndent: ctx.indent || </span><span class="s0">''</span>
    <span class="s2">}</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep)</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s3">const </span><span class="s2">MERGE_KEY = </span><span class="s0">'&lt;&lt;'</span><span class="s1">;</span>
<span class="s3">class </span><span class="s2">Merge </span><span class="s3">extends </span><span class="s2">Pair {</span>
  <span class="s2">constructor(pair) {</span>
    <span class="s3">if </span><span class="s2">(pair </span><span class="s3">instanceof </span><span class="s2">Pair) {</span>
      <span class="s3">let </span><span class="s2">seq = pair.value</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(!(seq </span><span class="s3">instanceof </span><span class="s2">YAMLSeq)) {</span>
        <span class="s2">seq = </span><span class="s3">new </span><span class="s2">YAMLSeq()</span><span class="s1">;</span>
        <span class="s2">seq.items.push(pair.value)</span><span class="s1">;</span>
        <span class="s2">seq.range = pair.value.range</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s3">super</span><span class="s2">(pair.key</span><span class="s1">, </span><span class="s2">seq)</span><span class="s1">;</span>
      <span class="s3">this</span><span class="s2">.range = pair.range</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">super</span><span class="s2">(</span><span class="s3">new </span><span class="s2">Scalar(MERGE_KEY)</span><span class="s1">, </span><span class="s3">new </span><span class="s2">YAMLSeq())</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">this</span><span class="s2">.type = Pair.Type.MERGE_PAIR</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s5">// If the value associated with a merge key is a single mapping node, each of</span>
  <span class="s5">// its key/value pairs is inserted into the current mapping, unless the key</span>
  <span class="s5">// already exists in it. If the value associated with the merge key is a</span>
  <span class="s5">// sequence, then this sequence is expected to contain mapping nodes and each</span>
  <span class="s5">// of these nodes is merged in turn according to its order in the sequence.</span>
  <span class="s5">// Keys in mapping nodes earlier in the sequence override keys specified in</span>
  <span class="s5">// later mapping nodes. -- http://yaml.org/type/merge.html</span>


  <span class="s2">addToJSMap(ctx</span><span class="s1">, </span><span class="s2">map) {</span>
    <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">{</span>
      <span class="s2">source</span>
    <span class="s2">} of </span><span class="s3">this</span><span class="s2">.value.items) {</span>
      <span class="s3">if </span><span class="s2">(!(source </span><span class="s3">instanceof </span><span class="s2">YAMLMap)) </span><span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">'Merge sources must be maps'</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">srcMap = source.toJSON(</span><span class="s3">null</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">Map)</span><span class="s1">;</span>

      <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">[key</span><span class="s1">, </span><span class="s2">value] of srcMap) {</span>
        <span class="s3">if </span><span class="s2">(map </span><span class="s3">instanceof </span><span class="s2">Map) {</span>
          <span class="s3">if </span><span class="s2">(!map.has(key)) map.set(key</span><span class="s1">, </span><span class="s2">value)</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(map </span><span class="s3">instanceof </span><span class="s2">Set) {</span>
          <span class="s2">map.add(key)</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(!Object.prototype.hasOwnProperty.call(map</span><span class="s1">, </span><span class="s2">key)) {</span>
          <span class="s2">Object.defineProperty(map</span><span class="s1">, </span><span class="s2">key</span><span class="s1">, </span><span class="s2">{</span>
            <span class="s2">value</span><span class="s1">,</span>
            <span class="s2">writable: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">enumerable: </span><span class="s3">true</span><span class="s1">,</span>
            <span class="s2">configurable: </span><span class="s3">true</span>
          <span class="s2">})</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s3">return </span><span class="s2">map</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">toString(ctx</span><span class="s1">, </span><span class="s2">onComment) {</span>
    <span class="s3">const </span><span class="s2">seq = </span><span class="s3">this</span><span class="s2">.value</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(seq.items.length &gt; </span><span class="s4">1</span><span class="s2">) </span><span class="s3">return super</span><span class="s2">.toString(ctx</span><span class="s1">, </span><span class="s2">onComment)</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.value = seq.items[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">str = </span><span class="s3">super</span><span class="s2">.toString(ctx</span><span class="s1">, </span><span class="s2">onComment)</span><span class="s1">;</span>
    <span class="s3">this</span><span class="s2">.value = seq</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">str</span><span class="s1">;</span>
  <span class="s2">}</span>

<span class="s2">}</span>

<span class="s3">const </span><span class="s2">binaryOptions = {</span>
  <span class="s2">defaultType: PlainValue.Type.BLOCK_LITERAL</span><span class="s1">,</span>
  <span class="s2">lineWidth: </span><span class="s4">76</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">boolOptions = {</span>
  <span class="s2">trueStr: </span><span class="s0">'true'</span><span class="s1">,</span>
  <span class="s2">falseStr: </span><span class="s0">'false'</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">intOptions = {</span>
  <span class="s2">asBigInt: </span><span class="s3">false</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">nullOptions = {</span>
  <span class="s2">nullStr: </span><span class="s0">'null'</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">strOptions = {</span>
  <span class="s2">defaultType: PlainValue.Type.PLAIN</span><span class="s1">,</span>
  <span class="s2">doubleQuoted: {</span>
    <span class="s2">jsonEncoding: </span><span class="s3">false</span><span class="s1">,</span>
    <span class="s2">minMultiLineLength: </span><span class="s4">40</span>
  <span class="s2">}</span><span class="s1">,</span>
  <span class="s2">fold: {</span>
    <span class="s2">lineWidth: </span><span class="s4">80</span><span class="s1">,</span>
    <span class="s2">minContentWidth: </span><span class="s4">20</span>
  <span class="s2">}</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">resolveScalar(str</span><span class="s1">, </span><span class="s2">tags</span><span class="s1">, </span><span class="s2">scalarFallback) {</span>
  <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">{</span>
    <span class="s2">format</span><span class="s1">,</span>
    <span class="s2">test</span><span class="s1">,</span>
    <span class="s2">resolve</span>
  <span class="s2">} of tags) {</span>
    <span class="s3">if </span><span class="s2">(test) {</span>
      <span class="s3">const </span><span class="s2">match = str.match(test)</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(match) {</span>
        <span class="s3">let </span><span class="s2">res = resolve.apply(</span><span class="s3">null</span><span class="s1">, </span><span class="s2">match)</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(!(res </span><span class="s3">instanceof </span><span class="s2">Scalar)) res = </span><span class="s3">new </span><span class="s2">Scalar(res)</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(format) res.format = format</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s2">res</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(scalarFallback) str = scalarFallback(str)</span><span class="s1">;</span>
  <span class="s3">return new </span><span class="s2">Scalar(str)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">const </span><span class="s2">FOLD_FLOW = </span><span class="s0">'flow'</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">FOLD_BLOCK = </span><span class="s0">'block'</span><span class="s1">;</span>
<span class="s3">const </span><span class="s2">FOLD_QUOTED = </span><span class="s0">'quoted'</span><span class="s1">; </span><span class="s5">// presumes i+1 is at the start of a line</span>
<span class="s5">// returns index of last newline in more-indented block</span>

<span class="s3">const </span><span class="s2">consumeMoreIndentedLines = (text</span><span class="s1">, </span><span class="s2">i) =&gt; {</span>
  <span class="s3">let </span><span class="s2">ch = text[i + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

  <span class="s3">while </span><span class="s2">(ch === </span><span class="s0">' ' </span><span class="s2">|| ch === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">) {</span>
    <span class="s3">do </span><span class="s2">{</span>
      <span class="s2">ch = text[i += </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">while </span><span class="s2">(ch &amp;&amp; ch !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s2">ch = text[i + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">i</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>
<span class="s7">/**</span>
 <span class="s7">* Tries to keep input at up to `lineWidth` characters, splitting only on spaces</span>
 <span class="s7">* not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are</span>
 <span class="s7">* terminated with `\n` and started with `indent`.</span>
 <span class="s7">*</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{string} text</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{string} indent</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{string} [mode='flow'] `'block'` prevents more-indented lines</span>
 <span class="s7">*   from being folded; `'quoted'` allows for `\` escapes, including escaped</span>
 <span class="s7">*   newlines</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Object} options</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{number} [options.indentAtStart] Accounts for leading contents on</span>
 <span class="s7">*   the first line, defaulting to `indent.length`</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{number} [options.lineWidth=80]</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{number} [options.minContentWidth=20] Allow highly indented lines to</span>
 <span class="s7">*   stretch the line width or indent content from the start</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{function} options.onFold Called once if the text is folded</span>
 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{function} options.onFold Called once if any line of text exceeds</span>
 <span class="s7">*   lineWidth characters</span>
 <span class="s7">*/</span>


<span class="s3">function </span><span class="s2">foldFlowLines(text</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">mode</span><span class="s1">, </span><span class="s2">{</span>
  <span class="s2">indentAtStart</span><span class="s1">,</span>
  <span class="s2">lineWidth = </span><span class="s4">80</span><span class="s1">,</span>
  <span class="s2">minContentWidth = </span><span class="s4">20</span><span class="s1">,</span>
  <span class="s2">onFold</span><span class="s1">,</span>
  <span class="s2">onOverflow</span>
<span class="s2">}) {</span>
  <span class="s3">if </span><span class="s2">(!lineWidth || lineWidth &lt; </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return </span><span class="s2">text</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">endStep = Math.max(</span><span class="s4">1 </span><span class="s2">+ minContentWidth</span><span class="s1">, </span><span class="s4">1 </span><span class="s2">+ lineWidth - indent.length)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(text.length &lt;= endStep) </span><span class="s3">return </span><span class="s2">text</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">folds = []</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">escapedFolds = {}</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">end = lineWidth - indent.length</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">indentAtStart === </span><span class="s0">'number'</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(indentAtStart &gt; lineWidth - Math.max(</span><span class="s4">2</span><span class="s1">, </span><span class="s2">minContentWidth)) folds.push(</span><span class="s4">0</span><span class="s2">)</span><span class="s1">;</span><span class="s3">else </span><span class="s2">end = lineWidth - indentAtStart</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">let </span><span class="s2">split = undefined</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">prev = undefined</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">overflow = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">i = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">escStart = -</span><span class="s4">1</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">escEnd = -</span><span class="s4">1</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(mode === FOLD_BLOCK) {</span>
    <span class="s2">i = consumeMoreIndentedLines(text</span><span class="s1">, </span><span class="s2">i)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(i !== -</span><span class="s4">1</span><span class="s2">) end = i + endStep</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">ch</span><span class="s1">; </span><span class="s2">ch = text[i += </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(mode === FOLD_QUOTED &amp;&amp; ch === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s2">escStart = i</span><span class="s1">;</span>

      <span class="s3">switch </span><span class="s2">(text[i + </span><span class="s4">1</span><span class="s2">]) {</span>
        <span class="s3">case </span><span class="s0">'x'</span><span class="s2">:</span>
          <span class="s2">i += </span><span class="s4">3</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s0">'u'</span><span class="s2">:</span>
          <span class="s2">i += </span><span class="s4">5</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">case </span><span class="s0">'U'</span><span class="s2">:</span>
          <span class="s2">i += </span><span class="s4">9</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>

        <span class="s3">default</span><span class="s2">:</span>
          <span class="s2">i += </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">escEnd = i</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(ch === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(mode === FOLD_BLOCK) i = consumeMoreIndentedLines(text</span><span class="s1">, </span><span class="s2">i)</span><span class="s1">;</span>
      <span class="s2">end = i + endStep</span><span class="s1">;</span>
      <span class="s2">split = undefined</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">if </span><span class="s2">(ch === </span><span class="s0">' ' </span><span class="s2">&amp;&amp; prev &amp;&amp; prev !== </span><span class="s0">' ' </span><span class="s2">&amp;&amp; prev !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">&amp;&amp; prev !== </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">) {</span>
        <span class="s5">// space surrounded by non-space can be replaced with newline + indent</span>
        <span class="s3">const </span><span class="s2">next = text[i + </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(next &amp;&amp; next !== </span><span class="s0">' ' </span><span class="s2">&amp;&amp; next !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">&amp;&amp; next !== </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">) split = i</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(i &gt;= end) {</span>
        <span class="s3">if </span><span class="s2">(split) {</span>
          <span class="s2">folds.push(split)</span><span class="s1">;</span>
          <span class="s2">end = split + endStep</span><span class="s1">;</span>
          <span class="s2">split = undefined</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s3">else if </span><span class="s2">(mode === FOLD_QUOTED) {</span>
          <span class="s5">// white-space collected at end may stretch past lineWidth</span>
          <span class="s3">while </span><span class="s2">(prev === </span><span class="s0">' ' </span><span class="s2">|| prev === </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">'</span><span class="s2">) {</span>
            <span class="s2">prev = ch</span><span class="s1">;</span>
            <span class="s2">ch = text[i += </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>
            <span class="s2">overflow = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s2">} </span><span class="s5">// Account for newline escape, but don't break preceding escape</span>


          <span class="s3">const </span><span class="s2">j = i &gt; escEnd + </span><span class="s4">1 </span><span class="s2">? i - </span><span class="s4">2 </span><span class="s2">: escStart - </span><span class="s4">1</span><span class="s1">; </span><span class="s5">// Bail out if lineWidth &amp; minContentWidth are shorter than an escape string</span>

          <span class="s3">if </span><span class="s2">(escapedFolds[j]) </span><span class="s3">return </span><span class="s2">text</span><span class="s1">;</span>
          <span class="s2">folds.push(j)</span><span class="s1">;</span>
          <span class="s2">escapedFolds[j] = </span><span class="s3">true</span><span class="s1">;</span>
          <span class="s2">end = j + endStep</span><span class="s1">;</span>
          <span class="s2">split = undefined</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
          <span class="s2">overflow = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>

    <span class="s2">prev = ch</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(overflow &amp;&amp; onOverflow) onOverflow()</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(folds.length === </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return </span><span class="s2">text</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(onFold) onFold()</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">res = text.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">folds[</span><span class="s4">0</span><span class="s2">])</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; folds.length</span><span class="s1">; </span><span class="s2">++i) {</span>
    <span class="s3">const </span><span class="s2">fold = folds[i]</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">end = folds[i + </span><span class="s4">1</span><span class="s2">] || text.length</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(fold === </span><span class="s4">0</span><span class="s2">) res = </span><span class="s0">`</span><span class="s1">\n</span><span class="s2">${indent}${text.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">end)}</span><span class="s0">`</span><span class="s1">;</span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">if </span><span class="s2">(mode === FOLD_QUOTED &amp;&amp; escapedFolds[fold]) res += </span><span class="s0">`</span><span class="s2">${text[fold]}</span><span class="s1">\\</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">res += </span><span class="s0">`</span><span class="s1">\n</span><span class="s2">${indent}${text.slice(fold + </span><span class="s4">1</span><span class="s1">, </span><span class="s2">end)}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">const </span><span class="s2">getFoldOptions = ({</span>
  <span class="s2">indentAtStart</span>
<span class="s2">}) =&gt; indentAtStart ? Object.assign({</span>
  <span class="s2">indentAtStart</span>
<span class="s2">}</span><span class="s1">, </span><span class="s2">strOptions.fold) : strOptions.fold</span><span class="s1">; </span><span class="s5">// Also checks for lines starting with %, as parsing the output as YAML 1.1 will</span>
<span class="s5">// presume that's starting a new document.</span>


<span class="s3">const </span><span class="s2">containsDocumentMarker = str =&gt; </span><span class="s4">/^(%|---|\.\.\.)/m</span><span class="s2">.test(str)</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">lineLengthOverLimit(str</span><span class="s1">, </span><span class="s2">lineWidth</span><span class="s1">, </span><span class="s2">indentLength) {</span>
  <span class="s3">if </span><span class="s2">(!lineWidth || lineWidth &lt; </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return false</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">limit = lineWidth - indentLength</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">strLen = str.length</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(strLen &lt;= limit) </span><span class="s3">return false</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">, </span><span class="s2">start = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; strLen</span><span class="s1">; </span><span class="s2">++i) {</span>
    <span class="s3">if </span><span class="s2">(str[i] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) {</span>
      <span class="s3">if </span><span class="s2">(i - start &gt; limit) </span><span class="s3">return true</span><span class="s1">;</span>
      <span class="s2">start = i + </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(strLen - start &lt;= limit) </span><span class="s3">return false</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">doubleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx) {</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">implicitKey</span>
  <span class="s2">} = ctx</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">jsonEncoding</span><span class="s1">,</span>
    <span class="s2">minMultiLineLength</span>
  <span class="s2">} = strOptions.doubleQuoted</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">json = JSON.stringify(value)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(jsonEncoding) </span><span class="s3">return </span><span class="s2">json</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">indent = ctx.indent || (containsDocumentMarker(value) ? </span><span class="s0">'  ' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">str = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">start = </span><span class="s4">0</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">, </span><span class="s2">ch = json[i]</span><span class="s1">; </span><span class="s2">ch</span><span class="s1">; </span><span class="s2">ch = json[++i]) {</span>
    <span class="s3">if </span><span class="s2">(ch === </span><span class="s0">' ' </span><span class="s2">&amp;&amp; json[i + </span><span class="s4">1</span><span class="s2">] === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">' </span><span class="s2">&amp;&amp; json[i + </span><span class="s4">2</span><span class="s2">] === </span><span class="s0">'n'</span><span class="s2">) {</span>
      <span class="s5">// space before newline needs to be escaped to not be folded</span>
      <span class="s2">str += json.slice(start</span><span class="s1">, </span><span class="s2">i) + </span><span class="s0">'</span><span class="s1">\\ </span><span class="s0">'</span><span class="s1">;</span>
      <span class="s2">i += </span><span class="s4">1</span><span class="s1">;</span>
      <span class="s2">start = i</span><span class="s1">;</span>
      <span class="s2">ch = </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(ch === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s2">) </span><span class="s3">switch </span><span class="s2">(json[i + </span><span class="s4">1</span><span class="s2">]) {</span>
      <span class="s3">case </span><span class="s0">'u'</span><span class="s2">:</span>
        <span class="s2">{</span>
          <span class="s2">str += json.slice(start</span><span class="s1">, </span><span class="s2">i)</span><span class="s1">;</span>
          <span class="s3">const </span><span class="s2">code = json.substr(i + </span><span class="s4">2</span><span class="s1">, </span><span class="s4">4</span><span class="s2">)</span><span class="s1">;</span>

          <span class="s3">switch </span><span class="s2">(code) {</span>
            <span class="s3">case </span><span class="s0">'0000'</span><span class="s2">:</span>
              <span class="s2">str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">0'</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s0">'0007'</span><span class="s2">:</span>
              <span class="s2">str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">a'</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s0">'000b'</span><span class="s2">:</span>
              <span class="s2">str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">v'</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s0">'001b'</span><span class="s2">:</span>
              <span class="s2">str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">e'</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s0">'0085'</span><span class="s2">:</span>
              <span class="s2">str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">N'</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s0">'00a0'</span><span class="s2">:</span>
              <span class="s2">str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">_'</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s0">'2028'</span><span class="s2">:</span>
              <span class="s2">str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">L'</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s0">'2029'</span><span class="s2">:</span>
              <span class="s2">str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">P'</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>

            <span class="s3">default</span><span class="s2">:</span>
              <span class="s3">if </span><span class="s2">(code.substr(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">2</span><span class="s2">) === </span><span class="s0">'00'</span><span class="s2">) str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">x' </span><span class="s2">+ code.substr(</span><span class="s4">2</span><span class="s2">)</span><span class="s1">;</span><span class="s3">else </span><span class="s2">str += json.substr(i</span><span class="s1">, </span><span class="s4">6</span><span class="s2">)</span><span class="s1">;</span>
          <span class="s2">}</span>

          <span class="s2">i += </span><span class="s4">5</span><span class="s1">;</span>
          <span class="s2">start = i + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s0">'n'</span><span class="s2">:</span>
        <span class="s3">if </span><span class="s2">(implicitKey || json[i + </span><span class="s4">2</span><span class="s2">] === </span><span class="s0">'&quot;' </span><span class="s2">|| json.length &lt; minMultiLineLength) {</span>
          <span class="s2">i += </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
          <span class="s5">// folding will eat first newline</span>
          <span class="s2">str += json.slice(start</span><span class="s1">, </span><span class="s2">i) + </span><span class="s0">'</span><span class="s1">\n\n</span><span class="s0">'</span><span class="s1">;</span>

          <span class="s3">while </span><span class="s2">(json[i + </span><span class="s4">2</span><span class="s2">] === </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">' </span><span class="s2">&amp;&amp; json[i + </span><span class="s4">3</span><span class="s2">] === </span><span class="s0">'n' </span><span class="s2">&amp;&amp; json[i + </span><span class="s4">4</span><span class="s2">] !== </span><span class="s0">'&quot;'</span><span class="s2">) {</span>
            <span class="s2">str += </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">;</span>
            <span class="s2">i += </span><span class="s4">2</span><span class="s1">;</span>
          <span class="s2">}</span>

          <span class="s2">str += indent</span><span class="s1">; </span><span class="s5">// space after newline needs to be escaped to not be folded</span>

          <span class="s3">if </span><span class="s2">(json[i + </span><span class="s4">2</span><span class="s2">] === </span><span class="s0">' '</span><span class="s2">) str += </span><span class="s0">'</span><span class="s1">\\</span><span class="s0">'</span><span class="s1">;</span>
          <span class="s2">i += </span><span class="s4">1</span><span class="s1">;</span>
          <span class="s2">start = i + </span><span class="s4">1</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s2">:</span>
        <span class="s2">i += </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s2">str = start ? str + json.slice(start) : json</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">implicitKey ? str : foldFlowLines(str</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">FOLD_QUOTED</span><span class="s1">, </span><span class="s2">getFoldOptions(ctx))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">singleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx) {</span>
  <span class="s3">if </span><span class="s2">(ctx.implicitKey) {</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s4">/\n/</span><span class="s2">.test(value)) </span><span class="s3">return </span><span class="s2">doubleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
    <span class="s5">// single quoted string can't have leading or trailing whitespace around newline</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s4">/[ \t]\n|\n[ \t]/</span><span class="s2">.test(value)) </span><span class="s3">return </span><span class="s2">doubleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">indent = ctx.indent || (containsDocumentMarker(value) ? </span><span class="s0">'  ' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">res = </span><span class="s0">&quot;'&quot; </span><span class="s2">+ value.replace(</span><span class="s4">/'/g</span><span class="s1">, </span><span class="s0">&quot;''&quot;</span><span class="s2">).replace(</span><span class="s4">/\n+/g</span><span class="s1">, </span><span class="s0">`$&amp;</span><span class="s1">\n</span><span class="s2">${indent}</span><span class="s0">`</span><span class="s2">) + </span><span class="s0">&quot;'&quot;</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">ctx.implicitKey ? res : foldFlowLines(res</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">FOLD_FLOW</span><span class="s1">, </span><span class="s2">getFoldOptions(ctx))</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">blockString({</span>
  <span class="s2">comment</span><span class="s1">,</span>
  <span class="s2">type</span><span class="s1">,</span>
  <span class="s2">value</span>
<span class="s2">}</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep) {</span>
  <span class="s5">// 1. Block can't end in whitespace unless the last line is non-empty.</span>
  <span class="s5">// 2. Strings consisting of only whitespace are best rendered explicitly.</span>
  <span class="s3">if </span><span class="s2">(</span><span class="s4">/\n[\t ]+$/</span><span class="s2">.test(value) || </span><span class="s4">/^\s*$/</span><span class="s2">.test(value)) {</span>
    <span class="s3">return </span><span class="s2">doubleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? </span><span class="s0">'  ' </span><span class="s2">: </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">indentSize = indent ? </span><span class="s0">'2' </span><span class="s2">: </span><span class="s0">'1'</span><span class="s1">; </span><span class="s5">// root is at -1</span>

  <span class="s3">const </span><span class="s2">literal = type === PlainValue.Type.BLOCK_FOLDED ? </span><span class="s3">false </span><span class="s2">: type === PlainValue.Type.BLOCK_LITERAL ? </span><span class="s3">true </span><span class="s2">: !lineLengthOverLimit(value</span><span class="s1">, </span><span class="s2">strOptions.fold.lineWidth</span><span class="s1">, </span><span class="s2">indent.length)</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">header = literal ? </span><span class="s0">'|' </span><span class="s2">: </span><span class="s0">'&gt;'</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(!value) </span><span class="s3">return </span><span class="s2">header + </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">wsStart = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">wsEnd = </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s2">value = value.replace(</span><span class="s4">/[\n\t ]*$/</span><span class="s1">, </span><span class="s2">ws =&gt; {</span>
    <span class="s3">const </span><span class="s2">n = ws.indexOf(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(n === -</span><span class="s4">1</span><span class="s2">) {</span>
      <span class="s2">header += </span><span class="s0">'-'</span><span class="s1">; </span><span class="s5">// strip</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(value === ws || n !== ws.length - </span><span class="s4">1</span><span class="s2">) {</span>
      <span class="s2">header += </span><span class="s0">'+'</span><span class="s1">; </span><span class="s5">// keep</span>

      <span class="s3">if </span><span class="s2">(onChompKeep) onChompKeep()</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s2">wsEnd = ws.replace(</span><span class="s4">/\n$/</span><span class="s1">, </span><span class="s0">''</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s2">}).replace(</span><span class="s4">/^[\n ]*/</span><span class="s1">, </span><span class="s2">ws =&gt; {</span>
    <span class="s3">if </span><span class="s2">(ws.indexOf(</span><span class="s0">' '</span><span class="s2">) !== -</span><span class="s4">1</span><span class="s2">) header += indentSize</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">m = ws.match(</span><span class="s4">/ +$/</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(m) {</span>
      <span class="s2">wsStart = ws.slice(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">-m[</span><span class="s4">0</span><span class="s2">].length)</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s2">m[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s2">wsStart = ws</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s0">''</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">})</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(wsEnd) wsEnd = wsEnd.replace(</span><span class="s4">/\n+(?!\n|$)/g</span><span class="s1">, </span><span class="s0">`$&amp;</span><span class="s2">${indent}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(wsStart) wsStart = wsStart.replace(</span><span class="s4">/\n+/g</span><span class="s1">, </span><span class="s0">`$&amp;</span><span class="s2">${indent}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(comment) {</span>
    <span class="s2">header += </span><span class="s0">' #' </span><span class="s2">+ comment.replace(</span><span class="s4">/ ?[\r\n]+/g</span><span class="s1">, </span><span class="s0">' '</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(onComment) onComment()</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(!value) </span><span class="s3">return </span><span class="s0">`</span><span class="s2">${header}${indentSize}</span><span class="s1">\n</span><span class="s2">${indent}${wsEnd}</span><span class="s0">`</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(literal) {</span>
    <span class="s2">value = value.replace(</span><span class="s4">/\n+/g</span><span class="s1">, </span><span class="s0">`$&amp;</span><span class="s2">${indent}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s0">`</span><span class="s2">${header}</span><span class="s1">\n</span><span class="s2">${indent}${wsStart}${value}${wsEnd}</span><span class="s0">`</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">value = value.replace(</span><span class="s4">/\n+/g</span><span class="s1">, </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">$&amp;'</span><span class="s2">).replace(</span><span class="s4">/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g</span><span class="s1">, </span><span class="s0">'$1$2'</span><span class="s2">) </span><span class="s5">// more-indented lines aren't folded</span>
  <span class="s5">//         ^ ind.line  ^ empty     ^ capture next empty lines only at end of indent</span>
  <span class="s2">.replace(</span><span class="s4">/\n+/g</span><span class="s1">, </span><span class="s0">`$&amp;</span><span class="s2">${indent}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">body = foldFlowLines(</span><span class="s0">`</span><span class="s2">${wsStart}${value}${wsEnd}</span><span class="s0">`</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">FOLD_BLOCK</span><span class="s1">, </span><span class="s2">strOptions.fold)</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s0">`</span><span class="s2">${header}</span><span class="s1">\n</span><span class="s2">${indent}${body}</span><span class="s0">`</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">plainString(item</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep) {</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">comment</span><span class="s1">,</span>
    <span class="s2">type</span><span class="s1">,</span>
    <span class="s2">value</span>
  <span class="s2">} = item</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">actualString</span><span class="s1">,</span>
    <span class="s2">implicitKey</span><span class="s1">,</span>
    <span class="s2">indent</span><span class="s1">,</span>
    <span class="s2">inFlow</span>
  <span class="s2">} = ctx</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(implicitKey &amp;&amp; </span><span class="s4">/[\n[\]{},]/</span><span class="s2">.test(value) || inFlow &amp;&amp; </span><span class="s4">/[[\]{},]/</span><span class="s2">.test(value)) {</span>
    <span class="s3">return </span><span class="s2">doubleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(!value || </span><span class="s4">/^[\n\t ,[\]{}#&amp;*!|&gt;'&quot;%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/</span><span class="s2">.test(value)) {</span>
    <span class="s5">// not allowed:</span>
    <span class="s5">// - empty string, '-' or '?'</span>
    <span class="s5">// - start with an indicator character (except [?:-]) or /[?-] /</span>
    <span class="s5">// - '\n ', ': ' or ' \n' anywhere</span>
    <span class="s5">// - '#' not preceded by a non-space char</span>
    <span class="s5">// - end with ' ' or ':'</span>
    <span class="s3">return </span><span class="s2">implicitKey || inFlow || value.indexOf(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) === -</span><span class="s4">1 </span><span class="s2">? value.indexOf(</span><span class="s0">'&quot;'</span><span class="s2">) !== -</span><span class="s4">1 </span><span class="s2">&amp;&amp; value.indexOf(</span><span class="s0">&quot;'&quot;</span><span class="s2">) === -</span><span class="s4">1 </span><span class="s2">? singleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx) : doubleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx) : blockString(item</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(!implicitKey &amp;&amp; !inFlow &amp;&amp; type !== PlainValue.Type.PLAIN &amp;&amp; value.indexOf(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) !== -</span><span class="s4">1</span><span class="s2">) {</span>
    <span class="s5">// Where allowed &amp; type not set explicitly, prefer block style for multiline strings</span>
    <span class="s3">return </span><span class="s2">blockString(item</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(indent === </span><span class="s0">'' </span><span class="s2">&amp;&amp; containsDocumentMarker(value)) {</span>
    <span class="s2">ctx.forceBlockIndent = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">blockString(item</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">str = value.replace(</span><span class="s4">/\n+/g</span><span class="s1">, </span><span class="s0">`$&amp;</span><span class="s1">\n</span><span class="s2">${indent}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">; </span><span class="s5">// Verify that output will be parsed as a string, as e.g. plain numbers and</span>
  <span class="s5">// booleans get parsed with those types in v1.2 (e.g. '42', 'true' &amp; '0.9e-3'),</span>
  <span class="s5">// and others in v1.1.</span>

  <span class="s3">if </span><span class="s2">(actualString) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">tags</span>
    <span class="s2">} = ctx.doc.schema</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">resolved = resolveScalar(str</span><span class="s1">, </span><span class="s2">tags</span><span class="s1">, </span><span class="s2">tags.scalarFallback).value</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">resolved !== </span><span class="s0">'string'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">doubleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">body = implicitKey ? str : foldFlowLines(str</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">FOLD_FLOW</span><span class="s1">, </span><span class="s2">getFoldOptions(ctx))</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(comment &amp;&amp; !inFlow &amp;&amp; (body.indexOf(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) !== -</span><span class="s4">1 </span><span class="s2">|| comment.indexOf(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) !== -</span><span class="s4">1</span><span class="s2">)) {</span>
    <span class="s3">if </span><span class="s2">(onComment) onComment()</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">addCommentBefore(body</span><span class="s1">, </span><span class="s2">indent</span><span class="s1">, </span><span class="s2">comment)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">body</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">stringifyString(item</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep) {</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">defaultType</span>
  <span class="s2">} = strOptions</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">implicitKey</span><span class="s1">,</span>
    <span class="s2">inFlow</span>
  <span class="s2">} = ctx</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">{</span>
    <span class="s2">type</span><span class="s1">,</span>
    <span class="s2">value</span>
  <span class="s2">} = item</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">value !== </span><span class="s0">'string'</span><span class="s2">) {</span>
    <span class="s2">value = String(value)</span><span class="s1">;</span>
    <span class="s2">item = Object.assign({}</span><span class="s1">, </span><span class="s2">item</span><span class="s1">, </span><span class="s2">{</span>
      <span class="s2">value</span>
    <span class="s2">})</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">_stringify = _type =&gt; {</span>
    <span class="s3">switch </span><span class="s2">(_type) {</span>
      <span class="s3">case </span><span class="s2">PlainValue.Type.BLOCK_FOLDED:</span>
      <span class="s3">case </span><span class="s2">PlainValue.Type.BLOCK_LITERAL:</span>
        <span class="s3">return </span><span class="s2">blockString(item</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep)</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Type.QUOTE_DOUBLE:</span>
        <span class="s3">return </span><span class="s2">doubleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Type.QUOTE_SINGLE:</span>
        <span class="s3">return </span><span class="s2">singleQuotedString(value</span><span class="s1">, </span><span class="s2">ctx)</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Type.PLAIN:</span>
        <span class="s3">return </span><span class="s2">plainString(item</span><span class="s1">, </span><span class="s2">ctx</span><span class="s1">, </span><span class="s2">onComment</span><span class="s1">, </span><span class="s2">onChompKeep)</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s2">:</span>
        <span class="s3">return null</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(type !== PlainValue.Type.QUOTE_DOUBLE &amp;&amp; </span><span class="s4">/[\x00-\x08\x0b-\x1f\x7f-\x9f]/</span><span class="s2">.test(value)) {</span>
    <span class="s5">// force double quotes on control characters</span>
    <span class="s2">type = PlainValue.Type.QUOTE_DOUBLE</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">else if </span><span class="s2">((implicitKey || inFlow) &amp;&amp; (type === PlainValue.Type.BLOCK_FOLDED || type === PlainValue.Type.BLOCK_LITERAL)) {</span>
    <span class="s5">// should not happen; blocks are not valid inside flow containers</span>
    <span class="s2">type = PlainValue.Type.QUOTE_DOUBLE</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">let </span><span class="s2">res = _stringify(type)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(res === </span><span class="s3">null</span><span class="s2">) {</span>
    <span class="s2">res = _stringify(defaultType)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(res === </span><span class="s3">null</span><span class="s2">) </span><span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">`Unsupported default string type </span><span class="s2">${defaultType}</span><span class="s0">`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">res</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">stringifyNumber({</span>
  <span class="s2">format</span><span class="s1">,</span>
  <span class="s2">minFractionDigits</span><span class="s1">,</span>
  <span class="s2">tag</span><span class="s1">,</span>
  <span class="s2">value</span>
<span class="s2">}) {</span>
  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">value === </span><span class="s0">'bigint'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">String(value)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(!isFinite(value)) </span><span class="s3">return </span><span class="s2">isNaN(value) ? </span><span class="s0">'.nan' </span><span class="s2">: value &lt; </span><span class="s4">0 </span><span class="s2">? </span><span class="s0">'-.inf' </span><span class="s2">: </span><span class="s0">'.inf'</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">n = JSON.stringify(value)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(!format &amp;&amp; minFractionDigits &amp;&amp; (!tag || tag === </span><span class="s0">'tag:yaml.org,2002:float'</span><span class="s2">) &amp;&amp; </span><span class="s4">/^\d/</span><span class="s2">.test(n)) {</span>
    <span class="s3">let </span><span class="s2">i = n.indexOf(</span><span class="s0">'.'</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(i &lt; </span><span class="s4">0</span><span class="s2">) {</span>
      <span class="s2">i = n.length</span><span class="s1">;</span>
      <span class="s2">n += </span><span class="s0">'.'</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">let </span><span class="s2">d = minFractionDigits - (n.length - i - </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s3">while </span><span class="s2">(d-- &gt; </span><span class="s4">0</span><span class="s2">) n += </span><span class="s0">'0'</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">n</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">checkFlowCollectionEnd(errors</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">let </span><span class="s2">char</span><span class="s1">, </span><span class="s2">name</span><span class="s1">;</span>

  <span class="s3">switch </span><span class="s2">(cst.type) {</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.FLOW_MAP:</span>
      <span class="s2">char = </span><span class="s0">'}'</span><span class="s1">;</span>
      <span class="s2">name = </span><span class="s0">'flow map'</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">PlainValue.Type.FLOW_SEQ:</span>
      <span class="s2">char = </span><span class="s0">']'</span><span class="s1">;</span>
      <span class="s2">name = </span><span class="s0">'flow sequence'</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>

    <span class="s3">default</span><span class="s2">:</span>
      <span class="s2">errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(cst</span><span class="s1">, </span><span class="s0">'Not a flow collection!?'</span><span class="s2">))</span><span class="s1">;</span>
      <span class="s3">return</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">let </span><span class="s2">lastItem</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = cst.items.length - </span><span class="s4">1</span><span class="s1">; </span><span class="s2">i &gt;= </span><span class="s4">0</span><span class="s1">; </span><span class="s2">--i) {</span>
    <span class="s3">const </span><span class="s2">item = cst.items[i]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(!item || item.type !== PlainValue.Type.COMMENT) {</span>
      <span class="s2">lastItem = item</span><span class="s1">;</span>
      <span class="s3">break</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(lastItem &amp;&amp; lastItem.char !== char) {</span>
    <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Expected </span><span class="s2">${name} </span><span class="s0">to end with </span><span class="s2">${char}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s3">let </span><span class="s2">err</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">lastItem.offset === </span><span class="s0">'number'</span><span class="s2">) {</span>
      <span class="s2">err = </span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(cst</span><span class="s1">, </span><span class="s2">msg)</span><span class="s1">;</span>
      <span class="s2">err.offset = lastItem.offset + </span><span class="s4">1</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s2">err = </span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(lastItem</span><span class="s1">, </span><span class="s2">msg)</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(lastItem.range &amp;&amp; lastItem.range.end) err.offset = lastItem.range.end - lastItem.range.start</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s2">errors.push(err)</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">checkFlowCommentSpace(errors</span><span class="s1">, </span><span class="s2">comment) {</span>
  <span class="s3">const </span><span class="s2">prev = comment.context.src[comment.range.start - </span><span class="s4">1</span><span class="s2">]</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(prev !== </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">&amp;&amp; prev !== </span><span class="s0">'</span><span class="s1">\t</span><span class="s0">' </span><span class="s2">&amp;&amp; prev !== </span><span class="s0">' '</span><span class="s2">) {</span>
    <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Comments must be separated from other tokens by white space characters'</span><span class="s1">;</span>
    <span class="s2">errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(comment</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">getLongKeyError(source</span><span class="s1">, </span><span class="s2">key) {</span>
  <span class="s3">const </span><span class="s2">sk = String(key)</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">k = sk.substr(</span><span class="s4">0</span><span class="s1">, </span><span class="s4">8</span><span class="s2">) + </span><span class="s0">'...' </span><span class="s2">+ sk.substr(-</span><span class="s4">8</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s3">return new </span><span class="s2">PlainValue.YAMLSemanticError(source</span><span class="s1">, </span><span class="s0">`The &quot;</span><span class="s2">${k}</span><span class="s0">&quot; key is too long`</span><span class="s2">)</span><span class="s1">;</span>
<span class="s2">}</span>
<span class="s3">function </span><span class="s2">resolveComments(collection</span><span class="s1">, </span><span class="s2">comments) {</span>
  <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">{</span>
    <span class="s2">afterKey</span><span class="s1">,</span>
    <span class="s2">before</span><span class="s1">,</span>
    <span class="s2">comment</span>
  <span class="s2">} of comments) {</span>
    <span class="s3">let </span><span class="s2">item = collection.items[before]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(!item) {</span>
      <span class="s3">if </span><span class="s2">(comment !== undefined) {</span>
        <span class="s3">if </span><span class="s2">(collection.comment) collection.comment += </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">+ comment</span><span class="s1">;</span><span class="s3">else </span><span class="s2">collection.comment = comment</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">if </span><span class="s2">(afterKey &amp;&amp; item.value) item = item.value</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(comment === undefined) {</span>
        <span class="s3">if </span><span class="s2">(afterKey || !item.commentBefore) item.spaceBefore = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">if </span><span class="s2">(item.commentBefore) item.commentBefore += </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">' </span><span class="s2">+ comment</span><span class="s1">;</span><span class="s3">else </span><span class="s2">item.commentBefore = comment</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>
<span class="s2">}</span>

<span class="s5">// on error, will return { str: string, errors: Error[] }</span>
<span class="s3">function </span><span class="s2">resolveString(doc</span><span class="s1">, </span><span class="s2">node) {</span>
  <span class="s3">const </span><span class="s2">res = node.strValue</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(!res) </span><span class="s3">return </span><span class="s0">''</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">res === </span><span class="s0">'string'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">res</span><span class="s1">;</span>
  <span class="s2">res.errors.forEach(error =&gt; {</span>
    <span class="s3">if </span><span class="s2">(!error.source) error.source = node</span><span class="s1">;</span>
    <span class="s2">doc.errors.push(error)</span><span class="s1">;</span>
  <span class="s2">})</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">res.str</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveTagHandle(doc</span><span class="s1">, </span><span class="s2">node) {</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">handle</span><span class="s1">,</span>
    <span class="s2">suffix</span>
  <span class="s2">} = node.tag</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">prefix = doc.tagPrefixes.find(p =&gt; p.handle === handle)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(!prefix) {</span>
    <span class="s3">const </span><span class="s2">dtp = doc.getDefaults().tagPrefixes</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(dtp) prefix = dtp.find(p =&gt; p.handle === handle)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(!prefix) </span><span class="s3">throw new </span><span class="s2">PlainValue.YAMLSemanticError(node</span><span class="s1">, </span><span class="s0">`The </span><span class="s2">${handle} </span><span class="s0">tag handle is non-default and was not declared.`</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(!suffix) </span><span class="s3">throw new </span><span class="s2">PlainValue.YAMLSemanticError(node</span><span class="s1">, </span><span class="s0">`The </span><span class="s2">${handle} </span><span class="s0">tag has no suffix.`</span><span class="s2">)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(handle === </span><span class="s0">'!' </span><span class="s2">&amp;&amp; (doc.version || doc.options.version) === </span><span class="s0">'1.0'</span><span class="s2">) {</span>
    <span class="s3">if </span><span class="s2">(suffix[</span><span class="s4">0</span><span class="s2">] === </span><span class="s0">'^'</span><span class="s2">) {</span>
      <span class="s2">doc.warnings.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLWarning(node</span><span class="s1">, </span><span class="s0">'YAML 1.0 ^ tag expansion is not supported'</span><span class="s2">))</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s2">suffix</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s4">/[:/]/</span><span class="s2">.test(suffix)) {</span>
      <span class="s5">// word/foo -&gt; tag:word.yaml.org,2002:foo</span>
      <span class="s3">const </span><span class="s2">vocab = suffix.match(</span><span class="s4">/^([a-z0-9-]+)\/(.*)/i</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s2">vocab ? </span><span class="s0">`tag:</span><span class="s2">${vocab[</span><span class="s4">1</span><span class="s2">]}</span><span class="s0">.yaml.org,2002:</span><span class="s2">${vocab[</span><span class="s4">2</span><span class="s2">]}</span><span class="s0">` </span><span class="s2">: </span><span class="s0">`tag:</span><span class="s2">${suffix}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">prefix.prefix + decodeURIComponent(suffix)</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveTagName(doc</span><span class="s1">, </span><span class="s2">node) {</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">tag</span><span class="s1">,</span>
    <span class="s2">type</span>
  <span class="s2">} = node</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">nonSpecific = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(tag) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">handle</span><span class="s1">,</span>
      <span class="s2">suffix</span><span class="s1">,</span>
      <span class="s2">verbatim</span>
    <span class="s2">} = tag</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(verbatim) {</span>
      <span class="s3">if </span><span class="s2">(verbatim !== </span><span class="s0">'!' </span><span class="s2">&amp;&amp; verbatim !== </span><span class="s0">'!!'</span><span class="s2">) </span><span class="s3">return </span><span class="s2">verbatim</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Verbatim tags aren't resolved, so </span><span class="s2">${verbatim} </span><span class="s0">is invalid.`</span><span class="s1">;</span>
      <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(handle === </span><span class="s0">'!' </span><span class="s2">&amp;&amp; !suffix) {</span>
      <span class="s2">nonSpecific = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">try </span><span class="s2">{</span>
        <span class="s3">return </span><span class="s2">resolveTagHandle(doc</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
        <span class="s2">doc.errors.push(error)</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">switch </span><span class="s2">(type) {</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.BLOCK_FOLDED:</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.BLOCK_LITERAL:</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.QUOTE_DOUBLE:</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.QUOTE_SINGLE:</span>
      <span class="s3">return </span><span class="s2">PlainValue.defaultTags.STR</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">PlainValue.Type.FLOW_MAP:</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.MAP:</span>
      <span class="s3">return </span><span class="s2">PlainValue.defaultTags.MAP</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">PlainValue.Type.FLOW_SEQ:</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.SEQ:</span>
      <span class="s3">return </span><span class="s2">PlainValue.defaultTags.SEQ</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">PlainValue.Type.PLAIN:</span>
      <span class="s3">return </span><span class="s2">nonSpecific ? PlainValue.defaultTags.STR : </span><span class="s3">null</span><span class="s1">;</span>

    <span class="s3">default</span><span class="s2">:</span>
      <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveByTagName(doc</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">tagName) {</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">tags</span>
  <span class="s2">} = doc.schema</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">matchWithTest = []</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">tag of tags) {</span>
    <span class="s3">if </span><span class="s2">(tag.tag === tagName) {</span>
      <span class="s3">if </span><span class="s2">(tag.test) matchWithTest.push(tag)</span><span class="s1">;</span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">const </span><span class="s2">res = tag.resolve(doc</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
        <span class="s3">return </span><span class="s2">res </span><span class="s3">instanceof </span><span class="s2">Collection ? res : </span><span class="s3">new </span><span class="s2">Scalar(res)</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">str = resolveString(doc</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">str === </span><span class="s0">'string' </span><span class="s2">&amp;&amp; matchWithTest.length &gt; </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return </span><span class="s2">resolveScalar(str</span><span class="s1">, </span><span class="s2">matchWithTest</span><span class="s1">, </span><span class="s2">tags.scalarFallback)</span><span class="s1">;</span>
  <span class="s3">return null</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">getFallbackTagName({</span>
  <span class="s2">type</span>
<span class="s2">}) {</span>
  <span class="s3">switch </span><span class="s2">(type) {</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.FLOW_MAP:</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.MAP:</span>
      <span class="s3">return </span><span class="s2">PlainValue.defaultTags.MAP</span><span class="s1">;</span>

    <span class="s3">case </span><span class="s2">PlainValue.Type.FLOW_SEQ:</span>
    <span class="s3">case </span><span class="s2">PlainValue.Type.SEQ:</span>
      <span class="s3">return </span><span class="s2">PlainValue.defaultTags.SEQ</span><span class="s1">;</span>

    <span class="s3">default</span><span class="s2">:</span>
      <span class="s3">return </span><span class="s2">PlainValue.defaultTags.STR</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveTag(doc</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">tagName) {</span>
  <span class="s3">try </span><span class="s2">{</span>
    <span class="s3">const </span><span class="s2">res = resolveByTagName(doc</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">tagName)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(res) {</span>
      <span class="s3">if </span><span class="s2">(tagName &amp;&amp; node.tag) res.tag = tagName</span><span class="s1">;</span>
      <span class="s3">return </span><span class="s2">res</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
    <span class="s6">/* istanbul ignore if */</span>
    <span class="s3">if </span><span class="s2">(!error.source) error.source = node</span><span class="s1">;</span>
    <span class="s2">doc.errors.push(error)</span><span class="s1">;</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">try </span><span class="s2">{</span>
    <span class="s3">const </span><span class="s2">fallback = getFallbackTagName(node)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(!fallback) </span><span class="s3">throw new </span><span class="s2">Error(</span><span class="s0">`The tag </span><span class="s2">${tagName} </span><span class="s0">is unavailable`</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`The tag </span><span class="s2">${tagName} </span><span class="s0">is unavailable, falling back to </span><span class="s2">${fallback}</span><span class="s0">`</span><span class="s1">;</span>
    <span class="s2">doc.warnings.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLWarning(node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">res = resolveByTagName(doc</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">fallback)</span><span class="s1">;</span>
    <span class="s2">res.tag = tagName</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">res</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
    <span class="s3">const </span><span class="s2">refError = </span><span class="s3">new </span><span class="s2">PlainValue.YAMLReferenceError(node</span><span class="s1">, </span><span class="s2">error.message)</span><span class="s1">;</span>
    <span class="s2">refError.stack = error.stack</span><span class="s1">;</span>
    <span class="s2">doc.errors.push(refError)</span><span class="s1">;</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">}</span>

<span class="s3">const </span><span class="s2">isCollectionItem = node =&gt; {</span>
  <span class="s3">if </span><span class="s2">(!node) </span><span class="s3">return false</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">type</span>
  <span class="s2">} = node</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">type === PlainValue.Type.MAP_KEY || type === PlainValue.Type.MAP_VALUE || type === PlainValue.Type.SEQ_ITEM</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">resolveNodeProps(errors</span><span class="s1">, </span><span class="s2">node) {</span>
  <span class="s3">const </span><span class="s2">comments = {</span>
    <span class="s2">before: []</span><span class="s1">,</span>
    <span class="s2">after: []</span>
  <span class="s2">}</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">hasAnchor = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">hasTag = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">props = isCollectionItem(node.context.parent) ? node.context.parent.props.concat(node.props) : node.props</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">const </span><span class="s2">{</span>
    <span class="s2">start</span><span class="s1">,</span>
    <span class="s2">end</span>
  <span class="s2">} of props) {</span>
    <span class="s3">switch </span><span class="s2">(node.context.src[start]) {</span>
      <span class="s3">case </span><span class="s2">PlainValue.Char.COMMENT:</span>
        <span class="s2">{</span>
          <span class="s3">if </span><span class="s2">(!node.commentHasRequiredWhitespace(start)) {</span>
            <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Comments must be separated from other tokens by white space characters'</span><span class="s1">;</span>
            <span class="s2">errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
          <span class="s2">}</span>

          <span class="s3">const </span><span class="s2">{</span>
            <span class="s2">header</span><span class="s1">,</span>
            <span class="s2">valueRange</span>
          <span class="s2">} = node</span><span class="s1">;</span>
          <span class="s3">const </span><span class="s2">cc = valueRange &amp;&amp; (start &gt; valueRange.start || header &amp;&amp; start &gt; header.start) ? comments.after : comments.before</span><span class="s1">;</span>
          <span class="s2">cc.push(node.context.src.slice(start + </span><span class="s4">1</span><span class="s1">, </span><span class="s2">end))</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s5">// Actual anchor &amp; tag resolution is handled by schema, here we just complain</span>

      <span class="s3">case </span><span class="s2">PlainValue.Char.ANCHOR:</span>
        <span class="s3">if </span><span class="s2">(hasAnchor) {</span>
          <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'A node can have at most one anchor'</span><span class="s1">;</span>
          <span class="s2">errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s2">hasAnchor = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Char.TAG:</span>
        <span class="s3">if </span><span class="s2">(hasTag) {</span>
          <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'A node can have at most one tag'</span><span class="s1">;</span>
          <span class="s2">errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s2">hasTag = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">{</span>
    <span class="s2">comments</span><span class="s1">,</span>
    <span class="s2">hasAnchor</span><span class="s1">,</span>
    <span class="s2">hasTag</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveNodeValue(doc</span><span class="s1">, </span><span class="s2">node) {</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">anchors</span><span class="s1">,</span>
    <span class="s2">errors</span><span class="s1">,</span>
    <span class="s2">schema</span>
  <span class="s2">} = doc</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(node.type === PlainValue.Type.ALIAS) {</span>
    <span class="s3">const </span><span class="s2">name = node.rawValue</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">src = anchors.getNode(name)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(!src) {</span>
      <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Aliased anchor not found: </span><span class="s2">${name}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s2">errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLReferenceError(node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
      <span class="s3">return null</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s5">// Lazy resolution for circular references</span>


    <span class="s3">const </span><span class="s2">res = </span><span class="s3">new </span><span class="s2">Alias(src)</span><span class="s1">;</span>

    <span class="s2">anchors._cstAliases.push(res)</span><span class="s1">;</span>

    <span class="s3">return </span><span class="s2">res</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">tagName = resolveTagName(doc</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(tagName) </span><span class="s3">return </span><span class="s2">resolveTag(doc</span><span class="s1">, </span><span class="s2">node</span><span class="s1">, </span><span class="s2">tagName)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(node.type !== PlainValue.Type.PLAIN) {</span>
    <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Failed to resolve </span><span class="s2">${node.type} </span><span class="s0">node here`</span><span class="s1">;</span>
    <span class="s2">errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSyntaxError(node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">try </span><span class="s2">{</span>
    <span class="s3">const </span><span class="s2">str = resolveString(doc</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>
    <span class="s3">return </span><span class="s2">resolveScalar(str</span><span class="s1">, </span><span class="s2">schema.tags</span><span class="s1">, </span><span class="s2">schema.tags.scalarFallback)</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">catch </span><span class="s2">(error) {</span>
    <span class="s3">if </span><span class="s2">(!error.source) error.source = node</span><span class="s1">;</span>
    <span class="s2">errors.push(error)</span><span class="s1">;</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>
<span class="s2">} </span><span class="s5">// sets node.resolved on success</span>


<span class="s3">function </span><span class="s2">resolveNode(doc</span><span class="s1">, </span><span class="s2">node) {</span>
  <span class="s3">if </span><span class="s2">(!node) </span><span class="s3">return null</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(node.error) doc.errors.push(node.error)</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">comments</span><span class="s1">,</span>
    <span class="s2">hasAnchor</span><span class="s1">,</span>
    <span class="s2">hasTag</span>
  <span class="s2">} = resolveNodeProps(doc.errors</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(hasAnchor) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">anchors</span>
    <span class="s2">} = doc</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">name = node.anchor</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">prev = anchors.getNode(name)</span><span class="s1">; </span><span class="s5">// At this point, aliases for any preceding node with the same anchor</span>
    <span class="s5">// name have already been resolved, so it may safely be renamed.</span>

    <span class="s3">if </span><span class="s2">(prev) anchors.map[anchors.newName(name)] = prev</span><span class="s1">; </span><span class="s5">// During parsing, we need to store the CST node in anchors.map as</span>
    <span class="s5">// anchors need to be available during resolution to allow for</span>
    <span class="s5">// circular references.</span>

    <span class="s2">anchors.map[name] = node</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(node.type === PlainValue.Type.ALIAS &amp;&amp; (hasAnchor || hasTag)) {</span>
    <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'An alias node must not specify any properties'</span><span class="s1">;</span>
    <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">res = resolveNodeValue(doc</span><span class="s1">, </span><span class="s2">node)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(res) {</span>
    <span class="s2">res.range = [node.range.start</span><span class="s1">, </span><span class="s2">node.range.end]</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(doc.options.keepCstNodes) res.cstNode = node</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(doc.options.keepNodeTypes) res.type = node.type</span><span class="s1">;</span>
    <span class="s3">const </span><span class="s2">cb = comments.before.join(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(cb) {</span>
      <span class="s2">res.commentBefore = res.commentBefore ? </span><span class="s0">`</span><span class="s2">${res.commentBefore}</span><span class="s1">\n</span><span class="s2">${cb}</span><span class="s0">` </span><span class="s2">: cb</span><span class="s1">;</span>
    <span class="s2">}</span>

    <span class="s3">const </span><span class="s2">ca = comments.after.join(</span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(ca) res.comment = res.comment ? </span><span class="s0">`</span><span class="s2">${res.comment}</span><span class="s1">\n</span><span class="s2">${ca}</span><span class="s0">` </span><span class="s2">: ca</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">node.resolved = res</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveMap(doc</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">if </span><span class="s2">(cst.type !== PlainValue.Type.MAP &amp;&amp; cst.type !== PlainValue.Type.FLOW_MAP) {</span>
    <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`A </span><span class="s2">${cst.type} </span><span class="s0">node cannot be resolved as a mapping`</span><span class="s1">;</span>
    <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSyntaxError(cst</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">comments</span><span class="s1">,</span>
    <span class="s2">items</span>
  <span class="s2">} = cst.type === PlainValue.Type.FLOW_MAP ? resolveFlowMapItems(doc</span><span class="s1">, </span><span class="s2">cst) : resolveBlockMapItems(doc</span><span class="s1">, </span><span class="s2">cst)</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">map = </span><span class="s3">new </span><span class="s2">YAMLMap()</span><span class="s1">;</span>
  <span class="s2">map.items = items</span><span class="s1">;</span>
  <span class="s2">resolveComments(map</span><span class="s1">, </span><span class="s2">comments)</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">hasCollectionKey = </span><span class="s3">false</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; items.length</span><span class="s1">; </span><span class="s2">++i) {</span>
    <span class="s3">const </span><span class="s2">{</span>
      <span class="s2">key: iKey</span>
    <span class="s2">} = items[i]</span><span class="s1">;</span>
    <span class="s3">if </span><span class="s2">(iKey </span><span class="s3">instanceof </span><span class="s2">Collection) hasCollectionKey = </span><span class="s3">true</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(doc.schema.merge &amp;&amp; iKey &amp;&amp; iKey.value === MERGE_KEY) {</span>
      <span class="s2">items[i] = </span><span class="s3">new </span><span class="s2">Merge(items[i])</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">sources = items[i].value.items</span><span class="s1">;</span>
      <span class="s3">let </span><span class="s2">error = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s2">sources.some(node =&gt; {</span>
        <span class="s3">if </span><span class="s2">(node </span><span class="s3">instanceof </span><span class="s2">Alias) {</span>
          <span class="s5">// During parsing, alias sources are CST nodes; to account for</span>
          <span class="s5">// circular references their resolved values can't be used here.</span>
          <span class="s3">const </span><span class="s2">{</span>
            <span class="s2">type</span>
          <span class="s2">} = node.source</span><span class="s1">;</span>
          <span class="s3">if </span><span class="s2">(type === PlainValue.Type.MAP || type === PlainValue.Type.FLOW_MAP) </span><span class="s3">return false</span><span class="s1">;</span>
          <span class="s3">return </span><span class="s2">error = </span><span class="s0">'Merge nodes aliases can only point to maps'</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s3">return </span><span class="s2">error = </span><span class="s0">'Merge nodes can only have Alias nodes as values'</span><span class="s1">;</span>
      <span class="s2">})</span><span class="s1">;</span>
      <span class="s3">if </span><span class="s2">(error) doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(cst</span><span class="s1">, </span><span class="s2">error))</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">j = i + </span><span class="s4">1</span><span class="s1">; </span><span class="s2">j &lt; items.length</span><span class="s1">; </span><span class="s2">++j) {</span>
        <span class="s3">const </span><span class="s2">{</span>
          <span class="s2">key: jKey</span>
        <span class="s2">} = items[j]</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s2">(iKey === jKey || iKey &amp;&amp; jKey &amp;&amp; Object.prototype.hasOwnProperty.call(iKey</span><span class="s1">, </span><span class="s0">'value'</span><span class="s2">) &amp;&amp; iKey.value === jKey.value) {</span>
          <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Map keys must be unique; &quot;</span><span class="s2">${iKey}</span><span class="s0">&quot; is repeated`</span><span class="s1">;</span>
          <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(cst</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
          <span class="s3">break</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">}</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(hasCollectionKey &amp;&amp; !doc.options.mapAsMap) {</span>
    <span class="s3">const </span><span class="s2">warn = </span><span class="s0">'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.'</span><span class="s1">;</span>
    <span class="s2">doc.warnings.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLWarning(cst</span><span class="s1">, </span><span class="s2">warn))</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">cst.resolved = map</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">map</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">const </span><span class="s2">valueHasPairComment = ({</span>
  <span class="s2">context: {</span>
    <span class="s2">lineStart</span><span class="s1">,</span>
    <span class="s2">node</span><span class="s1">,</span>
    <span class="s2">src</span>
  <span class="s2">}</span><span class="s1">,</span>
  <span class="s2">props</span>
<span class="s2">}) =&gt; {</span>
  <span class="s3">if </span><span class="s2">(props.length === </span><span class="s4">0</span><span class="s2">) </span><span class="s3">return false</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">start</span>
  <span class="s2">} = props[</span><span class="s4">0</span><span class="s2">]</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(node &amp;&amp; start &gt; node.valueRange.start) </span><span class="s3">return false</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(src[start] !== PlainValue.Char.COMMENT) </span><span class="s3">return false</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = lineStart</span><span class="s1">; </span><span class="s2">i &lt; start</span><span class="s1">; </span><span class="s2">++i) </span><span class="s3">if </span><span class="s2">(src[i] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) </span><span class="s3">return false</span><span class="s1">;</span>

  <span class="s3">return true</span><span class="s1">;</span>
<span class="s2">}</span><span class="s1">;</span>

<span class="s3">function </span><span class="s2">resolvePairComment(item</span><span class="s1">, </span><span class="s2">pair) {</span>
  <span class="s3">if </span><span class="s2">(!valueHasPairComment(item)) </span><span class="s3">return</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">comment = item.getPropValue(</span><span class="s4">0</span><span class="s1">, </span><span class="s2">PlainValue.Char.COMMENT</span><span class="s1">, </span><span class="s3">true</span><span class="s2">)</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">found = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">cb = pair.value.commentBefore</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(cb &amp;&amp; cb.startsWith(comment)) {</span>
    <span class="s2">pair.value.commentBefore = cb.substr(comment.length + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
    <span class="s2">found = </span><span class="s3">true</span><span class="s1">;</span>
  <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
    <span class="s3">const </span><span class="s2">cc = pair.value.comment</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(!item.node &amp;&amp; cc &amp;&amp; cc.startsWith(comment)) {</span>
      <span class="s2">pair.value.comment = cc.substr(comment.length + </span><span class="s4">1</span><span class="s2">)</span><span class="s1">;</span>
      <span class="s2">found = </span><span class="s3">true</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(found) pair.comment = comment</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveBlockMapItems(doc</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">const </span><span class="s2">comments = []</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">items = []</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">key = undefined</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">keyStart = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; cst.items.length</span><span class="s1">; </span><span class="s2">++i) {</span>
    <span class="s3">const </span><span class="s2">item = cst.items[i]</span><span class="s1">;</span>

    <span class="s3">switch </span><span class="s2">(item.type) {</span>
      <span class="s3">case </span><span class="s2">PlainValue.Type.BLANK_LINE:</span>
        <span class="s2">comments.push({</span>
          <span class="s2">afterKey: !!key</span><span class="s1">,</span>
          <span class="s2">before: items.length</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Type.COMMENT:</span>
        <span class="s2">comments.push({</span>
          <span class="s2">afterKey: !!key</span><span class="s1">,</span>
          <span class="s2">before: items.length</span><span class="s1">,</span>
          <span class="s2">comment: item.comment</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Type.MAP_KEY:</span>
        <span class="s3">if </span><span class="s2">(key !== undefined) items.push(</span><span class="s3">new </span><span class="s2">Pair(key))</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(item.error) doc.errors.push(item.error)</span><span class="s1">;</span>
        <span class="s2">key = resolveNode(doc</span><span class="s1">, </span><span class="s2">item.node)</span><span class="s1">;</span>
        <span class="s2">keyStart = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Type.MAP_VALUE:</span>
        <span class="s2">{</span>
          <span class="s3">if </span><span class="s2">(key === undefined) key = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s3">if </span><span class="s2">(item.error) doc.errors.push(item.error)</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s2">(!item.context.atLineStart &amp;&amp; item.node &amp;&amp; item.node.type === PlainValue.Type.MAP &amp;&amp; !item.node.context.atLineStart) {</span>
            <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Nested mappings are not allowed in compact mappings'</span><span class="s1">;</span>
            <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(item.node</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
          <span class="s2">}</span>

          <span class="s3">let </span><span class="s2">valueNode = item.node</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s2">(!valueNode &amp;&amp; item.props.length &gt; </span><span class="s4">0</span><span class="s2">) {</span>
            <span class="s5">// Comments on an empty mapping value need to be preserved, so we</span>
            <span class="s5">// need to construct a minimal empty node here to use instead of the</span>
            <span class="s5">// missing `item.node`. -- eemeli/yaml#19</span>
            <span class="s2">valueNode = </span><span class="s3">new </span><span class="s2">PlainValue.PlainValue(PlainValue.Type.PLAIN</span><span class="s1">, </span><span class="s2">[])</span><span class="s1">;</span>
            <span class="s2">valueNode.context = {</span>
              <span class="s2">parent: item</span><span class="s1">,</span>
              <span class="s2">src: item.context.src</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s3">const </span><span class="s2">pos = item.range.start + </span><span class="s4">1</span><span class="s1">;</span>
            <span class="s2">valueNode.range = {</span>
              <span class="s2">start: pos</span><span class="s1">,</span>
              <span class="s2">end: pos</span>
            <span class="s2">}</span><span class="s1">;</span>
            <span class="s2">valueNode.valueRange = {</span>
              <span class="s2">start: pos</span><span class="s1">,</span>
              <span class="s2">end: pos</span>
            <span class="s2">}</span><span class="s1">;</span>

            <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">item.range.origStart === </span><span class="s0">'number'</span><span class="s2">) {</span>
              <span class="s3">const </span><span class="s2">origPos = item.range.origStart + </span><span class="s4">1</span><span class="s1">;</span>
              <span class="s2">valueNode.range.origStart = valueNode.range.origEnd = origPos</span><span class="s1">;</span>
              <span class="s2">valueNode.valueRange.origStart = valueNode.valueRange.origEnd = origPos</span><span class="s1">;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>

          <span class="s3">const </span><span class="s2">pair = </span><span class="s3">new </span><span class="s2">Pair(key</span><span class="s1">, </span><span class="s2">resolveNode(doc</span><span class="s1">, </span><span class="s2">valueNode))</span><span class="s1">;</span>
          <span class="s2">resolvePairComment(item</span><span class="s1">, </span><span class="s2">pair)</span><span class="s1">;</span>
          <span class="s2">items.push(pair)</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s2">(key &amp;&amp; </span><span class="s3">typeof </span><span class="s2">keyStart === </span><span class="s0">'number'</span><span class="s2">) {</span>
            <span class="s3">if </span><span class="s2">(item.range.start &gt; keyStart + </span><span class="s4">1024</span><span class="s2">) doc.errors.push(getLongKeyError(cst</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
          <span class="s2">}</span>

          <span class="s2">key = undefined</span><span class="s1">;</span>
          <span class="s2">keyStart = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s2">}</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s2">:</span>
        <span class="s3">if </span><span class="s2">(key !== undefined) items.push(</span><span class="s3">new </span><span class="s2">Pair(key))</span><span class="s1">;</span>
        <span class="s2">key = resolveNode(doc</span><span class="s1">, </span><span class="s2">item)</span><span class="s1">;</span>
        <span class="s2">keyStart = item.range.start</span><span class="s1">;</span>
        <span class="s3">if </span><span class="s2">(item.error) doc.errors.push(item.error)</span><span class="s1">;</span>

        <span class="s2">next: </span><span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">j = i + </span><span class="s4">1</span><span class="s1">;; </span><span class="s2">++j) {</span>
          <span class="s3">const </span><span class="s2">nextItem = cst.items[j]</span><span class="s1">;</span>

          <span class="s3">switch </span><span class="s2">(nextItem &amp;&amp; nextItem.type) {</span>
            <span class="s3">case </span><span class="s2">PlainValue.Type.BLANK_LINE:</span>
            <span class="s3">case </span><span class="s2">PlainValue.Type.COMMENT:</span>
              <span class="s3">continue </span><span class="s2">next</span><span class="s1">;</span>

            <span class="s3">case </span><span class="s2">PlainValue.Type.MAP_VALUE:</span>
              <span class="s3">break </span><span class="s2">next</span><span class="s1">;</span>

            <span class="s3">default</span><span class="s2">:</span>
              <span class="s2">{</span>
                <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Implicit map keys need to be followed by map values'</span><span class="s1">;</span>
                <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(item</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
                <span class="s3">break </span><span class="s2">next</span><span class="s1">;</span>
              <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">}</span>

        <span class="s3">if </span><span class="s2">(item.valueRangeContainsNewline) {</span>
          <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Implicit map keys need to be on a single line'</span><span class="s1">;</span>
          <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(item</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
        <span class="s2">}</span>

    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">if </span><span class="s2">(key !== undefined) items.push(</span><span class="s3">new </span><span class="s2">Pair(key))</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">{</span>
    <span class="s2">comments</span><span class="s1">,</span>
    <span class="s2">items</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveFlowMapItems(doc</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">const </span><span class="s2">comments = []</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">items = []</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">key = undefined</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">explicitKey = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">next = </span><span class="s0">'{'</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; cst.items.length</span><span class="s1">; </span><span class="s2">++i) {</span>
    <span class="s3">const </span><span class="s2">item = cst.items[i]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">item.char === </span><span class="s0">'string'</span><span class="s2">) {</span>
      <span class="s3">const </span><span class="s2">{</span>
        <span class="s2">char</span><span class="s1">,</span>
        <span class="s2">offset</span>
      <span class="s2">} = item</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(char === </span><span class="s0">'?' </span><span class="s2">&amp;&amp; key === undefined &amp;&amp; !explicitKey) {</span>
        <span class="s2">explicitKey = </span><span class="s3">true</span><span class="s1">;</span>
        <span class="s2">next = </span><span class="s0">':'</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(char === </span><span class="s0">':'</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(key === undefined) key = </span><span class="s3">null</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s2">(next === </span><span class="s0">':'</span><span class="s2">) {</span>
          <span class="s2">next = </span><span class="s0">','</span><span class="s1">;</span>
          <span class="s3">continue</span><span class="s1">;</span>
        <span class="s2">}</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s3">if </span><span class="s2">(explicitKey) {</span>
          <span class="s3">if </span><span class="s2">(key === undefined &amp;&amp; char !== </span><span class="s0">','</span><span class="s2">) key = </span><span class="s3">null</span><span class="s1">;</span>
          <span class="s2">explicitKey = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s3">if </span><span class="s2">(key !== undefined) {</span>
          <span class="s2">items.push(</span><span class="s3">new </span><span class="s2">Pair(key))</span><span class="s1">;</span>
          <span class="s2">key = undefined</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s2">(char === </span><span class="s0">','</span><span class="s2">) {</span>
            <span class="s2">next = </span><span class="s0">':'</span><span class="s1">;</span>
            <span class="s3">continue</span><span class="s1">;</span>
          <span class="s2">}</span>
        <span class="s2">}</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(char === </span><span class="s0">'}'</span><span class="s2">) {</span>
        <span class="s3">if </span><span class="s2">(i === cst.items.length - </span><span class="s4">1</span><span class="s2">) </span><span class="s3">continue</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(char === next) {</span>
        <span class="s2">next = </span><span class="s0">':'</span><span class="s1">;</span>
        <span class="s3">continue</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Flow map contains an unexpected </span><span class="s2">${char}</span><span class="s0">`</span><span class="s1">;</span>
      <span class="s3">const </span><span class="s2">err = </span><span class="s3">new </span><span class="s2">PlainValue.YAMLSyntaxError(cst</span><span class="s1">, </span><span class="s2">msg)</span><span class="s1">;</span>
      <span class="s2">err.offset = offset</span><span class="s1">;</span>
      <span class="s2">doc.errors.push(err)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(item.type === PlainValue.Type.BLANK_LINE) {</span>
      <span class="s2">comments.push({</span>
        <span class="s2">afterKey: !!key</span><span class="s1">,</span>
        <span class="s2">before: items.length</span>
      <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(item.type === PlainValue.Type.COMMENT) {</span>
      <span class="s2">checkFlowCommentSpace(doc.errors</span><span class="s1">, </span><span class="s2">item)</span><span class="s1">;</span>
      <span class="s2">comments.push({</span>
        <span class="s2">afterKey: !!key</span><span class="s1">,</span>
        <span class="s2">before: items.length</span><span class="s1">,</span>
        <span class="s2">comment: item.comment</span>
      <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(key === undefined) {</span>
      <span class="s3">if </span><span class="s2">(next === </span><span class="s0">','</span><span class="s2">) doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(item</span><span class="s1">, </span><span class="s0">'Separator , missing in flow map'</span><span class="s2">))</span><span class="s1">;</span>
      <span class="s2">key = resolveNode(doc</span><span class="s1">, </span><span class="s2">item)</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">if </span><span class="s2">(next !== </span><span class="s0">','</span><span class="s2">) doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(item</span><span class="s1">, </span><span class="s0">'Indicator : missing in flow map entry'</span><span class="s2">))</span><span class="s1">;</span>
      <span class="s2">items.push(</span><span class="s3">new </span><span class="s2">Pair(key</span><span class="s1">, </span><span class="s2">resolveNode(doc</span><span class="s1">, </span><span class="s2">item)))</span><span class="s1">;</span>
      <span class="s2">key = undefined</span><span class="s1">;</span>
      <span class="s2">explicitKey = </span><span class="s3">false</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s2">checkFlowCollectionEnd(doc.errors</span><span class="s1">, </span><span class="s2">cst)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(key !== undefined) items.push(</span><span class="s3">new </span><span class="s2">Pair(key))</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">{</span>
    <span class="s2">comments</span><span class="s1">,</span>
    <span class="s2">items</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveSeq(doc</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">if </span><span class="s2">(cst.type !== PlainValue.Type.SEQ &amp;&amp; cst.type !== PlainValue.Type.FLOW_SEQ) {</span>
    <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`A </span><span class="s2">${cst.type} </span><span class="s0">node cannot be resolved as a sequence`</span><span class="s1">;</span>
    <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSyntaxError(cst</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
    <span class="s3">return null</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s3">const </span><span class="s2">{</span>
    <span class="s2">comments</span><span class="s1">,</span>
    <span class="s2">items</span>
  <span class="s2">} = cst.type === PlainValue.Type.FLOW_SEQ ? resolveFlowSeqItems(doc</span><span class="s1">, </span><span class="s2">cst) : resolveBlockSeqItems(doc</span><span class="s1">, </span><span class="s2">cst)</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">seq = </span><span class="s3">new </span><span class="s2">YAMLSeq()</span><span class="s1">;</span>
  <span class="s2">seq.items = items</span><span class="s1">;</span>
  <span class="s2">resolveComments(seq</span><span class="s1">, </span><span class="s2">comments)</span><span class="s1">;</span>

  <span class="s3">if </span><span class="s2">(!doc.options.mapAsMap &amp;&amp; items.some(it =&gt; it </span><span class="s3">instanceof </span><span class="s2">Pair &amp;&amp; it.key </span><span class="s3">instanceof </span><span class="s2">Collection)) {</span>
    <span class="s3">const </span><span class="s2">warn = </span><span class="s0">'Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this.'</span><span class="s1">;</span>
    <span class="s2">doc.warnings.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLWarning(cst</span><span class="s1">, </span><span class="s2">warn))</span><span class="s1">;</span>
  <span class="s2">}</span>

  <span class="s2">cst.resolved = seq</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">seq</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveBlockSeqItems(doc</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">const </span><span class="s2">comments = []</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">items = []</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; cst.items.length</span><span class="s1">; </span><span class="s2">++i) {</span>
    <span class="s3">const </span><span class="s2">item = cst.items[i]</span><span class="s1">;</span>

    <span class="s3">switch </span><span class="s2">(item.type) {</span>
      <span class="s3">case </span><span class="s2">PlainValue.Type.BLANK_LINE:</span>
        <span class="s2">comments.push({</span>
          <span class="s2">before: items.length</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Type.COMMENT:</span>
        <span class="s2">comments.push({</span>
          <span class="s2">comment: item.comment</span><span class="s1">,</span>
          <span class="s2">before: items.length</span>
        <span class="s2">})</span><span class="s1">;</span>
        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">case </span><span class="s2">PlainValue.Type.SEQ_ITEM:</span>
        <span class="s3">if </span><span class="s2">(item.error) doc.errors.push(item.error)</span><span class="s1">;</span>
        <span class="s2">items.push(resolveNode(doc</span><span class="s1">, </span><span class="s2">item.node))</span><span class="s1">;</span>

        <span class="s3">if </span><span class="s2">(item.hasProps) {</span>
          <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Sequence items cannot have tags or anchors before the - indicator'</span><span class="s1">;</span>
          <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(item</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s3">break</span><span class="s1">;</span>

      <span class="s3">default</span><span class="s2">:</span>
        <span class="s3">if </span><span class="s2">(item.error) doc.errors.push(item.error)</span><span class="s1">;</span>
        <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSyntaxError(item</span><span class="s1">, </span><span class="s0">`Unexpected </span><span class="s2">${item.type} </span><span class="s0">node in sequence`</span><span class="s2">))</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s3">return </span><span class="s2">{</span>
    <span class="s2">comments</span><span class="s1">,</span>
    <span class="s2">items</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s3">function </span><span class="s2">resolveFlowSeqItems(doc</span><span class="s1">, </span><span class="s2">cst) {</span>
  <span class="s3">const </span><span class="s2">comments = []</span><span class="s1">;</span>
  <span class="s3">const </span><span class="s2">items = []</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">explicitKey = </span><span class="s3">false</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">key = undefined</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">keyStart = </span><span class="s3">null</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">next = </span><span class="s0">'['</span><span class="s1">;</span>
  <span class="s3">let </span><span class="s2">prevItem = </span><span class="s3">null</span><span class="s1">;</span>

  <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = </span><span class="s4">0</span><span class="s1">; </span><span class="s2">i &lt; cst.items.length</span><span class="s1">; </span><span class="s2">++i) {</span>
    <span class="s3">const </span><span class="s2">item = cst.items[i]</span><span class="s1">;</span>

    <span class="s3">if </span><span class="s2">(</span><span class="s3">typeof </span><span class="s2">item.char === </span><span class="s0">'string'</span><span class="s2">) {</span>
      <span class="s3">const </span><span class="s2">{</span>
        <span class="s2">char</span><span class="s1">,</span>
        <span class="s2">offset</span>
      <span class="s2">} = item</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(char !== </span><span class="s0">':' </span><span class="s2">&amp;&amp; (explicitKey || key !== undefined)) {</span>
        <span class="s3">if </span><span class="s2">(explicitKey &amp;&amp; key === undefined) key = next ? items.pop() : </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s2">items.push(</span><span class="s3">new </span><span class="s2">Pair(key))</span><span class="s1">;</span>
        <span class="s2">explicitKey = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s2">key = undefined</span><span class="s1">;</span>
        <span class="s2">keyStart = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s3">if </span><span class="s2">(char === next) {</span>
        <span class="s2">next = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(!next &amp;&amp; char === </span><span class="s0">'?'</span><span class="s2">) {</span>
        <span class="s2">explicitKey = </span><span class="s3">true</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(next !== </span><span class="s0">'[' </span><span class="s2">&amp;&amp; char === </span><span class="s0">':' </span><span class="s2">&amp;&amp; key === undefined) {</span>
        <span class="s3">if </span><span class="s2">(next === </span><span class="s0">','</span><span class="s2">) {</span>
          <span class="s2">key = items.pop()</span><span class="s1">;</span>

          <span class="s3">if </span><span class="s2">(key </span><span class="s3">instanceof </span><span class="s2">Pair) {</span>
            <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Chaining flow sequence pairs is invalid'</span><span class="s1">;</span>
            <span class="s3">const </span><span class="s2">err = </span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(cst</span><span class="s1">, </span><span class="s2">msg)</span><span class="s1">;</span>
            <span class="s2">err.offset = offset</span><span class="s1">;</span>
            <span class="s2">doc.errors.push(err)</span><span class="s1">;</span>
          <span class="s2">}</span>

          <span class="s3">if </span><span class="s2">(!explicitKey &amp;&amp; </span><span class="s3">typeof </span><span class="s2">keyStart === </span><span class="s0">'number'</span><span class="s2">) {</span>
            <span class="s3">const </span><span class="s2">keyEnd = item.range ? item.range.start : item.offset</span><span class="s1">;</span>
            <span class="s3">if </span><span class="s2">(keyEnd &gt; keyStart + </span><span class="s4">1024</span><span class="s2">) doc.errors.push(getLongKeyError(cst</span><span class="s1">, </span><span class="s2">key))</span><span class="s1">;</span>
            <span class="s3">const </span><span class="s2">{</span>
              <span class="s2">src</span>
            <span class="s2">} = prevItem.context</span><span class="s1">;</span>

            <span class="s3">for </span><span class="s2">(</span><span class="s3">let </span><span class="s2">i = keyStart</span><span class="s1">; </span><span class="s2">i &lt; keyEnd</span><span class="s1">; </span><span class="s2">++i) </span><span class="s3">if </span><span class="s2">(src[i] === </span><span class="s0">'</span><span class="s1">\n</span><span class="s0">'</span><span class="s2">) {</span>
              <span class="s3">const </span><span class="s2">msg = </span><span class="s0">'Implicit keys of flow sequence pairs need to be on a single line'</span><span class="s1">;</span>
              <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(prevItem</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
              <span class="s3">break</span><span class="s1">;</span>
            <span class="s2">}</span>
          <span class="s2">}</span>
        <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
          <span class="s2">key = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s2">}</span>

        <span class="s2">keyStart = </span><span class="s3">null</span><span class="s1">;</span>
        <span class="s2">explicitKey = </span><span class="s3">false</span><span class="s1">;</span>
        <span class="s2">next = </span><span class="s3">null</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else if </span><span class="s2">(next === </span><span class="s0">'[' </span><span class="s2">|| char !== </span><span class="s0">']' </span><span class="s2">|| i &lt; cst.items.length - </span><span class="s4">1</span><span class="s2">) {</span>
        <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Flow sequence contains an unexpected </span><span class="s2">${char}</span><span class="s0">`</span><span class="s1">;</span>
        <span class="s3">const </span><span class="s2">err = </span><span class="s3">new </span><span class="s2">PlainValue.YAMLSyntaxError(cst</span><span class="s1">, </span><span class="s2">msg)</span><span class="s1">;</span>
        <span class="s2">err.offset = offset</span><span class="s1">;</span>
        <span class="s2">doc.errors.push(err)</span><span class="s1">;</span>
      <span class="s2">}</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(item.type === PlainValue.Type.BLANK_LINE) {</span>
      <span class="s2">comments.push({</span>
        <span class="s2">before: items.length</span>
      <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else if </span><span class="s2">(item.type === PlainValue.Type.COMMENT) {</span>
      <span class="s2">checkFlowCommentSpace(doc.errors</span><span class="s1">, </span><span class="s2">item)</span><span class="s1">;</span>
      <span class="s2">comments.push({</span>
        <span class="s2">comment: item.comment</span><span class="s1">,</span>
        <span class="s2">before: items.length</span>
      <span class="s2">})</span><span class="s1">;</span>
    <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
      <span class="s3">if </span><span class="s2">(next) {</span>
        <span class="s3">const </span><span class="s2">msg = </span><span class="s0">`Expected a </span><span class="s2">${next} </span><span class="s0">in flow sequence`</span><span class="s1">;</span>
        <span class="s2">doc.errors.push(</span><span class="s3">new </span><span class="s2">PlainValue.YAMLSemanticError(item</span><span class="s1">, </span><span class="s2">msg))</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s3">const </span><span class="s2">value = resolveNode(doc</span><span class="s1">, </span><span class="s2">item)</span><span class="s1">;</span>

      <span class="s3">if </span><span class="s2">(key === undefined) {</span>
        <span class="s2">items.push(value)</span><span class="s1">;</span>
        <span class="s2">prevItem = item</span><span class="s1">;</span>
      <span class="s2">} </span><span class="s3">else </span><span class="s2">{</span>
        <span class="s2">items.push(</span><span class="s3">new </span><span class="s2">Pair(key</span><span class="s1">, </span><span class="s2">value))</span><span class="s1">;</span>
        <span class="s2">key = undefined</span><span class="s1">;</span>
      <span class="s2">}</span>

      <span class="s2">keyStart = item.range.start</span><span class="s1">;</span>
      <span class="s2">next = </span><span class="s0">','</span><span class="s1">;</span>
    <span class="s2">}</span>
  <span class="s2">}</span>

  <span class="s2">checkFlowCollectionEnd(doc.errors</span><span class="s1">, </span><span class="s2">cst)</span><span class="s1">;</span>
  <span class="s3">if </span><span class="s2">(key !== undefined) items.push(</span><span class="s3">new </span><span class="s2">Pair(key))</span><span class="s1">;</span>
  <span class="s3">return </span><span class="s2">{</span>
    <span class="s2">comments</span><span class="s1">,</span>
    <span class="s2">items</span>
  <span class="s2">}</span><span class="s1">;</span>
<span class="s2">}</span>

<span class="s2">exports.Alias = Alias</span><span class="s1">;</span>
<span class="s2">exports.Collection = Collection</span><span class="s1">;</span>
<span class="s2">exports.Merge = Merge</span><span class="s1">;</span>
<span class="s2">exports.Node = Node</span><span class="s1">;</span>
<span class="s2">exports.Pair = Pair</span><span class="s1">;</span>
<span class="s2">exports.Scalar = Scalar</span><span class="s1">;</span>
<span class="s2">exports.YAMLMap = YAMLMap</span><span class="s1">;</span>
<span class="s2">exports.YAMLSeq = YAMLSeq</span><span class="s1">;</span>
<span class="s2">exports.addComment = addComment</span><span class="s1">;</span>
<span class="s2">exports.binaryOptions = binaryOptions</span><span class="s1">;</span>
<span class="s2">exports.boolOptions = boolOptions</span><span class="s1">;</span>
<span class="s2">exports.findPair = findPair</span><span class="s1">;</span>
<span class="s2">exports.intOptions = intOptions</span><span class="s1">;</span>
<span class="s2">exports.isEmptyPath = isEmptyPath</span><span class="s1">;</span>
<span class="s2">exports.nullOptions = nullOptions</span><span class="s1">;</span>
<span class="s2">exports.resolveMap = resolveMap</span><span class="s1">;</span>
<span class="s2">exports.resolveNode = resolveNode</span><span class="s1">;</span>
<span class="s2">exports.resolveSeq = resolveSeq</span><span class="s1">;</span>
<span class="s2">exports.resolveString = resolveString</span><span class="s1">;</span>
<span class="s2">exports.strOptions = strOptions</span><span class="s1">;</span>
<span class="s2">exports.stringifyNumber = stringifyNumber</span><span class="s1">;</span>
<span class="s2">exports.stringifyString = stringifyString</span><span class="s1">;</span>
<span class="s2">exports.toJSON = toJSON</span><span class="s1">;</span>
</pre>
</body>
</html>