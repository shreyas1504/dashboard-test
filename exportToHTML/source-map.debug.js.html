<html>
<head>
<title>source-map.debug.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cfd2d5;}
.s1 { color: #cc7832; font-weight: bold;}
.s2 { color: #cc7832;}
.s3 { color: #8ea765;}
.s4 { color: #8a8a8a;}
.s5 { color: #808080;}
.s6 { color: #6897bb;}
.s7 { color: #8a8a8a; font-style: italic;}
.s8 { color: #8a8a8a; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#1c1c1c">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-map.debug.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">webpackUniversalModuleDefinition(root</span><span class="s2">, </span><span class="s0">factory) {</span>
	<span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s3">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module === </span><span class="s3">'object'</span><span class="s0">)</span>
		<span class="s0">module.exports = factory()</span><span class="s2">;</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define === </span><span class="s3">'function' </span><span class="s0">&amp;&amp; define.amd)</span>
		<span class="s0">define([]</span><span class="s2">, </span><span class="s0">factory)</span><span class="s2">;</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s3">'object'</span><span class="s0">)</span>
		<span class="s0">exports[</span><span class="s3">&quot;sourceMap&quot;</span><span class="s0">] = factory()</span><span class="s2">;</span>
	<span class="s1">else</span>
		<span class="s0">root[</span><span class="s3">&quot;sourceMap&quot;</span><span class="s0">] = factory()</span><span class="s2">;</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s2">, </span><span class="s1">function</span><span class="s0">() {</span>
<span class="s1">return </span><span class="s4">/******/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(modules) { </span><span class="s5">// webpackBootstrap</span>
<span class="s4">/******/ 	</span><span class="s5">// The module cache</span>
<span class="s4">/******/ 	</span><span class="s1">var </span><span class="s0">installedModules = {}</span><span class="s2">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	</span><span class="s5">// The require function</span>
<span class="s4">/******/ 	</span><span class="s1">function </span><span class="s0">__webpack_require__(moduleId) {</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		</span><span class="s5">// Check if module is in cache</span>
<span class="s4">/******/ 		</span><span class="s1">if</span><span class="s0">(installedModules[moduleId])</span>
<span class="s4">/******/ 			</span><span class="s1">return </span><span class="s0">installedModules[moduleId].exports</span><span class="s2">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		</span><span class="s5">// Create a new module (and put it into the cache)</span>
<span class="s4">/******/ 		</span><span class="s1">var </span><span class="s0">module = installedModules[moduleId] = {</span>
<span class="s4">/******/ 			</span><span class="s0">exports: {}</span><span class="s2">,</span>
<span class="s4">/******/ 			</span><span class="s0">id: moduleId</span><span class="s2">,</span>
<span class="s4">/******/ 			</span><span class="s0">loaded: </span><span class="s1">false</span>
<span class="s4">/******/ 		</span><span class="s0">}</span><span class="s2">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		</span><span class="s5">// Execute the module function</span>
<span class="s4">/******/ 		</span><span class="s0">modules[moduleId].call(module.exports</span><span class="s2">, </span><span class="s0">module</span><span class="s2">, </span><span class="s0">module.exports</span><span class="s2">, </span><span class="s0">__webpack_require__)</span><span class="s2">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		</span><span class="s5">// Flag the module as loaded</span>
<span class="s4">/******/ 		</span><span class="s0">module.loaded = </span><span class="s1">true</span><span class="s2">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 		</span><span class="s5">// Return the exports of the module</span>
<span class="s4">/******/ 		</span><span class="s1">return </span><span class="s0">module.exports</span><span class="s2">;</span>
<span class="s4">/******/ 	</span><span class="s0">}</span>
<span class="s4">/******/</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	</span><span class="s5">// expose the modules object (__webpack_modules__)</span>
<span class="s4">/******/ 	</span><span class="s0">__webpack_require__.m = modules</span><span class="s2">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	</span><span class="s5">// expose the module cache</span>
<span class="s4">/******/ 	</span><span class="s0">__webpack_require__.c = installedModules</span><span class="s2">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	</span><span class="s5">// __webpack_public_path__</span>
<span class="s4">/******/ 	</span><span class="s0">__webpack_require__.p = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
<span class="s4">/******/</span>
<span class="s4">/******/ 	</span><span class="s5">// Load entry module and return exports</span>
<span class="s4">/******/ 	</span><span class="s1">return </span><span class="s0">__webpack_require__(</span><span class="s6">0</span><span class="s0">)</span><span class="s2">;</span>
<span class="s4">/******/ </span><span class="s0">})</span>
<span class="s4">/************************************************************************/</span>
<span class="s4">/******/ </span><span class="s0">([</span>
<span class="s4">/* 0 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* 
     * Copyright 2009-2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE.txt or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	<span class="s0">exports.SourceMapGenerator = __webpack_require__(</span><span class="s6">1</span><span class="s0">).SourceMapGenerator</span><span class="s2">;</span>
	<span class="s0">exports.SourceMapConsumer = __webpack_require__(</span><span class="s6">7</span><span class="s0">).SourceMapConsumer</span><span class="s2">;</span>
	<span class="s0">exports.SourceNode = __webpack_require__(</span><span class="s6">10</span><span class="s0">).SourceNode</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 1 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">base64VLQ = __webpack_require__(</span><span class="s6">2</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">ArraySet = __webpack_require__(</span><span class="s6">5</span><span class="s0">).ArraySet</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">MappingList = __webpack_require__(</span><span class="s6">6</span><span class="s0">).MappingList</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* An instance of the SourceMapGenerator represents a source map which is</span>
	 <span class="s7">* being built incrementally. You may pass an object with the following</span>
	 <span class="s7">* properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - file: The filename of the generated source.</span>
	 <span class="s7">*   - sourceRoot: A root for all relative URLs in this source map.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">SourceMapGenerator(aArgs) {</span>
	  <span class="s1">if </span><span class="s0">(!aArgs) {</span>
	    <span class="s0">aArgs = {}</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">this</span><span class="s0">._file = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'file'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sourceRoot = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'sourceRoot'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._skipValidation = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'skipValidation'</span><span class="s2">, </span><span class="s1">false</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sources = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._names = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._mappings = </span><span class="s1">new </span><span class="s0">MappingList()</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sourcesContents = </span><span class="s1">null</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s0">SourceMapGenerator.prototype._version = </span><span class="s6">3</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Creates a new SourceMapGenerator based on a SourceMapConsumer</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceMapConsumer The SourceMap.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.fromSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {</span>
	    <span class="s1">var </span><span class="s0">sourceRoot = aSourceMapConsumer.sourceRoot</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">generator = </span><span class="s1">new </span><span class="s0">SourceMapGenerator({</span>
	      <span class="s0">file: aSourceMapConsumer.file</span><span class="s2">,</span>
	      <span class="s0">sourceRoot: sourceRoot</span>
	    <span class="s0">})</span><span class="s2">;</span>
	    <span class="s0">aSourceMapConsumer.eachMapping(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">var </span><span class="s0">newMapping = {</span>
	        <span class="s0">generated: {</span>
	          <span class="s0">line: mapping.generatedLine</span><span class="s2">,</span>
	          <span class="s0">column: mapping.generatedColumn</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span><span class="s2">;</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.source != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">newMapping.source = mapping.source</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">newMapping.source = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">newMapping.source)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	
	        <span class="s0">newMapping.original = {</span>
	          <span class="s0">line: mapping.originalLine</span><span class="s2">,</span>
	          <span class="s0">column: mapping.originalColumn</span>
	        <span class="s0">}</span><span class="s2">;</span>
	
	        <span class="s1">if </span><span class="s0">(mapping.name != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">newMapping.name = mapping.name</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s0">generator.addMapping(newMapping)</span><span class="s2">;</span>
	    <span class="s0">})</span><span class="s2">;</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">sourceRelative = sourceFile</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(sourceRoot !== </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">sourceRelative = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	
	      <span class="s1">if </span><span class="s0">(!generator._sources.has(sourceRelative)) {</span>
	        <span class="s0">generator._sources.add(sourceRelative)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	
	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">generator.setSourceContent(sourceFile</span><span class="s2">, </span><span class="s0">content)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">})</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">generator</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Add a single mapping from original source line and column to the generated</span>
	 <span class="s7">* source's line and column for this source map being created. The mapping</span>
	 <span class="s7">* object should have the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - generated: An object with the generated line and column positions.</span>
	 <span class="s7">*   - original: An object with the original line and column positions.</span>
	 <span class="s7">*   - source: The original source file (relative to the sourceRoot).</span>
	 <span class="s7">*   - name: An optional original token name for this mapping.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.addMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_addMapping(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">generated = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'generated'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">original = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'original'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">source = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'source'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">name = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'name'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._skipValidation) {</span>
	      <span class="s1">this</span><span class="s0">._validateMapping(generated</span><span class="s2">, </span><span class="s0">original</span><span class="s2">, </span><span class="s0">source</span><span class="s2">, </span><span class="s0">name)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(source != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">source = String(source)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sources.has(source)) {</span>
	        <span class="s1">this</span><span class="s0">._sources.add(source)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(name != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">name = String(name)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._names.has(name)) {</span>
	        <span class="s1">this</span><span class="s0">._names.add(name)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">this</span><span class="s0">._mappings.add({</span>
	      <span class="s0">generatedLine: generated.line</span><span class="s2">,</span>
	      <span class="s0">generatedColumn: generated.column</span><span class="s2">,</span>
	      <span class="s0">originalLine: original != </span><span class="s1">null </span><span class="s0">&amp;&amp; original.line</span><span class="s2">,</span>
	      <span class="s0">originalColumn: original != </span><span class="s1">null </span><span class="s0">&amp;&amp; original.column</span><span class="s2">,</span>
	      <span class="s0">source: source</span><span class="s2">,</span>
	      <span class="s0">name: name</span>
	    <span class="s0">})</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Set the source content for a source file.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.setSourceContent =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_setSourceContent(aSourceFile</span><span class="s2">, </span><span class="s0">aSourceContent) {</span>
	    <span class="s1">var </span><span class="s0">source = aSourceFile</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">source = util.relative(</span><span class="s1">this</span><span class="s0">._sourceRoot</span><span class="s2">, </span><span class="s0">source)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(aSourceContent != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s5">// Add the source content to the _sourcesContents map.</span>
	      <span class="s5">// Create a new _sourcesContents map if the property is null.</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	        <span class="s1">this</span><span class="s0">._sourcesContents = Object.create(</span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">this</span><span class="s0">._sourcesContents[util.toSetString(source)] = aSourceContent</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	      <span class="s5">// Remove the source file from the _sourcesContents map.</span>
	      <span class="s5">// If the _sourcesContents map is empty, set the property to null.</span>
	      <span class="s1">delete this</span><span class="s0">._sourcesContents[util.toSetString(source)]</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(Object.keys(</span><span class="s1">this</span><span class="s0">._sourcesContents).length === </span><span class="s6">0</span><span class="s0">) {</span>
	        <span class="s1">this</span><span class="s0">._sourcesContents = </span><span class="s1">null</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Applies the mappings of a sub-source-map for a specific source file to the</span>
	 <span class="s7">* source map being generated. Each mapping to the supplied source file is</span>
	 <span class="s7">* rewritten using the supplied source map. Note: The resolution for the</span>
	 <span class="s7">* resulting mappings is the minimium of this map and the supplied map.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceMapConsumer The source map to be applied.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceFile Optional. The filename of the source file.</span>
	 <span class="s7">*        If omitted, SourceMapConsumer's file property will be used.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceMapPath Optional. The dirname of the path to the source map</span>
	 <span class="s7">*        to be applied. If relative, it is relative to the SourceMapConsumer.</span>
	 <span class="s7">*        This parameter is needed when the two source maps aren't in the same</span>
	 <span class="s7">*        directory, and the source map to be applied contains relative source</span>
	 <span class="s7">*        paths. If so, those relative source paths need to be rewritten</span>
	 <span class="s7">*        relative to the SourceMapGenerator.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.applySourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_applySourceMap(aSourceMapConsumer</span><span class="s2">, </span><span class="s0">aSourceFile</span><span class="s2">, </span><span class="s0">aSourceMapPath) {</span>
	    <span class="s1">var </span><span class="s0">sourceFile = aSourceFile</span><span class="s2">;</span>
	    <span class="s5">// If aSourceFile is omitted, we will use the file property of the SourceMap</span>
	    <span class="s1">if </span><span class="s0">(aSourceFile == </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(aSourceMapConsumer.file == </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">throw new </span><span class="s0">Error(</span>
	          <span class="s3">'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' </span><span class="s0">+</span>
	          <span class="s3">'or the source map</span><span class="s2">\'</span><span class="s3">s &quot;file&quot; property. Both were omitted.'</span>
	        <span class="s0">)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s0">sourceFile = aSourceMapConsumer.file</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">var </span><span class="s0">sourceRoot = </span><span class="s1">this</span><span class="s0">._sourceRoot</span><span class="s2">;</span>
	    <span class="s5">// Make &quot;sourceFile&quot; relative if an absolute Url is passed.</span>
	    <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">sourceFile = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s5">// Applying the SourceMap can add and remove items from the sources and</span>
	    <span class="s5">// the names array.</span>
	    <span class="s1">var </span><span class="s0">newSources = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">newNames = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	
	    <span class="s5">// Find mappings for the &quot;sourceFile&quot;</span>
	    <span class="s1">this</span><span class="s0">._mappings.unsortedForEach(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">if </span><span class="s0">(mapping.source === sourceFile &amp;&amp; mapping.originalLine != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s5">// Check if it can be mapped by the source map, then update the mapping.</span>
	        <span class="s1">var </span><span class="s0">original = aSourceMapConsumer.originalPositionFor({</span>
	          <span class="s0">line: mapping.originalLine</span><span class="s2">,</span>
	          <span class="s0">column: mapping.originalColumn</span>
	        <span class="s0">})</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(original.source != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s5">// Copy mapping</span>
	          <span class="s0">mapping.source = original.source</span><span class="s2">;</span>
	          <span class="s1">if </span><span class="s0">(aSourceMapPath != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.source = util.join(aSourceMapPath</span><span class="s2">, </span><span class="s0">mapping.source)</span>
	          <span class="s0">}</span>
	          <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.source = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">mapping.source)</span><span class="s2">;</span>
	          <span class="s0">}</span>
	          <span class="s0">mapping.originalLine = original.line</span><span class="s2">;</span>
	          <span class="s0">mapping.originalColumn = original.column</span><span class="s2">;</span>
	          <span class="s1">if </span><span class="s0">(original.name != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.name = original.name</span><span class="s2">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s1">var </span><span class="s0">source = mapping.source</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(source != </span><span class="s1">null </span><span class="s0">&amp;&amp; !newSources.has(source)) {</span>
	        <span class="s0">newSources.add(source)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	
	      <span class="s1">var </span><span class="s0">name = mapping.name</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(name != </span><span class="s1">null </span><span class="s0">&amp;&amp; !newNames.has(name)) {</span>
	        <span class="s0">newNames.add(name)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._sources = newSources</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._names = newNames</span><span class="s2">;</span>
	
	    <span class="s5">// Copy sourcesContents of applied map.</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(aSourceMapPath != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.join(aSourceMapPath</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s1">this</span><span class="s0">.setSourceContent(sourceFile</span><span class="s2">, </span><span class="s0">content)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* A mapping can have one of the three levels of data:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   1. Just the generated position.</span>
	 <span class="s7">*   2. The Generated position, original position, and original source.</span>
	 <span class="s7">*   3. Generated and original position, original source, as well as a name</span>
	 <span class="s7">*      token.</span>
	 <span class="s7">*</span>
	 <span class="s7">* To maintain consistency, we validate that any new mapping being added falls</span>
	 <span class="s7">* in to one of these categories.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype._validateMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_validateMapping(aGenerated</span><span class="s2">, </span><span class="s0">aOriginal</span><span class="s2">, </span><span class="s0">aSource</span><span class="s2">,</span>
	                                              <span class="s0">aName) {</span>
	    <span class="s5">// When aOriginal is truthy but has empty values for .line and .column,</span>
	    <span class="s5">// it is most likely a programmer error. In this case we throw a very</span>
	    <span class="s5">// specific error message to try to guide them the right way.</span>
	    <span class="s5">// For example: https://github.com/Polymer/polymer-bundler/pull/519</span>
	    <span class="s1">if </span><span class="s0">(aOriginal &amp;&amp; </span><span class="s1">typeof </span><span class="s0">aOriginal.line !== </span><span class="s3">'number' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">aOriginal.column !== </span><span class="s3">'number'</span><span class="s0">) {</span>
	        <span class="s1">throw new </span><span class="s0">Error(</span>
	            <span class="s3">'original.line and original.column are not numbers -- you probably meant to omit ' </span><span class="s0">+</span>
	            <span class="s3">'the original mapping entirely and only map the generated position. If so, pass ' </span><span class="s0">+</span>
	            <span class="s3">'null for the original mapping instead of an object with empty or null values.'</span>
	        <span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">if </span><span class="s0">(aGenerated &amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s0">aGenerated &amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s0">aGenerated</span>
	        <span class="s0">&amp;&amp; aGenerated.line &gt; </span><span class="s6">0 </span><span class="s0">&amp;&amp; aGenerated.column &gt;= </span><span class="s6">0</span>
	        <span class="s0">&amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {</span>
	      <span class="s5">// Case 1.</span>
	      <span class="s1">return</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else if </span><span class="s0">(aGenerated &amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s0">aGenerated &amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s0">aGenerated</span>
	             <span class="s0">&amp;&amp; aOriginal &amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s0">aOriginal &amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s0">aOriginal</span>
	             <span class="s0">&amp;&amp; aGenerated.line &gt; </span><span class="s6">0 </span><span class="s0">&amp;&amp; aGenerated.column &gt;= </span><span class="s6">0</span>
	             <span class="s0">&amp;&amp; aOriginal.line &gt; </span><span class="s6">0 </span><span class="s0">&amp;&amp; aOriginal.column &gt;= </span><span class="s6">0</span>
	             <span class="s0">&amp;&amp; aSource) {</span>
	      <span class="s5">// Cases 2 and 3.</span>
	      <span class="s1">return</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Invalid mapping: ' </span><span class="s0">+ JSON.stringify({</span>
	        <span class="s0">generated: aGenerated</span><span class="s2">,</span>
	        <span class="s0">source: aSource</span><span class="s2">,</span>
	        <span class="s0">original: aOriginal</span><span class="s2">,</span>
	        <span class="s0">name: aName</span>
	      <span class="s0">}))</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Serialize the accumulated mappings in to the stream of base 64 VLQs</span>
	 <span class="s7">* specified by the source map format.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype._serializeMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_serializeMappings() {</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedLine = </span><span class="s6">1</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalColumn = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalLine = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousName = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousSource = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">result = </span><span class="s3">''</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">next</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">mapping</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">nameIdx</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">sourceIdx</span><span class="s2">;</span>
	
	    <span class="s1">var </span><span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._mappings.toArray()</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = mappings.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s0">mapping = mappings[i]</span><span class="s2">;</span>
	      <span class="s0">next = </span><span class="s3">''</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.generatedLine !== previousGeneratedLine) {</span>
	        <span class="s0">previousGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	        <span class="s1">while </span><span class="s0">(mapping.generatedLine !== previousGeneratedLine) {</span>
	          <span class="s0">next += </span><span class="s3">';'</span><span class="s2">;</span>
	          <span class="s0">previousGeneratedLine++</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	      <span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	          <span class="s1">if </span><span class="s0">(!util.compareByGeneratedPositionsInflated(mapping</span><span class="s2">, </span><span class="s0">mappings[i - </span><span class="s6">1</span><span class="s0">])) {</span>
	            <span class="s1">continue</span><span class="s2">;</span>
	          <span class="s0">}</span>
	          <span class="s0">next += </span><span class="s3">','</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s0">next += base64VLQ.encode(mapping.generatedColumn</span>
	                                 <span class="s0">- previousGeneratedColumn)</span><span class="s2">;</span>
	      <span class="s0">previousGeneratedColumn = mapping.generatedColumn</span><span class="s2">;</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.source != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">sourceIdx = </span><span class="s1">this</span><span class="s0">._sources.indexOf(mapping.source)</span><span class="s2">;</span>
	        <span class="s0">next += base64VLQ.encode(sourceIdx - previousSource)</span><span class="s2">;</span>
	        <span class="s0">previousSource = sourceIdx</span><span class="s2">;</span>
	
	        <span class="s5">// lines are stored 0-based in SourceMap spec version 3</span>
	        <span class="s0">next += base64VLQ.encode(mapping.originalLine - </span><span class="s6">1</span>
	                                   <span class="s0">- previousOriginalLine)</span><span class="s2">;</span>
	        <span class="s0">previousOriginalLine = mapping.originalLine - </span><span class="s6">1</span><span class="s2">;</span>
	
	        <span class="s0">next += base64VLQ.encode(mapping.originalColumn</span>
	                                   <span class="s0">- previousOriginalColumn)</span><span class="s2">;</span>
	        <span class="s0">previousOriginalColumn = mapping.originalColumn</span><span class="s2">;</span>
	
	        <span class="s1">if </span><span class="s0">(mapping.name != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">nameIdx = </span><span class="s1">this</span><span class="s0">._names.indexOf(mapping.name)</span><span class="s2">;</span>
	          <span class="s0">next += base64VLQ.encode(nameIdx - previousName)</span><span class="s2">;</span>
	          <span class="s0">previousName = nameIdx</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s0">result += next</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">result</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">SourceMapGenerator.prototype._generateSourcesContent =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_generateSourcesContent(aSources</span><span class="s2">, </span><span class="s0">aSourceRoot) {</span>
	    <span class="s1">return </span><span class="s0">aSources.map(</span><span class="s1">function </span><span class="s0">(source) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	        <span class="s1">return null</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">if </span><span class="s0">(aSourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">source = util.relative(aSourceRoot</span><span class="s2">, </span><span class="s0">source)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">var </span><span class="s0">key = util.toSetString(source)</span><span class="s2">;</span>
	      <span class="s1">return </span><span class="s0">Object.prototype.hasOwnProperty.call(</span><span class="s1">this</span><span class="s0">._sourcesContents</span><span class="s2">, </span><span class="s0">key)</span>
	        <span class="s0">? </span><span class="s1">this</span><span class="s0">._sourcesContents[key]</span>
	        <span class="s0">: </span><span class="s1">null</span><span class="s2">;</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Externalize the source map.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.toJSON =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_toJSON() {</span>
	    <span class="s1">var </span><span class="s0">map = {</span>
	      <span class="s0">version: </span><span class="s1">this</span><span class="s0">._version</span><span class="s2">,</span>
	      <span class="s0">sources: </span><span class="s1">this</span><span class="s0">._sources.toArray()</span><span class="s2">,</span>
	      <span class="s0">names: </span><span class="s1">this</span><span class="s0">._names.toArray()</span><span class="s2">,</span>
	      <span class="s0">mappings: </span><span class="s1">this</span><span class="s0">._serializeMappings()</span>
	    <span class="s0">}</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._file != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">map.file = </span><span class="s1">this</span><span class="s0">._file</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">map.sourceRoot = </span><span class="s1">this</span><span class="s0">._sourceRoot</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	      <span class="s0">map.sourcesContent = </span><span class="s1">this</span><span class="s0">._generateSourcesContent(map.sources</span><span class="s2">, </span><span class="s0">map.sourceRoot)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">map</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Render the source map being generated to a string.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.toString =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_toString() {</span>
	    <span class="s1">return </span><span class="s0">JSON.stringify(</span><span class="s1">this</span><span class="s0">.toJSON())</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">exports.SourceMapGenerator = SourceMapGenerator</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 2 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     * 
     * Based on the Base 64 VLQ implementation in Closure Compiler: 
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java 
     * 
     * Copyright 2011 The Closure Compiler Authors. All rights reserved. 
     * Redistribution and use in source and binary forms, with or without 
     * modification, are permitted provided that the following conditions are 
     * met: 
     * 
     *  * Redistributions of source code must retain the above copyright 
     *    notice, this list of conditions and the following disclaimer. 
     *  * Redistributions in binary form must reproduce the above 
     *    copyright notice, this list of conditions and the following 
     *    disclaimer in the documentation and/or other materials provided 
     *    with the distribution. 
     *  * Neither the name of Google Inc. nor the names of its 
     *    contributors may be used to endorse or promote products derived 
     *    from this software without specific prior written permission. 
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
     * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
     */</span>
	
	<span class="s1">var </span><span class="s0">base64 = __webpack_require__(</span><span class="s6">3</span><span class="s0">)</span><span class="s2">;</span>
	
	<span class="s5">// A single base 64 digit can contain 6 bits of data. For the base 64 variable</span>
	<span class="s5">// length quantities we use in the source map spec, the first bit is the sign,</span>
	<span class="s5">// the next four bits are the actual value, and the 6th bit is the</span>
	<span class="s5">// continuation bit. The continuation bit tells us whether there are more</span>
	<span class="s5">// digits in this value following this digit.</span>
	<span class="s5">//</span>
	<span class="s5">//   Continuation</span>
	<span class="s5">//   |    Sign</span>
	<span class="s5">//   |    |</span>
	<span class="s5">//   V    V</span>
	<span class="s5">//   101011</span>
	
	<span class="s1">var </span><span class="s0">VLQ_BASE_SHIFT = </span><span class="s6">5</span><span class="s2">;</span>
	
	<span class="s5">// binary: 100000</span>
	<span class="s1">var </span><span class="s0">VLQ_BASE = </span><span class="s6">1 </span><span class="s0">&lt;&lt; VLQ_BASE_SHIFT</span><span class="s2">;</span>
	
	<span class="s5">// binary: 011111</span>
	<span class="s1">var </span><span class="s0">VLQ_BASE_MASK = VLQ_BASE - </span><span class="s6">1</span><span class="s2">;</span>
	
	<span class="s5">// binary: 100000</span>
	<span class="s1">var </span><span class="s0">VLQ_CONTINUATION_BIT = VLQ_BASE</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Converts from a two-complement value to a value where the sign bit is</span>
	 <span class="s7">* placed in the least significant bit.  For example, as decimals:</span>
	 <span class="s7">*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)</span>
	 <span class="s7">*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">toVLQSigned(aValue) {</span>
	  <span class="s1">return </span><span class="s0">aValue &lt; </span><span class="s6">0</span>
	    <span class="s0">? ((-aValue) &lt;&lt; </span><span class="s6">1</span><span class="s0">) + </span><span class="s6">1</span>
	    <span class="s0">: (aValue &lt;&lt; </span><span class="s6">1</span><span class="s0">) + </span><span class="s6">0</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Converts to a two-complement value from a value where the sign bit is</span>
	 <span class="s7">* placed in the least significant bit.  For example, as decimals:</span>
	 <span class="s7">*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1</span>
	 <span class="s7">*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">fromVLQSigned(aValue) {</span>
	  <span class="s1">var </span><span class="s0">isNegative = (aValue &amp; </span><span class="s6">1</span><span class="s0">) === </span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">shifted = aValue &gt;&gt; </span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s1">return </span><span class="s0">isNegative</span>
	    <span class="s0">? -shifted</span>
	    <span class="s0">: shifted</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the base 64 VLQ encoded value.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.encode = </span><span class="s1">function </span><span class="s0">base64VLQ_encode(aValue) {</span>
	  <span class="s1">var </span><span class="s0">encoded = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">digit</span><span class="s2">;</span>
	
	  <span class="s1">var </span><span class="s0">vlq = toVLQSigned(aValue)</span><span class="s2">;</span>
	
	  <span class="s1">do </span><span class="s0">{</span>
	    <span class="s0">digit = vlq &amp; VLQ_BASE_MASK</span><span class="s2">;</span>
	    <span class="s0">vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(vlq &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s5">// There are still more digits in this value, so we must make sure the</span>
	      <span class="s5">// continuation bit is marked.</span>
	      <span class="s0">digit |= VLQ_CONTINUATION_BIT</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">encoded += base64.encode(digit)</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">while </span><span class="s0">(vlq &gt; </span><span class="s6">0</span><span class="s0">)</span><span class="s2">;</span>
	
	  <span class="s1">return </span><span class="s0">encoded</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Decodes the next base 64 VLQ value from the given string and returns the</span>
	 <span class="s7">* value and the rest of the string via the out parameter.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.decode = </span><span class="s1">function </span><span class="s0">base64VLQ_decode(aStr</span><span class="s2">, </span><span class="s0">aIndex</span><span class="s2">, </span><span class="s0">aOutParam) {</span>
	  <span class="s1">var </span><span class="s0">strLen = aStr.length</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">result = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">shift = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">continuation</span><span class="s2">, </span><span class="s0">digit</span><span class="s2">;</span>
	
	  <span class="s1">do </span><span class="s0">{</span>
	    <span class="s1">if </span><span class="s0">(aIndex &gt;= strLen) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Expected more digits in base 64 VLQ value.&quot;</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s0">digit = base64.decode(aStr.charCodeAt(aIndex++))</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(digit === -</span><span class="s6">1</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Invalid base64 digit: &quot; </span><span class="s0">+ aStr.charAt(aIndex - </span><span class="s6">1</span><span class="s0">))</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s0">continuation = !!(digit &amp; VLQ_CONTINUATION_BIT)</span><span class="s2">;</span>
	    <span class="s0">digit &amp;= VLQ_BASE_MASK</span><span class="s2">;</span>
	    <span class="s0">result = result + (digit &lt;&lt; shift)</span><span class="s2">;</span>
	    <span class="s0">shift += VLQ_BASE_SHIFT</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">while </span><span class="s0">(continuation)</span><span class="s2">;</span>
	
	  <span class="s0">aOutParam.value = fromVLQSigned(result)</span><span class="s2">;</span>
	  <span class="s0">aOutParam.rest = aIndex</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 3 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">intToCharMap = </span><span class="s3">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s0">.split(</span><span class="s3">''</span><span class="s0">)</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Encode an integer in the range of 0 to 63 to a single base 64 digit.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.encode = </span><span class="s1">function </span><span class="s0">(number) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s6">0 </span><span class="s0">&lt;= number &amp;&amp; number &lt; intToCharMap.length) {</span>
	    <span class="s1">return </span><span class="s0">intToCharMap[number]</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Must be between 0 and 63: &quot; </span><span class="s0">+ number)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Decode a single base 64 character code digit to an integer. Returns -1 on</span>
	 <span class="s7">* failure.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.decode = </span><span class="s1">function </span><span class="s0">(charCode) {</span>
	  <span class="s1">var </span><span class="s0">bigA = </span><span class="s6">65</span><span class="s2">;     </span><span class="s5">// 'A'</span>
	  <span class="s1">var </span><span class="s0">bigZ = </span><span class="s6">90</span><span class="s2">;     </span><span class="s5">// 'Z'</span>
	
	  <span class="s1">var </span><span class="s0">littleA = </span><span class="s6">97</span><span class="s2">;  </span><span class="s5">// 'a'</span>
	  <span class="s1">var </span><span class="s0">littleZ = </span><span class="s6">122</span><span class="s2">; </span><span class="s5">// 'z'</span>
	
	  <span class="s1">var </span><span class="s0">zero = </span><span class="s6">48</span><span class="s2">;     </span><span class="s5">// '0'</span>
	  <span class="s1">var </span><span class="s0">nine = </span><span class="s6">57</span><span class="s2">;     </span><span class="s5">// '9'</span>
	
	  <span class="s1">var </span><span class="s0">plus = </span><span class="s6">43</span><span class="s2">;     </span><span class="s5">// '+'</span>
	  <span class="s1">var </span><span class="s0">slash = </span><span class="s6">47</span><span class="s2">;    </span><span class="s5">// '/'</span>
	
	  <span class="s1">var </span><span class="s0">littleOffset = </span><span class="s6">26</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">numberOffset = </span><span class="s6">52</span><span class="s2">;</span>
	
	  <span class="s5">// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ</span>
	  <span class="s1">if </span><span class="s0">(bigA &lt;= charCode &amp;&amp; charCode &lt;= bigZ) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - bigA)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// 26 - 51: abcdefghijklmnopqrstuvwxyz</span>
	  <span class="s1">if </span><span class="s0">(littleA &lt;= charCode &amp;&amp; charCode &lt;= littleZ) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - littleA + littleOffset)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// 52 - 61: 0123456789</span>
	  <span class="s1">if </span><span class="s0">(zero &lt;= charCode &amp;&amp; charCode &lt;= nine) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - zero + numberOffset)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// 62: +</span>
	  <span class="s1">if </span><span class="s0">(charCode == plus) {</span>
	    <span class="s1">return </span><span class="s6">62</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// 63: /</span>
	  <span class="s1">if </span><span class="s0">(charCode == slash) {</span>
	    <span class="s1">return </span><span class="s6">63</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// Invalid base64 digit.</span>
	  <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 4 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* This is a helper function for getting values from parameter/options</span>
	 <span class="s7">* objects.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">args The object we are extracting values from</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">name The name of the property we are getting.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">defaultValue An optional value to return if the property is missing</span>
	 <span class="s7">* from the object. If this is not specified and the property is missing, an</span>
	 <span class="s7">* error will be thrown.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">getArg(aArgs</span><span class="s2">, </span><span class="s0">aName</span><span class="s2">, </span><span class="s0">aDefaultValue) {</span>
	  <span class="s1">if </span><span class="s0">(aName </span><span class="s1">in </span><span class="s0">aArgs) {</span>
	    <span class="s1">return </span><span class="s0">aArgs[aName]</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(arguments.length === </span><span class="s6">3</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">aDefaultValue</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'&quot;' </span><span class="s0">+ aName + </span><span class="s3">'&quot; is a required argument.'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">exports.getArg = getArg</span><span class="s2">;</span>
	
	<span class="s1">var </span><span class="s0">urlRegexp = </span><span class="s6">/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">dataUrlRegexp = </span><span class="s6">/^data:.+\,.+$/</span><span class="s2">;</span>
	
	<span class="s1">function </span><span class="s0">urlParse(aUrl) {</span>
	  <span class="s1">var </span><span class="s0">match = aUrl.match(urlRegexp)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(!match) {</span>
	    <span class="s1">return null</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">{</span>
	    <span class="s0">scheme: match[</span><span class="s6">1</span><span class="s0">]</span><span class="s2">,</span>
	    <span class="s0">auth: match[</span><span class="s6">2</span><span class="s0">]</span><span class="s2">,</span>
	    <span class="s0">host: match[</span><span class="s6">3</span><span class="s0">]</span><span class="s2">,</span>
	    <span class="s0">port: match[</span><span class="s6">4</span><span class="s0">]</span><span class="s2">,</span>
	    <span class="s0">path: match[</span><span class="s6">5</span><span class="s0">]</span>
	  <span class="s0">}</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.urlParse = urlParse</span><span class="s2">;</span>
	
	<span class="s1">function </span><span class="s0">urlGenerate(aParsedUrl) {</span>
	  <span class="s1">var </span><span class="s0">url = </span><span class="s3">''</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.scheme) {</span>
	    <span class="s0">url += aParsedUrl.scheme + </span><span class="s3">':'</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s0">url += </span><span class="s3">'//'</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.auth) {</span>
	    <span class="s0">url += aParsedUrl.auth + </span><span class="s3">'@'</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.host) {</span>
	    <span class="s0">url += aParsedUrl.host</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.port) {</span>
	    <span class="s0">url += </span><span class="s3">&quot;:&quot; </span><span class="s0">+ aParsedUrl.port</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.path) {</span>
	    <span class="s0">url += aParsedUrl.path</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">url</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.urlGenerate = urlGenerate</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Normalizes a path, or the path portion of a URL:</span>
	 <span class="s7">*</span>
	 <span class="s7">* - Replaces consecutive slashes with one slash.</span>
	 <span class="s7">* - Removes unnecessary '.' parts.</span>
	 <span class="s7">* - Removes unnecessary '&lt;dir&gt;/..' parts.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Based on code in the Node.js 'path' core module.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aPath The path or url to normalize.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">normalize(aPath) {</span>
	  <span class="s1">var </span><span class="s0">path = aPath</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">url = urlParse(aPath)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(url) {</span>
	    <span class="s1">if </span><span class="s0">(!url.path) {</span>
	      <span class="s1">return </span><span class="s0">aPath</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">path = url.path</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">var </span><span class="s0">isAbsolute = exports.isAbsolute(path)</span><span class="s2">;</span>
	
	  <span class="s1">var </span><span class="s0">parts = path.split(</span><span class="s6">/\/+/</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">part</span><span class="s2">, </span><span class="s0">up = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">i = parts.length - </span><span class="s6">1</span><span class="s2">; </span><span class="s0">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i--) {</span>
	    <span class="s0">part = parts[i]</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(part === </span><span class="s3">'.'</span><span class="s0">) {</span>
	      <span class="s0">parts.splice(i</span><span class="s2">, </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(part === </span><span class="s3">'..'</span><span class="s0">) {</span>
	      <span class="s0">up++</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(up &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(part === </span><span class="s3">''</span><span class="s0">) {</span>
	        <span class="s5">// The first part is blank if the path is absolute. Trying to go</span>
	        <span class="s5">// above the root is a no-op. Therefore we can remove all '..' parts</span>
	        <span class="s5">// directly after the root.</span>
	        <span class="s0">parts.splice(i + </span><span class="s6">1</span><span class="s2">, </span><span class="s0">up)</span><span class="s2">;</span>
	        <span class="s0">up = </span><span class="s6">0</span><span class="s2">;</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">parts.splice(i</span><span class="s2">, </span><span class="s6">2</span><span class="s0">)</span><span class="s2">;</span>
	        <span class="s0">up--</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s0">path = parts.join(</span><span class="s3">'/'</span><span class="s0">)</span><span class="s2">;</span>
	
	  <span class="s1">if </span><span class="s0">(path === </span><span class="s3">''</span><span class="s0">) {</span>
	    <span class="s0">path = isAbsolute ? </span><span class="s3">'/' </span><span class="s0">: </span><span class="s3">'.'</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(url) {</span>
	    <span class="s0">url.path = path</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(url)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">path</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.normalize = normalize</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Joins two paths/URLs.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aRoot The root path or URL.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aPath The path or URL to be joined with the root.</span>
	 <span class="s7">*</span>
	 <span class="s7">* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a</span>
	 <span class="s7">*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended</span>
	 <span class="s7">*   first.</span>
	 <span class="s7">* - Otherwise aPath is a path. If aRoot is a URL, then its path portion</span>
	 <span class="s7">*   is updated with the result and aRoot is returned. Otherwise the result</span>
	 <span class="s7">*   is returned.</span>
	 <span class="s7">*   - If aPath is absolute, the result is aPath.</span>
	 <span class="s7">*   - Otherwise the two paths are joined with a slash.</span>
	 <span class="s7">* - Joining for example 'http://' and 'www.example.com' is also supported.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">join(aRoot</span><span class="s2">, </span><span class="s0">aPath) {</span>
	  <span class="s1">if </span><span class="s0">(aRoot === </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aRoot = </span><span class="s3">&quot;.&quot;</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aPath === </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aPath = </span><span class="s3">&quot;.&quot;</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">var </span><span class="s0">aPathUrl = urlParse(aPath)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">aRootUrl = urlParse(aRoot)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	    <span class="s0">aRoot = aRootUrl.path || </span><span class="s3">'/'</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// `join(foo, '//www.example.org')`</span>
	  <span class="s1">if </span><span class="s0">(aPathUrl &amp;&amp; !aPathUrl.scheme) {</span>
	    <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	      <span class="s0">aPathUrl.scheme = aRootUrl.scheme</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aPathUrl)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(aPathUrl || aPath.match(dataUrlRegexp)) {</span>
	    <span class="s1">return </span><span class="s0">aPath</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// `join('http://', 'www.example.com')`</span>
	  <span class="s1">if </span><span class="s0">(aRootUrl &amp;&amp; !aRootUrl.host &amp;&amp; !aRootUrl.path) {</span>
	    <span class="s0">aRootUrl.host = aPath</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aRootUrl)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">joined = aPath.charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s3">'/'</span>
	    <span class="s0">? aPath</span>
	    <span class="s0">: normalize(aRoot.replace(</span><span class="s6">/\/+$/</span><span class="s2">, </span><span class="s3">''</span><span class="s0">) + </span><span class="s3">'/' </span><span class="s0">+ aPath)</span><span class="s2">;</span>
	
	  <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	    <span class="s0">aRootUrl.path = joined</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aRootUrl)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">joined</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.join = join</span><span class="s2">;</span>
	
	<span class="s0">exports.isAbsolute = </span><span class="s1">function </span><span class="s0">(aPath) {</span>
	  <span class="s1">return </span><span class="s0">aPath.charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s3">'/' </span><span class="s0">|| urlRegexp.test(aPath)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Make a path relative to a URL or another path.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aRoot The root path or URL.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aPath The path or URL to be made relative to aRoot.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">relative(aRoot</span><span class="s2">, </span><span class="s0">aPath) {</span>
	  <span class="s1">if </span><span class="s0">(aRoot === </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aRoot = </span><span class="s3">&quot;.&quot;</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">aRoot = aRoot.replace(</span><span class="s6">/\/$/</span><span class="s2">, </span><span class="s3">''</span><span class="s0">)</span><span class="s2">;</span>
	
	  <span class="s5">// It is possible for the path to be above the root. In this case, simply</span>
	  <span class="s5">// checking whether the root is a prefix of the path won't work. Instead, we</span>
	  <span class="s5">// need to remove components from the root one by one, until either we find</span>
	  <span class="s5">// a prefix that fits, or we run out of components to remove.</span>
	  <span class="s1">var </span><span class="s0">level = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">while </span><span class="s0">(aPath.indexOf(aRoot + </span><span class="s3">'/'</span><span class="s0">) !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s0">index = aRoot.lastIndexOf(</span><span class="s3">&quot;/&quot;</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">aPath</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s5">// If the only part of the root that is left is the scheme (i.e. http://,</span>
	    <span class="s5">// file:///, etc.), one or more slashes (/), or simply nothing at all, we</span>
	    <span class="s5">// have exhausted all components, so the path is not relative to the root.</span>
	    <span class="s0">aRoot = aRoot.slice(</span><span class="s6">0</span><span class="s2">, </span><span class="s0">index)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(aRoot.match(</span><span class="s6">/^([^\/]+:\/)?\/*$/</span><span class="s0">)) {</span>
	      <span class="s1">return </span><span class="s0">aPath</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s0">++level</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// Make sure we add a &quot;../&quot; for each component we removed from the root.</span>
	  <span class="s1">return </span><span class="s0">Array(level + </span><span class="s6">1</span><span class="s0">).join(</span><span class="s3">&quot;../&quot;</span><span class="s0">) + aPath.substr(aRoot.length + </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.relative = relative</span><span class="s2">;</span>
	
	<span class="s1">var </span><span class="s0">supportsNullProto = (</span><span class="s1">function </span><span class="s0">() {</span>
	  <span class="s1">var </span><span class="s0">obj = Object.create(</span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">return </span><span class="s0">!(</span><span class="s3">'__proto__' </span><span class="s1">in </span><span class="s0">obj)</span><span class="s2">;</span>
	<span class="s0">}())</span><span class="s2">;</span>
	
	<span class="s1">function </span><span class="s0">identity (s) {</span>
	  <span class="s1">return </span><span class="s0">s</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Because behavior goes wacky when you set `__proto__` on objects, we</span>
	 <span class="s7">* have to prefix all the strings in our set with an arbitrary character.</span>
	 <span class="s7">*</span>
	 <span class="s7">* See https://github.com/mozilla/source-map/pull/31 and</span>
	 <span class="s7">* https://github.com/mozilla/source-map/issues/30</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aStr</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">toSetString(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(isProtoString(aStr)) {</span>
	    <span class="s1">return </span><span class="s3">'$' </span><span class="s0">+ aStr</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">aStr</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.toSetString = supportsNullProto ? identity : toSetString</span><span class="s2">;</span>
	
	<span class="s1">function </span><span class="s0">fromSetString(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(isProtoString(aStr)) {</span>
	    <span class="s1">return </span><span class="s0">aStr.slice(</span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">aStr</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.fromSetString = supportsNullProto ? identity : fromSetString</span><span class="s2">;</span>
	
	<span class="s1">function </span><span class="s0">isProtoString(s) {</span>
	  <span class="s1">if </span><span class="s0">(!s) {</span>
	    <span class="s1">return false</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">length = s.length</span><span class="s2">;</span>
	
	  <span class="s1">if </span><span class="s0">(length &lt; </span><span class="s6">9 </span><span class="s4">/* &quot;__proto__&quot;.length */</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(s.charCodeAt(length - </span><span class="s6">1</span><span class="s0">) !== </span><span class="s6">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">2</span><span class="s0">) !== </span><span class="s6">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">3</span><span class="s0">) !== </span><span class="s6">111 </span><span class="s4">/* 'o' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">4</span><span class="s0">) !== </span><span class="s6">116 </span><span class="s4">/* 't' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">5</span><span class="s0">) !== </span><span class="s6">111 </span><span class="s4">/* 'o' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">6</span><span class="s0">) !== </span><span class="s6">114 </span><span class="s4">/* 'r' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">7</span><span class="s0">) !== </span><span class="s6">112 </span><span class="s4">/* 'p' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">8</span><span class="s0">) !== </span><span class="s6">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">9</span><span class="s0">) !== </span><span class="s6">95  </span><span class="s4">/* '_' */</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = length - </span><span class="s6">10</span><span class="s2">; </span><span class="s0">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i--) {</span>
	    <span class="s1">if </span><span class="s0">(s.charCodeAt(i) !== </span><span class="s6">36 </span><span class="s4">/* '$' */</span><span class="s0">) {</span>
	      <span class="s1">return false</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return true</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Comparator between two mappings where the original positions are compared.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span>
	 <span class="s7">* mappings with the same original source/line/column, but different generated</span>
	 <span class="s7">* line and column the same. Useful when searching for a mapping with a</span>
	 <span class="s7">* stubbed out mapping.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">compareByOriginalPositions(mappingA</span><span class="s2">, </span><span class="s0">mappingB</span><span class="s2">, </span><span class="s0">onlyCompareOriginal) {</span>
	  <span class="s1">var </span><span class="s0">cmp = strcmp(mappingA.source</span><span class="s2">, </span><span class="s0">mappingB.source)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0 </span><span class="s0">|| onlyCompareOriginal) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">strcmp(mappingA.name</span><span class="s2">, </span><span class="s0">mappingB.name)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByOriginalPositions = compareByOriginalPositions</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Comparator between two mappings with deflated source and name indices where</span>
	 <span class="s7">* the generated positions are compared.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span>
	 <span class="s7">* mappings with the same generated line and column, but different</span>
	 <span class="s7">* source/name/original line and column the same. Useful when searching for a</span>
	 <span class="s7">* mapping with a stubbed out mapping.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">compareByGeneratedPositionsDeflated(mappingA</span><span class="s2">, </span><span class="s0">mappingB</span><span class="s2">, </span><span class="s0">onlyCompareGenerated) {</span>
	  <span class="s1">var </span><span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0 </span><span class="s0">|| onlyCompareGenerated) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = strcmp(mappingA.source</span><span class="s2">, </span><span class="s0">mappingB.source)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">strcmp(mappingA.name</span><span class="s2">, </span><span class="s0">mappingB.name)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated</span><span class="s2">;</span>
	
	<span class="s1">function </span><span class="s0">strcmp(aStr1</span><span class="s2">, </span><span class="s0">aStr2) {</span>
	  <span class="s1">if </span><span class="s0">(aStr1 === aStr2) {</span>
	    <span class="s1">return </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(aStr1 === </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s6">1</span><span class="s2">; </span><span class="s5">// aStr2 !== null</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(aStr2 === </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">; </span><span class="s5">// aStr1 !== null</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(aStr1 &gt; aStr2) {</span>
	    <span class="s1">return </span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Comparator between two mappings with inflated source and name strings where</span>
	 <span class="s7">* the generated positions are compared.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">compareByGeneratedPositionsInflated(mappingA</span><span class="s2">, </span><span class="s0">mappingB) {</span>
	  <span class="s1">var </span><span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = strcmp(mappingA.source</span><span class="s2">, </span><span class="s0">mappingB.source)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">strcmp(mappingA.name</span><span class="s2">, </span><span class="s0">mappingB.name)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Strip any JSON XSSI avoidance prefix from the string (as documented</span>
	 <span class="s7">* in the source maps specification), and then parse the string as</span>
	 <span class="s7">* JSON.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">parseSourceMapInput(str) {</span>
	  <span class="s1">return </span><span class="s0">JSON.parse(str.replace(</span><span class="s6">/^\)]}'[^\n]*\n/</span><span class="s2">, </span><span class="s3">''</span><span class="s0">))</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.parseSourceMapInput = parseSourceMapInput</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Compute the URL of a source given the the source root, the source's</span>
	 <span class="s7">* URL, and the source map's URL.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">computeSourceURL(sourceRoot</span><span class="s2">, </span><span class="s0">sourceURL</span><span class="s2">, </span><span class="s0">sourceMapURL) {</span>
	  <span class="s0">sourceURL = sourceURL || </span><span class="s3">''</span><span class="s2">;</span>
	
	  <span class="s1">if </span><span class="s0">(sourceRoot) {</span>
	    <span class="s5">// This follows what Chrome does.</span>
	    <span class="s1">if </span><span class="s0">(sourceRoot[sourceRoot.length - </span><span class="s6">1</span><span class="s0">] !== </span><span class="s3">'/' </span><span class="s0">&amp;&amp; sourceURL[</span><span class="s6">0</span><span class="s0">] !== </span><span class="s3">'/'</span><span class="s0">) {</span>
	      <span class="s0">sourceRoot += </span><span class="s3">'/'</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s5">// The spec says:</span>
	    <span class="s5">//   Line 4: An optional source root, useful for relocating source</span>
	    <span class="s5">//   files on a server or removing repeated values in the</span>
	    <span class="s5">//   “sources” entry.  This value is prepended to the individual</span>
	    <span class="s5">//   entries in the “source” field.</span>
	    <span class="s0">sourceURL = sourceRoot + sourceURL</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// Historically, SourceMapConsumer did not take the sourceMapURL as</span>
	  <span class="s5">// a parameter.  This mode is still somewhat supported, which is why</span>
	  <span class="s5">// this code block is conditional.  However, it's preferable to pass</span>
	  <span class="s5">// the source map URL to SourceMapConsumer, so that this function</span>
	  <span class="s5">// can implement the source URL resolution algorithm as outlined in</span>
	  <span class="s5">// the spec.  This block is basically the equivalent of:</span>
	  <span class="s5">//    new URL(sourceURL, sourceMapURL).toString()</span>
	  <span class="s5">// ... except it avoids using URL, which wasn't available in the</span>
	  <span class="s5">// older releases of node still supported by this library.</span>
	  <span class="s5">//</span>
	  <span class="s5">// The spec says:</span>
	  <span class="s5">//   If the sources are not absolute URLs after prepending of the</span>
	  <span class="s5">//   “sourceRoot”, the sources are resolved relative to the</span>
	  <span class="s5">//   SourceMap (like resolving script src in a html document).</span>
	  <span class="s1">if </span><span class="s0">(sourceMapURL) {</span>
	    <span class="s1">var </span><span class="s0">parsed = urlParse(sourceMapURL)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(!parsed) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;sourceMapURL could not be parsed&quot;</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(parsed.path) {</span>
	      <span class="s5">// Strip the last path component, but keep the &quot;/&quot;.</span>
	      <span class="s1">var </span><span class="s0">index = parsed.path.lastIndexOf(</span><span class="s3">'/'</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	        <span class="s0">parsed.path = parsed.path.substring(</span><span class="s6">0</span><span class="s2">, </span><span class="s0">index + </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s0">sourceURL = join(urlGenerate(parsed)</span><span class="s2">, </span><span class="s0">sourceURL)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">normalize(sourceURL)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.computeSourceURL = computeSourceURL</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 5 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">has = Object.prototype.hasOwnProperty</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">hasNativeMap = </span><span class="s1">typeof </span><span class="s0">Map !== </span><span class="s3">&quot;undefined&quot;</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* A data structure which is a combination of an array and a set. Adding a new</span>
	 <span class="s7">* member is O(1), testing for membership is O(1), and finding the index of an</span>
	 <span class="s7">* element is O(1). Removing elements from the set is not supported. Only</span>
	 <span class="s7">* strings are supported for membership.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">ArraySet() {</span>
	  <span class="s1">this</span><span class="s0">._array = []</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._set = hasNativeMap ? </span><span class="s1">new </span><span class="s0">Map() : Object.create(</span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Static method for creating ArraySet instances from an existing array.</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.fromArray = </span><span class="s1">function </span><span class="s0">ArraySet_fromArray(aArray</span><span class="s2">, </span><span class="s0">aAllowDuplicates) {</span>
	  <span class="s1">var </span><span class="s0">set = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = aArray.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	    <span class="s0">set.add(aArray[i]</span><span class="s2">, </span><span class="s0">aAllowDuplicates)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">set</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Return how many unique items are in this ArraySet. If duplicates have been</span>
	 <span class="s7">* added, than those do not count towards the size.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@returns </span><span class="s7">Number</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.size = </span><span class="s1">function </span><span class="s0">ArraySet_size() {</span>
	  <span class="s1">return </span><span class="s0">hasNativeMap ? </span><span class="s1">this</span><span class="s0">._set.size : Object.getOwnPropertyNames(</span><span class="s1">this</span><span class="s0">._set).length</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Add the given string to this set.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aStr</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.add = </span><span class="s1">function </span><span class="s0">ArraySet_add(aStr</span><span class="s2">, </span><span class="s0">aAllowDuplicates) {</span>
	  <span class="s1">var </span><span class="s0">sStr = hasNativeMap ? aStr : util.toSetString(aStr)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">isDuplicate = hasNativeMap ? </span><span class="s1">this</span><span class="s0">.has(aStr) : has.call(</span><span class="s1">this</span><span class="s0">._set</span><span class="s2">, </span><span class="s0">sStr)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">idx = </span><span class="s1">this</span><span class="s0">._array.length</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(!isDuplicate || aAllowDuplicates) {</span>
	    <span class="s1">this</span><span class="s0">._array.push(aStr)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(!isDuplicate) {</span>
	    <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	      <span class="s1">this</span><span class="s0">._set.set(aStr</span><span class="s2">, </span><span class="s0">idx)</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">this</span><span class="s0">._set[sStr] = idx</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Is the given string a member of this set?</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aStr</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.has = </span><span class="s1">function </span><span class="s0">ArraySet_has(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	    <span class="s1">return this</span><span class="s0">._set.has(aStr)</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">var </span><span class="s0">sStr = util.toSetString(aStr)</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">has.call(</span><span class="s1">this</span><span class="s0">._set</span><span class="s2">, </span><span class="s0">sStr)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* What is the index of the given string in the array?</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aStr</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.indexOf = </span><span class="s1">function </span><span class="s0">ArraySet_indexOf(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	    <span class="s1">var </span><span class="s0">idx = </span><span class="s1">this</span><span class="s0">._set.get(aStr)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(idx &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	        <span class="s1">return </span><span class="s0">idx</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">var </span><span class="s0">sStr = util.toSetString(aStr)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(has.call(</span><span class="s1">this</span><span class="s0">._set</span><span class="s2">, </span><span class="s0">sStr)) {</span>
	      <span class="s1">return this</span><span class="s0">._set[sStr]</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	
	  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'&quot;' </span><span class="s0">+ aStr + </span><span class="s3">'&quot; is not in the set.'</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* What is the element at the given index?</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">Number aIdx</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.at = </span><span class="s1">function </span><span class="s0">ArraySet_at(aIdx) {</span>
	  <span class="s1">if </span><span class="s0">(aIdx &gt;= </span><span class="s6">0 </span><span class="s0">&amp;&amp; aIdx &lt; </span><span class="s1">this</span><span class="s0">._array.length) {</span>
	    <span class="s1">return this</span><span class="s0">._array[aIdx]</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'No element indexed by ' </span><span class="s0">+ aIdx)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the array representation of this set (which has the proper indices</span>
	 <span class="s7">* indicated by indexOf). Note that this is a copy of the internal array used</span>
	 <span class="s7">* for storing the members so that no one can mess with internal state.</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.toArray = </span><span class="s1">function </span><span class="s0">ArraySet_toArray() {</span>
	  <span class="s1">return this</span><span class="s0">._array.slice()</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">exports.ArraySet = ArraySet</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 6 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2014 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Determine whether mappingB is after mappingA with respect to generated</span>
	 <span class="s7">* position.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">generatedPositionAfter(mappingA</span><span class="s2">, </span><span class="s0">mappingB) {</span>
	  <span class="s5">// Optimized for most common case</span>
	  <span class="s1">var </span><span class="s0">lineA = mappingA.generatedLine</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lineB = mappingB.generatedLine</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">columnA = mappingA.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">columnB = mappingB.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">return </span><span class="s0">lineB &gt; lineA || lineB == lineA &amp;&amp; columnB &gt;= columnA ||</span>
	         <span class="s0">util.compareByGeneratedPositionsInflated(mappingA</span><span class="s2">, </span><span class="s0">mappingB) &lt;= </span><span class="s6">0</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* A data structure to provide a sorted view of accumulated mappings in a</span>
	 <span class="s7">* performance conscious manner. It trades a neglibable overhead in general</span>
	 <span class="s7">* case for a large speedup in case of mappings being added in order.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">MappingList() {</span>
	  <span class="s1">this</span><span class="s0">._array = []</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">true</span><span class="s2">;</span>
	  <span class="s5">// Serves as infimum</span>
	  <span class="s1">this</span><span class="s0">._last = {generatedLine: -</span><span class="s6">1</span><span class="s2">, </span><span class="s0">generatedColumn: </span><span class="s6">0</span><span class="s0">}</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Iterate through internal items. This method takes the same arguments that</span>
	 <span class="s7">* `Array.prototype.forEach` takes.</span>
	 <span class="s7">*</span>
	 <span class="s7">* NOTE: The order of the mappings is NOT guaranteed.</span>
	 <span class="s7">*/</span>
	<span class="s0">MappingList.prototype.unsortedForEach =</span>
	  <span class="s1">function </span><span class="s0">MappingList_forEach(aCallback</span><span class="s2">, </span><span class="s0">aThisArg) {</span>
	    <span class="s1">this</span><span class="s0">._array.forEach(aCallback</span><span class="s2">, </span><span class="s0">aThisArg)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Add the given source mapping.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">Object aMapping</span>
	 <span class="s7">*/</span>
	<span class="s0">MappingList.prototype.add = </span><span class="s1">function </span><span class="s0">MappingList_add(aMapping) {</span>
	  <span class="s1">if </span><span class="s0">(generatedPositionAfter(</span><span class="s1">this</span><span class="s0">._last</span><span class="s2">, </span><span class="s0">aMapping)) {</span>
	    <span class="s1">this</span><span class="s0">._last = aMapping</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._array.push(aMapping)</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">false</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._array.push(aMapping)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the flat, sorted array of mappings. The mappings are sorted by</span>
	 <span class="s7">* generated position.</span>
	 <span class="s7">*</span>
	 <span class="s7">* WARNING: This method returns internal data without copying, for</span>
	 <span class="s7">* performance. The return value must NOT be mutated, and should be treated as</span>
	 <span class="s7">* an immutable borrow. If you want to take ownership, you must make your own</span>
	 <span class="s7">* copy.</span>
	 <span class="s7">*/</span>
	<span class="s0">MappingList.prototype.toArray = </span><span class="s1">function </span><span class="s0">MappingList_toArray() {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sorted) {</span>
	    <span class="s1">this</span><span class="s0">._array.sort(util.compareByGeneratedPositionsInflated)</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">true</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">._array</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">exports.MappingList = MappingList</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 7 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">binarySearch = __webpack_require__(</span><span class="s6">8</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">ArraySet = __webpack_require__(</span><span class="s6">5</span><span class="s0">).ArraySet</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">base64VLQ = __webpack_require__(</span><span class="s6">2</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">quickSort = __webpack_require__(</span><span class="s6">9</span><span class="s0">).quickSort</span><span class="s2">;</span>
	
	<span class="s1">function </span><span class="s0">SourceMapConsumer(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">sourceMap.sections != </span><span class="s1">null</span>
	    <span class="s0">? </span><span class="s1">new </span><span class="s0">IndexedSourceMapConsumer(sourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span>
	    <span class="s0">: </span><span class="s1">new </span><span class="s0">BasicSourceMapConsumer(sourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s0">SourceMapConsumer.fromSourceMap = </span><span class="s1">function</span><span class="s0">(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	  <span class="s1">return </span><span class="s0">BasicSourceMapConsumer.fromSourceMap(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapConsumer.prototype._version = </span><span class="s6">3</span><span class="s2">;</span>
	
	<span class="s5">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span>
	<span class="s5">// parsed mapping coordinates from the source map's &quot;mappings&quot; attribute. They</span>
	<span class="s5">// are lazily instantiated, accessed via the `_generatedMappings` and</span>
	<span class="s5">// `_originalMappings` getters respectively, and we only parse the mappings</span>
	<span class="s5">// and create these arrays once queried for a source location. We jump through</span>
	<span class="s5">// these hoops because there can be many thousands of mappings, and parsing</span>
	<span class="s5">// them is expensive, so we only want to do it if we must.</span>
	<span class="s5">//</span>
	<span class="s5">// Each object in the arrays is of the form:</span>
	<span class="s5">//</span>
	<span class="s5">//     {</span>
	<span class="s5">//       generatedLine: The line number in the generated code,</span>
	<span class="s5">//       generatedColumn: The column number in the generated code,</span>
	<span class="s5">//       source: The path to the original source file that generated this</span>
	<span class="s5">//               chunk of code,</span>
	<span class="s5">//       originalLine: The line number in the original source that</span>
	<span class="s5">//                     corresponds to this chunk of generated code,</span>
	<span class="s5">//       originalColumn: The column number in the original source that</span>
	<span class="s5">//                       corresponds to this chunk of generated code,</span>
	<span class="s5">//       name: The name of the original symbol which generated this chunk of</span>
	<span class="s5">//             code.</span>
	<span class="s5">//     }</span>
	<span class="s5">//</span>
	<span class="s5">// All properties except for `generatedLine` and `generatedColumn` can be</span>
	<span class="s5">// `null`.</span>
	<span class="s5">//</span>
	<span class="s5">// `_generatedMappings` is ordered by the generated positions.</span>
	<span class="s5">//</span>
	<span class="s5">// `_originalMappings` is ordered by the original positions.</span>
	
	<span class="s0">SourceMapConsumer.prototype.__generatedMappings = </span><span class="s1">null</span><span class="s2">;</span>
	<span class="s0">Object.defineProperty(SourceMapConsumer.prototype</span><span class="s2">, </span><span class="s3">'_generatedMappings'</span><span class="s2">, </span><span class="s0">{</span>
	  <span class="s0">configurable: </span><span class="s1">true</span><span class="s2">,</span>
	  <span class="s0">enumerable: </span><span class="s1">true</span><span class="s2">,</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.__generatedMappings) {</span>
	      <span class="s1">this</span><span class="s0">._parseMappings(</span><span class="s1">this</span><span class="s0">._mappings</span><span class="s2">, </span><span class="s1">this</span><span class="s0">.sourceRoot)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return this</span><span class="s0">.__generatedMappings</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">})</span><span class="s2">;</span>
	
	<span class="s0">SourceMapConsumer.prototype.__originalMappings = </span><span class="s1">null</span><span class="s2">;</span>
	<span class="s0">Object.defineProperty(SourceMapConsumer.prototype</span><span class="s2">, </span><span class="s3">'_originalMappings'</span><span class="s2">, </span><span class="s0">{</span>
	  <span class="s0">configurable: </span><span class="s1">true</span><span class="s2">,</span>
	  <span class="s0">enumerable: </span><span class="s1">true</span><span class="s2">,</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.__originalMappings) {</span>
	      <span class="s1">this</span><span class="s0">._parseMappings(</span><span class="s1">this</span><span class="s0">._mappings</span><span class="s2">, </span><span class="s1">this</span><span class="s0">.sourceRoot)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return this</span><span class="s0">.__originalMappings</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">})</span><span class="s2">;</span>
	
	<span class="s0">SourceMapConsumer.prototype._charIsMappingSeparator =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_charIsMappingSeparator(aStr</span><span class="s2">, </span><span class="s0">index) {</span>
	    <span class="s1">var </span><span class="s0">c = aStr.charAt(index)</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">c === </span><span class="s3">&quot;;&quot; </span><span class="s0">|| c === </span><span class="s3">&quot;,&quot;</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s7">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s7">* `this.__originalMappings` properties).</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_parseMappings(aStr</span><span class="s2">, </span><span class="s0">aSourceRoot) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Subclasses must implement _parseMappings&quot;</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">SourceMapConsumer.GENERATED_ORDER = </span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">SourceMapConsumer.ORIGINAL_ORDER = </span><span class="s6">2</span><span class="s2">;</span>
	
	<span class="s0">SourceMapConsumer.GREATEST_LOWER_BOUND = </span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">SourceMapConsumer.LEAST_UPPER_BOUND = </span><span class="s6">2</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Iterate over each mapping between an original source/line/column and a</span>
	 <span class="s7">* generated line/column in this source map.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">Function aCallback</span>
	 <span class="s7">*        The function that is called with each mapping.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">Object aContext</span>
	 <span class="s7">*        Optional. If specified, this object will be the value of `this` every</span>
	 <span class="s7">*        time that `aCallback` is called.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aOrder</span>
	 <span class="s7">*        Either `SourceMapConsumer.GENERATED_ORDER` or</span>
	 <span class="s7">*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to</span>
	 <span class="s7">*        iterate over the mappings sorted by the generated file's line/column</span>
	 <span class="s7">*        order or the original's source/line/column order, respectively. Defaults to</span>
	 <span class="s7">*        `SourceMapConsumer.GENERATED_ORDER`.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapConsumer.prototype.eachMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_eachMapping(aCallback</span><span class="s2">, </span><span class="s0">aContext</span><span class="s2">, </span><span class="s0">aOrder) {</span>
	    <span class="s1">var </span><span class="s0">context = aContext || </span><span class="s1">null</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">order = aOrder || SourceMapConsumer.GENERATED_ORDER</span><span class="s2">;</span>
	
	    <span class="s1">var </span><span class="s0">mappings</span><span class="s2">;</span>
	    <span class="s1">switch </span><span class="s0">(order) {</span>
	    <span class="s1">case </span><span class="s0">SourceMapConsumer.GENERATED_ORDER:</span>
	      <span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._generatedMappings</span><span class="s2">;</span>
	      <span class="s1">break</span><span class="s2">;</span>
	    <span class="s1">case </span><span class="s0">SourceMapConsumer.ORIGINAL_ORDER:</span>
	      <span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._originalMappings</span><span class="s2">;</span>
	      <span class="s1">break</span><span class="s2">;</span>
	    <span class="s1">default</span><span class="s0">:</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unknown order of iteration.&quot;</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">sourceRoot = </span><span class="s1">this</span><span class="s0">.sourceRoot</span><span class="s2">;</span>
	    <span class="s0">mappings.map(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">var </span><span class="s0">source = mapping.source === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">._sources.at(mapping.source)</span><span class="s2">;</span>
	      <span class="s0">source = util.computeSourceURL(sourceRoot</span><span class="s2">, </span><span class="s0">source</span><span class="s2">, </span><span class="s1">this</span><span class="s0">._sourceMapURL)</span><span class="s2">;</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">source: source</span><span class="s2">,</span>
	        <span class="s0">generatedLine: mapping.generatedLine</span><span class="s2">,</span>
	        <span class="s0">generatedColumn: mapping.generatedColumn</span><span class="s2">,</span>
	        <span class="s0">originalLine: mapping.originalLine</span><span class="s2">,</span>
	        <span class="s0">originalColumn: mapping.originalColumn</span><span class="s2">,</span>
	        <span class="s0">name: mapping.name === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">._names.at(mapping.name)</span>
	      <span class="s0">}</span><span class="s2">;</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">).forEach(aCallback</span><span class="s2">, </span><span class="s0">context)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns all generated line and column information for the original source,</span>
	 <span class="s7">* line, and column provided. If no column is provided, returns all mappings</span>
	 <span class="s7">* corresponding to a either the line we are searching for or the next</span>
	 <span class="s7">* closest line that has any mappings. Otherwise, returns all mappings</span>
	 <span class="s7">* corresponding to the given line and either the column we are searching for</span>
	 <span class="s7">* or the next closest column that has any offsets.</span>
	 <span class="s7">*</span>
	 <span class="s7">* The only argument is an object with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The filename of the original source.</span>
	 <span class="s7">*   - line: The line number in the original source.  The line number is 1-based.</span>
	 <span class="s7">*   - column: Optional. the column number in the original source.</span>
	 <span class="s7">*    The column number is 0-based.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an array of objects is returned, each with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s7">*    line number is 1-based.</span>
	 <span class="s7">*   - column: The column number in the generated source, or null.</span>
	 <span class="s7">*    The column number is 0-based.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapConsumer.prototype.allGeneratedPositionsFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_allGeneratedPositionsFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">line = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">;</span>
	
	    <span class="s5">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span>
	    <span class="s5">// returns the index of the closest mapping less than the needle. By</span>
	    <span class="s5">// setting needle.originalColumn to 0, we thus find the last mapping for</span>
	    <span class="s5">// the given line, provided such a mapping exists.</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">source: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'source'</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">originalLine: line</span><span class="s2">,</span>
	      <span class="s0">originalColumn: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'column'</span><span class="s2">, </span><span class="s6">0</span><span class="s0">)</span>
	    <span class="s0">}</span><span class="s2">;</span>
	
	    <span class="s0">needle.source = </span><span class="s1">this</span><span class="s0">._findSourceIndex(needle.source)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(needle.source &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">[]</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">mappings = []</span><span class="s2">;</span>
	
	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(needle</span><span class="s2">,</span>
	                                  <span class="s1">this</span><span class="s0">._originalMappings</span><span class="s2">,</span>
	                                  <span class="s3">&quot;originalLine&quot;</span><span class="s2">,</span>
	                                  <span class="s3">&quot;originalColumn&quot;</span><span class="s2">,</span>
	                                  <span class="s0">util.compareByOriginalPositions</span><span class="s2">,</span>
	                                  <span class="s0">binarySearch.LEAST_UPPER_BOUND)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[index]</span><span class="s2">;</span>
	
	      <span class="s1">if </span><span class="s0">(aArgs.column === undefined) {</span>
	        <span class="s1">var </span><span class="s0">originalLine = mapping.originalLine</span><span class="s2">;</span>
	
	        <span class="s5">// Iterate until either we run out of mappings, or we run into</span>
	        <span class="s5">// a mapping for a different line than the one we found. Since</span>
	        <span class="s5">// mappings are sorted, this is guaranteed to find all mappings for</span>
	        <span class="s5">// the line we found.</span>
	        <span class="s1">while </span><span class="s0">(mapping &amp;&amp; mapping.originalLine === originalLine) {</span>
	          <span class="s0">mappings.push({</span>
	            <span class="s0">line: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedLine'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	            <span class="s0">column: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	            <span class="s0">lastColumn: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span>
	          <span class="s0">})</span><span class="s2">;</span>
	
	          <span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[++index]</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">var </span><span class="s0">originalColumn = mapping.originalColumn</span><span class="s2">;</span>
	
	        <span class="s5">// Iterate until either we run out of mappings, or we run into</span>
	        <span class="s5">// a mapping for a different line than the one we were searching for.</span>
	        <span class="s5">// Since mappings are sorted, this is guaranteed to find all mappings for</span>
	        <span class="s5">// the line we are searching for.</span>
	        <span class="s1">while </span><span class="s0">(mapping &amp;&amp;</span>
	               <span class="s0">mapping.originalLine === line &amp;&amp;</span>
	               <span class="s0">mapping.originalColumn == originalColumn) {</span>
	          <span class="s0">mappings.push({</span>
	            <span class="s0">line: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedLine'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	            <span class="s0">column: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	            <span class="s0">lastColumn: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span>
	          <span class="s0">})</span><span class="s2">;</span>
	
	          <span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[++index]</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">mappings</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">exports.SourceMapConsumer = SourceMapConsumer</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* A BasicSourceMapConsumer instance represents a parsed source map which we can</span>
	 <span class="s7">* query for information about the original file positions by giving it a file</span>
	 <span class="s7">* position in the generated source.</span>
	 <span class="s7">*</span>
	 <span class="s7">* The first parameter is the raw source map (either as a JSON string, or</span>
	 <span class="s7">* already parsed to an object). According to the spec, source maps have the</span>
	 <span class="s7">* following attributes:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - version: Which version of the source map spec this map is following.</span>
	 <span class="s7">*   - sources: An array of URLs to the original source files.</span>
	 <span class="s7">*   - names: An array of identifiers which can be referrenced by individual mappings.</span>
	 <span class="s7">*   - sourceRoot: Optional. The URL root from which all sources are relative.</span>
	 <span class="s7">*   - sourcesContent: Optional. An array of contents of the original source files.</span>
	 <span class="s7">*   - mappings: A string of base64 VLQs which contain the actual mappings.</span>
	 <span class="s7">*   - file: Optional. The generated file this source map is associated with.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Here is an example source map, taken from the source map spec[0]:</span>
	 <span class="s7">*</span>
	 <span class="s7">*     {</span>
	 <span class="s7">*       version : 3,</span>
	 <span class="s7">*       file: &quot;out.js&quot;,</span>
	 <span class="s7">*       sourceRoot : &quot;&quot;,</span>
	 <span class="s7">*       sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span>
	 <span class="s7">*       names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span>
	 <span class="s7">*       mappings: &quot;AA,AB;;ABCDE;&quot;</span>
	 <span class="s7">*     }</span>
	 <span class="s7">*</span>
	 <span class="s7">* The second parameter, if given, is a string whose value is the URL</span>
	 <span class="s7">* at which the source map was found.  This URL is used to compute the</span>
	 <span class="s7">* sources array.</span>
	 <span class="s7">*</span>
	 <span class="s7">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">BasicSourceMapConsumer(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">version = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'version'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sources = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'sources'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s5">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span>
	  <span class="s5">// requires the array) to play nice here.</span>
	  <span class="s1">var </span><span class="s0">names = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'names'</span><span class="s2">, </span><span class="s0">[])</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sourceRoot = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'sourceRoot'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sourcesContent = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'sourcesContent'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">mappings = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'mappings'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">file = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'file'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	
	  <span class="s5">// Once again, Sass deviates from the spec and supplies the version as a</span>
	  <span class="s5">// string rather than a number, so we use loose equality checking here.</span>
	  <span class="s1">if </span><span class="s0">(version != </span><span class="s1">this</span><span class="s0">._version) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Unsupported version: ' </span><span class="s0">+ version)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(sourceRoot) {</span>
	    <span class="s0">sourceRoot = util.normalize(sourceRoot)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s0">sources = sources</span>
	    <span class="s0">.map(String)</span>
	    <span class="s5">// Some source maps produce relative source paths like &quot;./foo.js&quot; instead of</span>
	    <span class="s5">// &quot;foo.js&quot;.  Normalize these first so that future comparisons will succeed.</span>
	    <span class="s5">// See bugzil.la/1090768.</span>
	    <span class="s0">.map(util.normalize)</span>
	    <span class="s5">// Always ensure that absolute sources are internally stored relative to</span>
	    <span class="s5">// the source root, if the source root is absolute. Not doing this would</span>
	    <span class="s5">// be particularly problematic when the source root is a prefix of the</span>
	    <span class="s5">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span>
	    <span class="s0">.map(</span><span class="s1">function </span><span class="s0">(source) {</span>
	      <span class="s1">return </span><span class="s0">sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)</span>
	        <span class="s0">? util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">source)</span>
	        <span class="s0">: source</span><span class="s2">;</span>
	    <span class="s0">})</span><span class="s2">;</span>
	
	  <span class="s5">// Pass `true` below to allow duplicate names and sources. While source maps</span>
	  <span class="s5">// are intended to be compressed and deduplicated, the TypeScript compiler</span>
	  <span class="s5">// sometimes generates source maps with duplicates in them. See Github issue</span>
	  <span class="s5">// #72 and bugzil.la/889492.</span>
	  <span class="s1">this</span><span class="s0">._names = ArraySet.fromArray(names.map(String)</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sources = ArraySet.fromArray(sources</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	
	  <span class="s1">this</span><span class="s0">._absoluteSources = </span><span class="s1">this</span><span class="s0">._sources.toArray().map(</span><span class="s1">function </span><span class="s0">(s) {</span>
	    <span class="s1">return </span><span class="s0">util.computeSourceURL(sourceRoot</span><span class="s2">, </span><span class="s0">s</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span><span class="s2">;</span>
	  <span class="s0">})</span><span class="s2">;</span>
	
	  <span class="s1">this</span><span class="s0">.sourceRoot = sourceRoot</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.sourcesContent = sourcesContent</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._mappings = mappings</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sourceMapURL = aSourceMapURL</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.file = file</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s0">BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype)</span><span class="s2">;</span>
	<span class="s0">BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Utility function to find the index of a source.  Returns -1 if not</span>
	 <span class="s7">* found.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype._findSourceIndex = </span><span class="s1">function</span><span class="s0">(aSource) {</span>
	  <span class="s1">var </span><span class="s0">relativeSource = aSource</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s0">relativeSource = util.relative(</span><span class="s1">this</span><span class="s0">.sourceRoot</span><span class="s2">, </span><span class="s0">relativeSource)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sources.has(relativeSource)) {</span>
	    <span class="s1">return this</span><span class="s0">._sources.indexOf(relativeSource)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// Maybe aSource is an absolute URL as returned by |sources|.  In</span>
	  <span class="s5">// this case we can't simply undo the transform.</span>
	  <span class="s1">var </span><span class="s0">i</span><span class="s2">;</span>
	  <span class="s1">for </span><span class="s0">(i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._absoluteSources.length</span><span class="s2">; </span><span class="s0">++i) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._absoluteSources[i] == aSource) {</span>
	      <span class="s1">return </span><span class="s0">i</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Create a BasicSourceMapConsumer from a SourceMapGenerator.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">SourceMapGenerator aSourceMap</span>
	 <span class="s7">*        The source map that will be consumed.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aSourceMapURL</span>
	 <span class="s7">*        The URL at which the source map can be found (optional)</span>
	 <span class="s7">* </span><span class="s8">@returns </span><span class="s7">BasicSourceMapConsumer</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.fromSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_fromSourceMap(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	    <span class="s1">var </span><span class="s0">smc = Object.create(BasicSourceMapConsumer.prototype)</span><span class="s2">;</span>
	
	    <span class="s1">var </span><span class="s0">names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray()</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray()</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">smc.sourceRoot = aSourceMap._sourceRoot</span><span class="s2">;</span>
	    <span class="s0">smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray()</span><span class="s2">,</span>
	                                                            <span class="s0">smc.sourceRoot)</span><span class="s2">;</span>
	    <span class="s0">smc.file = aSourceMap._file</span><span class="s2">;</span>
	    <span class="s0">smc._sourceMapURL = aSourceMapURL</span><span class="s2">;</span>
	    <span class="s0">smc._absoluteSources = smc._sources.toArray().map(</span><span class="s1">function </span><span class="s0">(s) {</span>
	      <span class="s1">return </span><span class="s0">util.computeSourceURL(smc.sourceRoot</span><span class="s2">, </span><span class="s0">s</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span><span class="s2">;</span>
	    <span class="s0">})</span><span class="s2">;</span>
	
	    <span class="s5">// Because we are modifying the entries (by converting string sources and</span>
	    <span class="s5">// names to indices into the sources and names ArraySets), we have to make</span>
	    <span class="s5">// a copy of the entry or else bad things happen. Shared mutable state</span>
	    <span class="s5">// strikes again! See github issue #191.</span>
	
	    <span class="s1">var </span><span class="s0">generatedMappings = aSourceMap._mappings.toArray().slice()</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">destGeneratedMappings = smc.__generatedMappings = []</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">destOriginalMappings = smc.__originalMappings = []</span><span class="s2">;</span>
	
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">length = generatedMappings.length</span><span class="s2">; </span><span class="s0">i &lt; length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">var </span><span class="s0">srcMapping = generatedMappings[i]</span><span class="s2">;</span>
	      <span class="s1">var </span><span class="s0">destMapping = </span><span class="s1">new </span><span class="s0">Mapping</span><span class="s2">;</span>
	      <span class="s0">destMapping.generatedLine = srcMapping.generatedLine</span><span class="s2">;</span>
	      <span class="s0">destMapping.generatedColumn = srcMapping.generatedColumn</span><span class="s2">;</span>
	
	      <span class="s1">if </span><span class="s0">(srcMapping.source) {</span>
	        <span class="s0">destMapping.source = sources.indexOf(srcMapping.source)</span><span class="s2">;</span>
	        <span class="s0">destMapping.originalLine = srcMapping.originalLine</span><span class="s2">;</span>
	        <span class="s0">destMapping.originalColumn = srcMapping.originalColumn</span><span class="s2">;</span>
	
	        <span class="s1">if </span><span class="s0">(srcMapping.name) {</span>
	          <span class="s0">destMapping.name = names.indexOf(srcMapping.name)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	
	        <span class="s0">destOriginalMappings.push(destMapping)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	
	      <span class="s0">destGeneratedMappings.push(destMapping)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s0">quickSort(smc.__originalMappings</span><span class="s2">, </span><span class="s0">util.compareByOriginalPositions)</span><span class="s2">;</span>
	
	    <span class="s1">return </span><span class="s0">smc</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype._version = </span><span class="s6">3</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* The list of original sources.</span>
	 <span class="s7">*/</span>
	<span class="s0">Object.defineProperty(BasicSourceMapConsumer.prototype</span><span class="s2">, </span><span class="s3">'sources'</span><span class="s2">, </span><span class="s0">{</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">return this</span><span class="s0">._absoluteSources.slice()</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">})</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Provide the JIT with a nice shape / hidden class.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">Mapping() {</span>
	  <span class="s1">this</span><span class="s0">.generatedLine = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.generatedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.source = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.originalLine = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.originalColumn = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.name = </span><span class="s1">null</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s7">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s7">* `this.__originalMappings` properties).</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_parseMappings(aStr</span><span class="s2">, </span><span class="s0">aSourceRoot) {</span>
	    <span class="s1">var </span><span class="s0">generatedLine = </span><span class="s6">1</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalLine = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalColumn = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousSource = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousName = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">length = aStr.length</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">index = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">cachedSegments = {}</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">temp = {}</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">originalMappings = []</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">generatedMappings = []</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">mapping</span><span class="s2">, </span><span class="s0">str</span><span class="s2">, </span><span class="s0">segment</span><span class="s2">, </span><span class="s0">end</span><span class="s2">, </span><span class="s0">value</span><span class="s2">;</span>
	
	    <span class="s1">while </span><span class="s0">(index &lt; length) {</span>
	      <span class="s1">if </span><span class="s0">(aStr.charAt(index) === </span><span class="s3">';'</span><span class="s0">) {</span>
	        <span class="s0">generatedLine++</span><span class="s2">;</span>
	        <span class="s0">index++</span><span class="s2">;</span>
	        <span class="s0">previousGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">else if </span><span class="s0">(aStr.charAt(index) === </span><span class="s3">','</span><span class="s0">) {</span>
	        <span class="s0">index++</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">mapping = </span><span class="s1">new </span><span class="s0">Mapping()</span><span class="s2">;</span>
	        <span class="s0">mapping.generatedLine = generatedLine</span><span class="s2">;</span>
	
	        <span class="s5">// Because each offset is encoded relative to the previous one,</span>
	        <span class="s5">// many segments often have the same encoding. We can exploit this</span>
	        <span class="s5">// fact by caching the parsed variable length fields of each segment,</span>
	        <span class="s5">// allowing us to avoid a second parse if we encounter the same</span>
	        <span class="s5">// segment again.</span>
	        <span class="s1">for </span><span class="s0">(end = index</span><span class="s2">; </span><span class="s0">end &lt; length</span><span class="s2">; </span><span class="s0">end++) {</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._charIsMappingSeparator(aStr</span><span class="s2">, </span><span class="s0">end)) {</span>
	            <span class="s1">break</span><span class="s2">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	        <span class="s0">str = aStr.slice(index</span><span class="s2">, </span><span class="s0">end)</span><span class="s2">;</span>
	
	        <span class="s0">segment = cachedSegments[str]</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(segment) {</span>
	          <span class="s0">index += str.length</span><span class="s2">;</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s0">segment = []</span><span class="s2">;</span>
	          <span class="s1">while </span><span class="s0">(index &lt; end) {</span>
	            <span class="s0">base64VLQ.decode(aStr</span><span class="s2">, </span><span class="s0">index</span><span class="s2">, </span><span class="s0">temp)</span><span class="s2">;</span>
	            <span class="s0">value = temp.value</span><span class="s2">;</span>
	            <span class="s0">index = temp.rest</span><span class="s2">;</span>
	            <span class="s0">segment.push(value)</span><span class="s2">;</span>
	          <span class="s0">}</span>
	
	          <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s6">2</span><span class="s0">) {</span>
	            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Found a source, but no line and column'</span><span class="s0">)</span><span class="s2">;</span>
	          <span class="s0">}</span>
	
	          <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s6">3</span><span class="s0">) {</span>
	            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Found a source and line, but no column'</span><span class="s0">)</span><span class="s2">;</span>
	          <span class="s0">}</span>
	
	          <span class="s0">cachedSegments[str] = segment</span><span class="s2">;</span>
	        <span class="s0">}</span>
	
	        <span class="s5">// Generated column.</span>
	        <span class="s0">mapping.generatedColumn = previousGeneratedColumn + segment[</span><span class="s6">0</span><span class="s0">]</span><span class="s2">;</span>
	        <span class="s0">previousGeneratedColumn = mapping.generatedColumn</span><span class="s2">;</span>
	
	        <span class="s1">if </span><span class="s0">(segment.length &gt; </span><span class="s6">1</span><span class="s0">) {</span>
	          <span class="s5">// Original source.</span>
	          <span class="s0">mapping.source = previousSource + segment[</span><span class="s6">1</span><span class="s0">]</span><span class="s2">;</span>
	          <span class="s0">previousSource += segment[</span><span class="s6">1</span><span class="s0">]</span><span class="s2">;</span>
	
	          <span class="s5">// Original line.</span>
	          <span class="s0">mapping.originalLine = previousOriginalLine + segment[</span><span class="s6">2</span><span class="s0">]</span><span class="s2">;</span>
	          <span class="s0">previousOriginalLine = mapping.originalLine</span><span class="s2">;</span>
	          <span class="s5">// Lines are stored 0-based</span>
	          <span class="s0">mapping.originalLine += </span><span class="s6">1</span><span class="s2">;</span>
	
	          <span class="s5">// Original column.</span>
	          <span class="s0">mapping.originalColumn = previousOriginalColumn + segment[</span><span class="s6">3</span><span class="s0">]</span><span class="s2">;</span>
	          <span class="s0">previousOriginalColumn = mapping.originalColumn</span><span class="s2">;</span>
	
	          <span class="s1">if </span><span class="s0">(segment.length &gt; </span><span class="s6">4</span><span class="s0">) {</span>
	            <span class="s5">// Original name.</span>
	            <span class="s0">mapping.name = previousName + segment[</span><span class="s6">4</span><span class="s0">]</span><span class="s2">;</span>
	            <span class="s0">previousName += segment[</span><span class="s6">4</span><span class="s0">]</span><span class="s2">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	
	        <span class="s0">generatedMappings.push(mapping)</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">mapping.originalLine === </span><span class="s3">'number'</span><span class="s0">) {</span>
	          <span class="s0">originalMappings.push(mapping)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s0">quickSort(generatedMappings</span><span class="s2">, </span><span class="s0">util.compareByGeneratedPositionsDeflated)</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">.__generatedMappings = generatedMappings</span><span class="s2">;</span>
	
	    <span class="s0">quickSort(originalMappings</span><span class="s2">, </span><span class="s0">util.compareByOriginalPositions)</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">.__originalMappings = originalMappings</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that</span>
	 <span class="s7">* we are searching for in the given &quot;haystack&quot; of mappings.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype._findMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_findMapping(aNeedle</span><span class="s2">, </span><span class="s0">aMappings</span><span class="s2">, </span><span class="s0">aLineName</span><span class="s2">,</span>
	                                         <span class="s0">aColumnName</span><span class="s2">, </span><span class="s0">aComparator</span><span class="s2">, </span><span class="s0">aBias) {</span>
	    <span class="s5">// To return the position we are searching for, we must first find the</span>
	    <span class="s5">// mapping for the given position and then return the opposite position it</span>
	    <span class="s5">// points to. Because the mappings are sorted, we can use binary search to</span>
	    <span class="s5">// find the best mapping.</span>
	
	    <span class="s1">if </span><span class="s0">(aNeedle[aLineName] &lt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">'Line must be greater than or equal to 1, got '</span>
	                          <span class="s0">+ aNeedle[aLineName])</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(aNeedle[aColumnName] &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">'Column must be greater than or equal to 0, got '</span>
	                          <span class="s0">+ aNeedle[aColumnName])</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">binarySearch.search(aNeedle</span><span class="s2">, </span><span class="s0">aMappings</span><span class="s2">, </span><span class="s0">aComparator</span><span class="s2">, </span><span class="s0">aBias)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Compute the last column for each generated mapping. The last column is</span>
	 <span class="s7">* inclusive.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.computeColumnSpans =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_computeColumnSpans() {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">index = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">index &lt; </span><span class="s1">this</span><span class="s0">._generatedMappings.length</span><span class="s2">; </span><span class="s0">++index) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index]</span><span class="s2">;</span>
	
	      <span class="s5">// Mappings do not contain a field for the last generated columnt. We</span>
	      <span class="s5">// can come up with an optimistic estimate, however, by assuming that</span>
	      <span class="s5">// mappings are contiguous (i.e. given two consecutive mappings, the</span>
	      <span class="s5">// first mapping ends where the second one starts).</span>
	      <span class="s1">if </span><span class="s0">(index + </span><span class="s6">1 </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">._generatedMappings.length) {</span>
	        <span class="s1">var </span><span class="s0">nextMapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index + </span><span class="s6">1</span><span class="s0">]</span><span class="s2">;</span>
	
	        <span class="s1">if </span><span class="s0">(mapping.generatedLine === nextMapping.generatedLine) {</span>
	          <span class="s0">mapping.lastGeneratedColumn = nextMapping.generatedColumn - </span><span class="s6">1</span><span class="s2">;</span>
	          <span class="s1">continue</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	
	      <span class="s5">// The last mapping for each line spans the entire line.</span>
	      <span class="s0">mapping.lastGeneratedColumn = Infinity</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the original source, line, and column information for the generated</span>
	 <span class="s7">* source's line and column positions provided. The only argument is an object</span>
	 <span class="s7">* with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source.  The line number</span>
	 <span class="s7">*     is 1-based.</span>
	 <span class="s7">*   - column: The column number in the generated source.  The column</span>
	 <span class="s7">*     number is 0-based.</span>
	 <span class="s7">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span>
	 <span class="s7">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s7">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s7">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s7">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an object is returned with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The original source file, or null.</span>
	 <span class="s7">*   - line: The line number in the original source, or null.  The</span>
	 <span class="s7">*     line number is 1-based.</span>
	 <span class="s7">*   - column: The column number in the original source, or null.  The</span>
	 <span class="s7">*     column number is 0-based.</span>
	 <span class="s7">*   - name: The original identifier, or null.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.originalPositionFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_originalPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">generatedLine: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">generatedColumn: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">}</span><span class="s2">;</span>
	
	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(</span>
	      <span class="s0">needle</span><span class="s2">,</span>
	      <span class="s1">this</span><span class="s0">._generatedMappings</span><span class="s2">,</span>
	      <span class="s3">&quot;generatedLine&quot;</span><span class="s2">,</span>
	      <span class="s3">&quot;generatedColumn&quot;</span><span class="s2">,</span>
	      <span class="s0">util.compareByGeneratedPositionsDeflated</span><span class="s2">,</span>
	      <span class="s0">util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'bias'</span><span class="s2">, </span><span class="s0">SourceMapConsumer.GREATEST_LOWER_BOUND)</span>
	    <span class="s0">)</span><span class="s2">;</span>
	
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index]</span><span class="s2">;</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.generatedLine === needle.generatedLine) {</span>
	        <span class="s1">var </span><span class="s0">source = util.getArg(mapping</span><span class="s2">, </span><span class="s3">'source'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(source !== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">source = </span><span class="s1">this</span><span class="s0">._sources.at(source)</span><span class="s2">;</span>
	          <span class="s0">source = util.computeSourceURL(</span><span class="s1">this</span><span class="s0">.sourceRoot</span><span class="s2">, </span><span class="s0">source</span><span class="s2">, </span><span class="s1">this</span><span class="s0">._sourceMapURL)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s1">var </span><span class="s0">name = util.getArg(mapping</span><span class="s2">, </span><span class="s3">'name'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(name !== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">name = </span><span class="s1">this</span><span class="s0">._names.at(name)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s0">source: source</span><span class="s2">,</span>
	          <span class="s0">line: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'originalLine'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">column: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'originalColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">name: name</span>
	        <span class="s0">}</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">source: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">column: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">name: </span><span class="s1">null</span>
	    <span class="s0">}</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Return true if we have the source content for every source in the source</span>
	 <span class="s7">* map, false otherwise.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.hasContentsOfAllSources =</span>
	  <span class="s1">function </span><span class="s0">BasicSourceMapConsumer_hasContentsOfAllSources() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.sourcesContent) {</span>
	      <span class="s1">return false</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">return this</span><span class="s0">.sourcesContent.length &gt;= </span><span class="s1">this</span><span class="s0">._sources.size() &amp;&amp;</span>
	      <span class="s0">!</span><span class="s1">this</span><span class="s0">.sourcesContent.some(</span><span class="s1">function </span><span class="s0">(sc) { </span><span class="s1">return </span><span class="s0">sc == </span><span class="s1">null</span><span class="s2">; </span><span class="s0">})</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the original source content. The only argument is the url of the</span>
	 <span class="s7">* original source file. Returns null if no original source content is</span>
	 <span class="s7">* available.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.sourceContentFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_sourceContentFor(aSource</span><span class="s2">, </span><span class="s0">nullOnMissing) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.sourcesContent) {</span>
	      <span class="s1">return null</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findSourceIndex(aSource)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">return this</span><span class="s0">.sourcesContent[index]</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">relativeSource = aSource</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">relativeSource = util.relative(</span><span class="s1">this</span><span class="s0">.sourceRoot</span><span class="s2">, </span><span class="s0">relativeSource)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">url</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; (url = util.urlParse(</span><span class="s1">this</span><span class="s0">.sourceRoot))) {</span>
	      <span class="s5">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span>
	      <span class="s5">// many users. We can help them out when they expect file:// URIs to</span>
	      <span class="s5">// behave like it would if they were running a local HTTP server. See</span>
	      <span class="s5">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span>
	      <span class="s1">var </span><span class="s0">fileUriAbsPath = relativeSource.replace(</span><span class="s6">/^file:\/\//</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(url.scheme == </span><span class="s3">&quot;file&quot;</span>
	          <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">._sources.has(fileUriAbsPath)) {</span>
	        <span class="s1">return this</span><span class="s0">.sourcesContent[</span><span class="s1">this</span><span class="s0">._sources.indexOf(fileUriAbsPath)]</span>
	      <span class="s0">}</span>
	
	      <span class="s1">if </span><span class="s0">((!url.path || url.path == </span><span class="s3">&quot;/&quot;</span><span class="s0">)</span>
	          <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">._sources.has(</span><span class="s3">&quot;/&quot; </span><span class="s0">+ relativeSource)) {</span>
	        <span class="s1">return this</span><span class="s0">.sourcesContent[</span><span class="s1">this</span><span class="s0">._sources.indexOf(</span><span class="s3">&quot;/&quot; </span><span class="s0">+ relativeSource)]</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s5">// This function is used recursively from</span>
	    <span class="s5">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span>
	    <span class="s5">// don't want to throw if we can't find the source - we just want to</span>
	    <span class="s5">// return null, so we provide a flag to exit gracefully.</span>
	    <span class="s1">if </span><span class="s0">(nullOnMissing) {</span>
	      <span class="s1">return null</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'&quot;' </span><span class="s0">+ relativeSource + </span><span class="s3">'&quot; is not in the SourceMap.'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the generated line and column information for the original source,</span>
	 <span class="s7">* line, and column positions provided. The only argument is an object with</span>
	 <span class="s7">* the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The filename of the original source.</span>
	 <span class="s7">*   - line: The line number in the original source.  The line number</span>
	 <span class="s7">*     is 1-based.</span>
	 <span class="s7">*   - column: The column number in the original source.  The column</span>
	 <span class="s7">*     number is 0-based.</span>
	 <span class="s7">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span>
	 <span class="s7">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s7">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s7">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s7">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an object is returned with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s7">*     line number is 1-based.</span>
	 <span class="s7">*   - column: The column number in the generated source, or null.</span>
	 <span class="s7">*     The column number is 0-based.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.generatedPositionFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_generatedPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">source = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'source'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">source = </span><span class="s1">this</span><span class="s0">._findSourceIndex(source)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(source &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">column: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">lastColumn: </span><span class="s1">null</span>
	      <span class="s0">}</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">source: source</span><span class="s2">,</span>
	      <span class="s0">originalLine: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">originalColumn: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">}</span><span class="s2">;</span>
	
	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(</span>
	      <span class="s0">needle</span><span class="s2">,</span>
	      <span class="s1">this</span><span class="s0">._originalMappings</span><span class="s2">,</span>
	      <span class="s3">&quot;originalLine&quot;</span><span class="s2">,</span>
	      <span class="s3">&quot;originalColumn&quot;</span><span class="s2">,</span>
	      <span class="s0">util.compareByOriginalPositions</span><span class="s2">,</span>
	      <span class="s0">util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'bias'</span><span class="s2">, </span><span class="s0">SourceMapConsumer.GREATEST_LOWER_BOUND)</span>
	    <span class="s0">)</span><span class="s2">;</span>
	
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[index]</span><span class="s2">;</span>
	
	      <span class="s1">if </span><span class="s0">(mapping.source === needle.source) {</span>
	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s0">line: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedLine'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">column: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">lastColumn: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span>
	        <span class="s0">}</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">column: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">lastColumn: </span><span class="s1">null</span>
	    <span class="s0">}</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">exports.BasicSourceMapConsumer = BasicSourceMapConsumer</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* An IndexedSourceMapConsumer instance represents a parsed source map which</span>
	 <span class="s7">* we can query for information. It differs from BasicSourceMapConsumer in</span>
	 <span class="s7">* that it takes &quot;indexed&quot; source maps (i.e. ones with a &quot;sections&quot; field) as</span>
	 <span class="s7">* input.</span>
	 <span class="s7">*</span>
	 <span class="s7">* The first parameter is a raw source map (either as a JSON string, or already</span>
	 <span class="s7">* parsed to an object). According to the spec for indexed source maps, they</span>
	 <span class="s7">* have the following attributes:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - version: Which version of the source map spec this map is following.</span>
	 <span class="s7">*   - file: Optional. The generated file this source map is associated with.</span>
	 <span class="s7">*   - sections: A list of section definitions.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Each value under the &quot;sections&quot; field has two fields:</span>
	 <span class="s7">*   - offset: The offset into the original specified at which this section</span>
	 <span class="s7">*       begins to apply, defined as an object with a &quot;line&quot; and &quot;column&quot;</span>
	 <span class="s7">*       field.</span>
	 <span class="s7">*   - map: A source map definition. This source map could also be indexed,</span>
	 <span class="s7">*       but doesn't have to be.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Instead of the &quot;map&quot; field, it's also possible to have a &quot;url&quot; field</span>
	 <span class="s7">* specifying a URL to retrieve a source map from, but that's currently</span>
	 <span class="s7">* unsupported.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Here's an example source map, taken from the source map spec[0], but</span>
	 <span class="s7">* modified to omit a section which uses the &quot;url&quot; field.</span>
	 <span class="s7">*</span>
	 <span class="s7">*  {</span>
	 <span class="s7">*    version : 3,</span>
	 <span class="s7">*    file: &quot;app.js&quot;,</span>
	 <span class="s7">*    sections: [{</span>
	 <span class="s7">*      offset: {line:100, column:10},</span>
	 <span class="s7">*      map: {</span>
	 <span class="s7">*        version : 3,</span>
	 <span class="s7">*        file: &quot;section.js&quot;,</span>
	 <span class="s7">*        sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span>
	 <span class="s7">*        names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span>
	 <span class="s7">*        mappings: &quot;AAAA,E;;ABCDE;&quot;</span>
	 <span class="s7">*      }</span>
	 <span class="s7">*    }],</span>
	 <span class="s7">*  }</span>
	 <span class="s7">*</span>
	 <span class="s7">* The second parameter, if given, is a string whose value is the URL</span>
	 <span class="s7">* at which the source map was found.  This URL is used to compute the</span>
	 <span class="s7">* sources array.</span>
	 <span class="s7">*</span>
	 <span class="s7">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">IndexedSourceMapConsumer(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">version = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'version'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sections = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'sections'</span><span class="s0">)</span><span class="s2">;</span>
	
	  <span class="s1">if </span><span class="s0">(version != </span><span class="s1">this</span><span class="s0">._version) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Unsupported version: ' </span><span class="s0">+ version)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">this</span><span class="s0">._sources = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._names = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	
	  <span class="s1">var </span><span class="s0">lastOffset = {</span>
	    <span class="s0">line: -</span><span class="s6">1</span><span class="s2">,</span>
	    <span class="s0">column: </span><span class="s6">0</span>
	  <span class="s0">}</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sections = sections.map(</span><span class="s1">function </span><span class="s0">(s) {</span>
	    <span class="s1">if </span><span class="s0">(s.url) {</span>
	      <span class="s5">// The url field will require support for asynchronicity.</span>
	      <span class="s5">// See https://github.com/mozilla/source-map/issues/16</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Support for url field in sections not implemented.'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">var </span><span class="s0">offset = util.getArg(s</span><span class="s2">, </span><span class="s3">'offset'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">offsetLine = util.getArg(offset</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">offsetColumn = util.getArg(offset</span><span class="s2">, </span><span class="s3">'column'</span><span class="s0">)</span><span class="s2">;</span>
	
	    <span class="s1">if </span><span class="s0">(offsetLine &lt; lastOffset.line ||</span>
	        <span class="s0">(offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Section offsets must be ordered and non-overlapping.'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">lastOffset = offset</span><span class="s2">;</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">generatedOffset: {</span>
	        <span class="s5">// The offset fields are 0-based, but we use 1-based indices when</span>
	        <span class="s5">// encoding/decoding from VLQ.</span>
	        <span class="s0">generatedLine: offsetLine + </span><span class="s6">1</span><span class="s2">,</span>
	        <span class="s0">generatedColumn: offsetColumn + </span><span class="s6">1</span>
	      <span class="s0">}</span><span class="s2">,</span>
	      <span class="s0">consumer: </span><span class="s1">new </span><span class="s0">SourceMapConsumer(util.getArg(s</span><span class="s2">, </span><span class="s3">'map'</span><span class="s0">)</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span>
	    <span class="s0">}</span>
	  <span class="s0">})</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s0">IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype)</span><span class="s2">;</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype._version = </span><span class="s6">3</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* The list of original sources.</span>
	 <span class="s7">*/</span>
	<span class="s0">Object.defineProperty(IndexedSourceMapConsumer.prototype</span><span class="s2">, </span><span class="s3">'sources'</span><span class="s2">, </span><span class="s0">{</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">var </span><span class="s0">sources = []</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._sections.length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">j &lt; </span><span class="s1">this</span><span class="s0">._sections[i].consumer.sources.length</span><span class="s2">; </span><span class="s0">j++) {</span>
	        <span class="s0">sources.push(</span><span class="s1">this</span><span class="s0">._sections[i].consumer.sources[j])</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s1">return </span><span class="s0">sources</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">})</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the original source, line, and column information for the generated</span>
	 <span class="s7">* source's line and column positions provided. The only argument is an object</span>
	 <span class="s7">* with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source.  The line number</span>
	 <span class="s7">*     is 1-based.</span>
	 <span class="s7">*   - column: The column number in the generated source.  The column</span>
	 <span class="s7">*     number is 0-based.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an object is returned with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The original source file, or null.</span>
	 <span class="s7">*   - line: The line number in the original source, or null.  The</span>
	 <span class="s7">*     line number is 1-based.</span>
	 <span class="s7">*   - column: The column number in the original source, or null.  The</span>
	 <span class="s7">*     column number is 0-based.</span>
	 <span class="s7">*   - name: The original identifier, or null.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.originalPositionFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_originalPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">generatedLine: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">generatedColumn: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">}</span><span class="s2">;</span>
	
	    <span class="s5">// Find the section containing the generated position we're trying to map</span>
	    <span class="s5">// to an original position.</span>
	    <span class="s1">var </span><span class="s0">sectionIndex = binarySearch.search(needle</span><span class="s2">, </span><span class="s1">this</span><span class="s0">._sections</span><span class="s2">,</span>
	      <span class="s1">function</span><span class="s0">(needle</span><span class="s2">, </span><span class="s0">section) {</span>
	        <span class="s1">var </span><span class="s0">cmp = needle.generatedLine - section.generatedOffset.generatedLine</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(cmp) {</span>
	          <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	        <span class="s0">}</span>
	
	        <span class="s1">return </span><span class="s0">(needle.generatedColumn -</span>
	                <span class="s0">section.generatedOffset.generatedColumn)</span><span class="s2">;</span>
	      <span class="s0">})</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[sectionIndex]</span><span class="s2">;</span>
	
	    <span class="s1">if </span><span class="s0">(!section) {</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">source: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">column: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">name: </span><span class="s1">null</span>
	      <span class="s0">}</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">section.consumer.originalPositionFor({</span>
	      <span class="s0">line: needle.generatedLine -</span>
	        <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">column: needle.generatedColumn -</span>
	        <span class="s0">(section.generatedOffset.generatedLine === needle.generatedLine</span>
	         <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s6">1</span>
	         <span class="s0">: </span><span class="s6">0</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">bias: aArgs.bias</span>
	    <span class="s0">})</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Return true if we have the source content for every source in the source</span>
	 <span class="s7">* map, false otherwise.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_hasContentsOfAllSources() {</span>
	    <span class="s1">return this</span><span class="s0">._sections.every(</span><span class="s1">function </span><span class="s0">(s) {</span>
	      <span class="s1">return </span><span class="s0">s.consumer.hasContentsOfAllSources()</span><span class="s2">;</span>
	    <span class="s0">})</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the original source content. The only argument is the url of the</span>
	 <span class="s7">* original source file. Returns null if no original source content is</span>
	 <span class="s7">* available.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.sourceContentFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_sourceContentFor(aSource</span><span class="s2">, </span><span class="s0">nullOnMissing) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._sections.length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i]</span><span class="s2">;</span>
	
	      <span class="s1">var </span><span class="s0">content = section.consumer.sourceContentFor(aSource</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(content) {</span>
	        <span class="s1">return </span><span class="s0">content</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(nullOnMissing) {</span>
	      <span class="s1">return null</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'&quot;' </span><span class="s0">+ aSource + </span><span class="s3">'&quot; is not in the SourceMap.'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the generated line and column information for the original source,</span>
	 <span class="s7">* line, and column positions provided. The only argument is an object with</span>
	 <span class="s7">* the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The filename of the original source.</span>
	 <span class="s7">*   - line: The line number in the original source.  The line number</span>
	 <span class="s7">*     is 1-based.</span>
	 <span class="s7">*   - column: The column number in the original source.  The column</span>
	 <span class="s7">*     number is 0-based.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an object is returned with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s7">*     line number is 1-based. </span>
	 <span class="s7">*   - column: The column number in the generated source, or null.</span>
	 <span class="s7">*     The column number is 0-based.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.generatedPositionFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_generatedPositionFor(aArgs) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._sections.length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i]</span><span class="s2">;</span>
	
	      <span class="s5">// Only consider this section if the requested source is in the list of</span>
	      <span class="s5">// sources of the consumer.</span>
	      <span class="s1">if </span><span class="s0">(section.consumer._findSourceIndex(util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'source'</span><span class="s0">)) === -</span><span class="s6">1</span><span class="s0">) {</span>
	        <span class="s1">continue</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">var </span><span class="s0">generatedPosition = section.consumer.generatedPositionFor(aArgs)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(generatedPosition) {</span>
	        <span class="s1">var </span><span class="s0">ret = {</span>
	          <span class="s0">line: generatedPosition.line +</span>
	            <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">column: generatedPosition.column +</span>
	            <span class="s0">(section.generatedOffset.generatedLine === generatedPosition.line</span>
	             <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s6">1</span>
	             <span class="s0">: </span><span class="s6">0</span><span class="s0">)</span>
	        <span class="s0">}</span><span class="s2">;</span>
	        <span class="s1">return </span><span class="s0">ret</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">column: </span><span class="s1">null</span>
	    <span class="s0">}</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s7">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s7">* `this.__originalMappings` properties).</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_parseMappings(aStr</span><span class="s2">, </span><span class="s0">aSourceRoot) {</span>
	    <span class="s1">this</span><span class="s0">.__generatedMappings = []</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">.__originalMappings = []</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._sections.length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i]</span><span class="s2">;</span>
	      <span class="s1">var </span><span class="s0">sectionMappings = section.consumer._generatedMappings</span><span class="s2">;</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">j &lt; sectionMappings.length</span><span class="s2">; </span><span class="s0">j++) {</span>
	        <span class="s1">var </span><span class="s0">mapping = sectionMappings[j]</span><span class="s2">;</span>
	
	        <span class="s1">var </span><span class="s0">source = section.consumer._sources.at(mapping.source)</span><span class="s2">;</span>
	        <span class="s0">source = util.computeSourceURL(section.consumer.sourceRoot</span><span class="s2">, </span><span class="s0">source</span><span class="s2">, </span><span class="s1">this</span><span class="s0">._sourceMapURL)</span><span class="s2">;</span>
	        <span class="s1">this</span><span class="s0">._sources.add(source)</span><span class="s2">;</span>
	        <span class="s0">source = </span><span class="s1">this</span><span class="s0">._sources.indexOf(source)</span><span class="s2">;</span>
	
	        <span class="s1">var </span><span class="s0">name = </span><span class="s1">null</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(mapping.name) {</span>
	          <span class="s0">name = section.consumer._names.at(mapping.name)</span><span class="s2">;</span>
	          <span class="s1">this</span><span class="s0">._names.add(name)</span><span class="s2">;</span>
	          <span class="s0">name = </span><span class="s1">this</span><span class="s0">._names.indexOf(name)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	
	        <span class="s5">// The mappings coming from the consumer for the section have</span>
	        <span class="s5">// generated positions relative to the start of the section, so we</span>
	        <span class="s5">// need to offset them to be relative to the start of the concatenated</span>
	        <span class="s5">// generated file.</span>
	        <span class="s1">var </span><span class="s0">adjustedMapping = {</span>
	          <span class="s0">source: source</span><span class="s2">,</span>
	          <span class="s0">generatedLine: mapping.generatedLine +</span>
	            <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">generatedColumn: mapping.generatedColumn +</span>
	            <span class="s0">(section.generatedOffset.generatedLine === mapping.generatedLine</span>
	            <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s6">1</span>
	            <span class="s0">: </span><span class="s6">0</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">originalLine: mapping.originalLine</span><span class="s2">,</span>
	          <span class="s0">originalColumn: mapping.originalColumn</span><span class="s2">,</span>
	          <span class="s0">name: name</span>
	        <span class="s0">}</span><span class="s2">;</span>
	
	        <span class="s1">this</span><span class="s0">.__generatedMappings.push(adjustedMapping)</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">adjustedMapping.originalLine === </span><span class="s3">'number'</span><span class="s0">) {</span>
	          <span class="s1">this</span><span class="s0">.__originalMappings.push(adjustedMapping)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s0">quickSort(</span><span class="s1">this</span><span class="s0">.__generatedMappings</span><span class="s2">, </span><span class="s0">util.compareByGeneratedPositionsDeflated)</span><span class="s2">;</span>
	    <span class="s0">quickSort(</span><span class="s1">this</span><span class="s0">.__originalMappings</span><span class="s2">, </span><span class="s0">util.compareByOriginalPositions)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 8 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s0">exports.GREATEST_LOWER_BOUND = </span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">exports.LEAST_UPPER_BOUND = </span><span class="s6">2</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Recursive implementation of binary search.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aLow Indices here and lower do not contain the needle.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aHigh Indices here and higher do not contain the needle.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aNeedle The element being searched for.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aHaystack The non-empty array being searched.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aCompare Function which takes two elements and returns -1, 0, or 1.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span>
	 <span class="s7">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s7">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s7">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">recursiveSearch(aLow</span><span class="s2">, </span><span class="s0">aHigh</span><span class="s2">, </span><span class="s0">aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">, </span><span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias) {</span>
	  <span class="s5">// This function terminates when one of the following is true:</span>
	  <span class="s5">//</span>
	  <span class="s5">//   1. We find the exact element we are looking for.</span>
	  <span class="s5">//</span>
	  <span class="s5">//   2. We did not find the exact element, but we can return the index of</span>
	  <span class="s5">//      the next-closest element.</span>
	  <span class="s5">//</span>
	  <span class="s5">//   3. We did not find the exact element, and there is no next-closest</span>
	  <span class="s5">//      element than the one we are searching for, so we return -1.</span>
	  <span class="s1">var </span><span class="s0">mid = Math.floor((aHigh - aLow) / </span><span class="s6">2</span><span class="s0">) + aLow</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">cmp = aCompare(aNeedle</span><span class="s2">, </span><span class="s0">aHaystack[mid]</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp === </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s5">// Found the element we are looking for.</span>
	    <span class="s1">return </span><span class="s0">mid</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(cmp &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s5">// Our needle is greater than aHaystack[mid].</span>
	    <span class="s1">if </span><span class="s0">(aHigh - mid &gt; </span><span class="s6">1</span><span class="s0">) {</span>
	      <span class="s5">// The element is in the upper half.</span>
	      <span class="s1">return </span><span class="s0">recursiveSearch(mid</span><span class="s2">, </span><span class="s0">aHigh</span><span class="s2">, </span><span class="s0">aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">, </span><span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s5">// The exact needle element was not found in this haystack. Determine if</span>
	    <span class="s5">// we are in termination case (3) or (2) and return the appropriate thing.</span>
	    <span class="s1">if </span><span class="s0">(aBias == exports.LEAST_UPPER_BOUND) {</span>
	      <span class="s1">return </span><span class="s0">aHigh &lt; aHaystack.length ? aHigh : -</span><span class="s6">1</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">return </span><span class="s0">mid</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s5">// Our needle is less than aHaystack[mid].</span>
	    <span class="s1">if </span><span class="s0">(mid - aLow &gt; </span><span class="s6">1</span><span class="s0">) {</span>
	      <span class="s5">// The element is in the lower half.</span>
	      <span class="s1">return </span><span class="s0">recursiveSearch(aLow</span><span class="s2">, </span><span class="s0">mid</span><span class="s2">, </span><span class="s0">aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">, </span><span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s5">// we are in termination case (3) or (2) and return the appropriate thing.</span>
	    <span class="s1">if </span><span class="s0">(aBias == exports.LEAST_UPPER_BOUND) {</span>
	      <span class="s1">return </span><span class="s0">mid</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">return </span><span class="s0">aLow &lt; </span><span class="s6">0 </span><span class="s0">? -</span><span class="s6">1 </span><span class="s0">: aLow</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* This is an implementation of binary search which will always try and return</span>
	 <span class="s7">* the index of the closest element if there is no exact hit. This is because</span>
	 <span class="s7">* mappings between original and generated line/col pairs are single points,</span>
	 <span class="s7">* and there is an implicit region between each of them, so a miss just means</span>
	 <span class="s7">* that you aren't on the very start of a region.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aNeedle The element you are looking for.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aHaystack The array that is being searched.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aCompare A function which takes the needle and an element in the</span>
	 <span class="s7">*     array and returns -1, 0, or 1 depending on whether the needle is less</span>
	 <span class="s7">*     than, equal to, or greater than the element, respectively.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span>
	 <span class="s7">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s7">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s7">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s7">*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.search = </span><span class="s1">function </span><span class="s0">search(aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">, </span><span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias) {</span>
	  <span class="s1">if </span><span class="s0">(aHaystack.length === </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">var </span><span class="s0">index = recursiveSearch(-</span><span class="s6">1</span><span class="s2">, </span><span class="s0">aHaystack.length</span><span class="s2">, </span><span class="s0">aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">,</span>
	                              <span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias || exports.GREATEST_LOWER_BOUND)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s5">// We have found either the exact element, or the next-closest element than</span>
	  <span class="s5">// the one we are searching for. However, there may be more than one such</span>
	  <span class="s5">// element. Make sure we always return the smallest of these.</span>
	  <span class="s1">while </span><span class="s0">(index - </span><span class="s6">1 </span><span class="s0">&gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(aCompare(aHaystack[index]</span><span class="s2">, </span><span class="s0">aHaystack[index - </span><span class="s6">1</span><span class="s0">]</span><span class="s2">, </span><span class="s1">true</span><span class="s0">) !== </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">break</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">--index</span><span class="s2">;</span>
	  <span class="s0">}</span>
	
	  <span class="s1">return </span><span class="s0">index</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 9 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s5">// It turns out that some (most?) JavaScript engines don't self-host</span>
	<span class="s5">// `Array.prototype.sort`. This makes sense because C++ will likely remain</span>
	<span class="s5">// faster than JS when doing raw CPU-intensive sorting. However, when using a</span>
	<span class="s5">// custom comparator function, calling back and forth between the VM's C++ and</span>
	<span class="s5">// JIT'd JS is rather slow *and* loses JIT type information, resulting in</span>
	<span class="s5">// worse generated code for the comparator function than would be optimal. In</span>
	<span class="s5">// fact, when sorting with a comparator, these costs outweigh the benefits of</span>
	<span class="s5">// sorting in C++. By using our own JS-implemented Quick Sort (below), we get</span>
	<span class="s5">// a ~3500ms mean speed-up in `bench/bench.html`.</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Swap the elements indexed by `x` and `y` in the array `ary`.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Array} ary</span>
	 <span class="s7">*        The array.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} x</span>
	 <span class="s7">*        The index of the first item.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} y</span>
	 <span class="s7">*        The index of the second item.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">swap(ary</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">y) {</span>
	  <span class="s1">var </span><span class="s0">temp = ary[x]</span><span class="s2">;</span>
	  <span class="s0">ary[x] = ary[y]</span><span class="s2">;</span>
	  <span class="s0">ary[y] = temp</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns a random integer within the range `low .. high` inclusive.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} low</span>
	 <span class="s7">*        The lower bound on the range.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} high</span>
	 <span class="s7">*        The upper bound on the range.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">randomIntInRange(low</span><span class="s2">, </span><span class="s0">high) {</span>
	  <span class="s1">return </span><span class="s0">Math.round(low + (Math.random() * (high - low)))</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* The Quick Sort algorithm.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Array} ary</span>
	 <span class="s7">*        An array to sort.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{function} comparator</span>
	 <span class="s7">*        Function to use to compare two items.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} p</span>
	 <span class="s7">*        Start index of the array</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} r</span>
	 <span class="s7">*        End index of the array</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">doQuickSort(ary</span><span class="s2">, </span><span class="s0">comparator</span><span class="s2">, </span><span class="s0">p</span><span class="s2">, </span><span class="s0">r) {</span>
	  <span class="s5">// If our lower bound is less than our upper bound, we (1) partition the</span>
	  <span class="s5">// array into two pieces and (2) recurse on each half. If it is not, this is</span>
	  <span class="s5">// the empty array and our base case.</span>
	
	  <span class="s1">if </span><span class="s0">(p &lt; r) {</span>
	    <span class="s5">// (1) Partitioning.</span>
	    <span class="s5">//</span>
	    <span class="s5">// The partitioning chooses a pivot between `p` and `r` and moves all</span>
	    <span class="s5">// elements that are less than or equal to the pivot to the before it, and</span>
	    <span class="s5">// all the elements that are greater than it after it. The effect is that</span>
	    <span class="s5">// once partition is done, the pivot is in the exact place it will be when</span>
	    <span class="s5">// the array is put in sorted order, and it will not need to be moved</span>
	    <span class="s5">// again. This runs in O(n) time.</span>
	
	    <span class="s5">// Always choose a random pivot so that an input array which is reverse</span>
	    <span class="s5">// sorted does not cause O(n^2) running time.</span>
	    <span class="s1">var </span><span class="s0">pivotIndex = randomIntInRange(p</span><span class="s2">, </span><span class="s0">r)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">i = p - </span><span class="s6">1</span><span class="s2">;</span>
	
	    <span class="s0">swap(ary</span><span class="s2">, </span><span class="s0">pivotIndex</span><span class="s2">, </span><span class="s0">r)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">pivot = ary[r]</span><span class="s2">;</span>
	
	    <span class="s5">// Immediately after `j` is incremented in this loop, the following hold</span>
	    <span class="s5">// true:</span>
	    <span class="s5">//</span>
	    <span class="s5">//   * Every element in `ary[p .. i]` is less than or equal to the pivot.</span>
	    <span class="s5">//</span>
	    <span class="s5">//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = p</span><span class="s2">; </span><span class="s0">j &lt; r</span><span class="s2">; </span><span class="s0">j++) {</span>
	      <span class="s1">if </span><span class="s0">(comparator(ary[j]</span><span class="s2">, </span><span class="s0">pivot) &lt;= </span><span class="s6">0</span><span class="s0">) {</span>
	        <span class="s0">i += </span><span class="s6">1</span><span class="s2">;</span>
	        <span class="s0">swap(ary</span><span class="s2">, </span><span class="s0">i</span><span class="s2">, </span><span class="s0">j)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s0">swap(ary</span><span class="s2">, </span><span class="s0">i + </span><span class="s6">1</span><span class="s2">, </span><span class="s0">j)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">q = i + </span><span class="s6">1</span><span class="s2">;</span>
	
	    <span class="s5">// (2) Recurse on each half.</span>
	
	    <span class="s0">doQuickSort(ary</span><span class="s2">, </span><span class="s0">comparator</span><span class="s2">, </span><span class="s0">p</span><span class="s2">, </span><span class="s0">q - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">doQuickSort(ary</span><span class="s2">, </span><span class="s0">comparator</span><span class="s2">, </span><span class="s0">q + </span><span class="s6">1</span><span class="s2">, </span><span class="s0">r)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Sort the given array in-place with the given comparator function.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Array} ary</span>
	 <span class="s7">*        An array to sort.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{function} comparator</span>
	 <span class="s7">*        Function to use to compare two items.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.quickSort = </span><span class="s1">function </span><span class="s0">(ary</span><span class="s2">, </span><span class="s0">comparator) {</span>
	  <span class="s0">doQuickSort(ary</span><span class="s2">, </span><span class="s0">comparator</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s0">ary.length - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 10 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	
	<span class="s1">var </span><span class="s0">SourceMapGenerator = __webpack_require__(</span><span class="s6">1</span><span class="s0">).SourceMapGenerator</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>
	
	<span class="s5">// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other</span>
	<span class="s5">// operating systems these days (capturing the result).</span>
	<span class="s1">var </span><span class="s0">REGEX_NEWLINE = </span><span class="s6">/(\r?\n)/</span><span class="s2">;</span>
	
	<span class="s5">// Newline character code for charCodeAt() comparisons</span>
	<span class="s1">var </span><span class="s0">NEWLINE_CODE = </span><span class="s6">10</span><span class="s2">;</span>
	
	<span class="s5">// Private symbol for identifying `SourceNode`s when multiple versions of</span>
	<span class="s5">// the source-map library are loaded. This MUST NOT CHANGE across</span>
	<span class="s5">// versions!</span>
	<span class="s1">var </span><span class="s0">isSourceNode = </span><span class="s3">&quot;$$$isSourceNode$$$&quot;</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* SourceNodes provide a way to abstract over interpolating/concatenating</span>
	 <span class="s7">* snippets of generated JavaScript source code while maintaining the line and</span>
	 <span class="s7">* column information associated with the original source code.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aLine The original line number.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aColumn The original column number.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSource The original source's filename.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aChunks Optional. An array of strings which are snippets of</span>
	 <span class="s7">*        generated JS, or other SourceNodes.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aName The original identifier.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">SourceNode(aLine</span><span class="s2">, </span><span class="s0">aColumn</span><span class="s2">, </span><span class="s0">aSource</span><span class="s2">, </span><span class="s0">aChunks</span><span class="s2">, </span><span class="s0">aName) {</span>
	  <span class="s1">this</span><span class="s0">.children = []</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.sourceContents = {}</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.line = aLine == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aLine</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.column = aColumn == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aColumn</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.source = aSource == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aSource</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.name = aName == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aName</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">[isSourceNode] = </span><span class="s1">true</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(aChunks != </span><span class="s1">null</span><span class="s0">) </span><span class="s1">this</span><span class="s0">.add(aChunks)</span><span class="s2">;</span>
	<span class="s0">}</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Creates a SourceNode from generated code and a SourceMapConsumer.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aGeneratedCode The generated code</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceMapConsumer The SourceMap for the generated code</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aRelativePath Optional. The path that relative sources in the</span>
	 <span class="s7">*        SourceMapConsumer should be relative to.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.fromStringWithSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_fromStringWithSourceMap(aGeneratedCode</span><span class="s2">, </span><span class="s0">aSourceMapConsumer</span><span class="s2">, </span><span class="s0">aRelativePath) {</span>
	    <span class="s5">// The SourceNode we want to fill with the generated code</span>
	    <span class="s5">// and the SourceMap</span>
	    <span class="s1">var </span><span class="s0">node = </span><span class="s1">new </span><span class="s0">SourceNode()</span><span class="s2">;</span>
	
	    <span class="s5">// All even indices of this array are one line of the generated code,</span>
	    <span class="s5">// while all odd indices are the newlines between two adjacent lines</span>
	    <span class="s5">// (since `REGEX_NEWLINE` captures its match).</span>
	    <span class="s5">// Processed fragments are accessed by calling `shiftNextLine`.</span>
	    <span class="s1">var </span><span class="s0">remainingLines = aGeneratedCode.split(REGEX_NEWLINE)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">remainingLinesIndex = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">shiftNextLine = </span><span class="s1">function</span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s0">lineContents = getNextLine()</span><span class="s2">;</span>
	      <span class="s5">// The last line of a file might not have a newline.</span>
	      <span class="s1">var </span><span class="s0">newLine = getNextLine() || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
	      <span class="s1">return </span><span class="s0">lineContents + newLine</span><span class="s2">;</span>
	
	      <span class="s1">function </span><span class="s0">getNextLine() {</span>
	        <span class="s1">return </span><span class="s0">remainingLinesIndex &lt; remainingLines.length ?</span>
	            <span class="s0">remainingLines[remainingLinesIndex++] : undefined</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span><span class="s2">;</span>
	
	    <span class="s5">// We need to remember the position of &quot;remainingLines&quot;</span>
	    <span class="s1">var </span><span class="s0">lastGeneratedLine = </span><span class="s6">1</span><span class="s2">, </span><span class="s0">lastGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	
	    <span class="s5">// The generate SourceNodes we need a code range.</span>
	    <span class="s5">// To extract it current and last mapping is used.</span>
	    <span class="s5">// Here we store the last mapping.</span>
	    <span class="s1">var </span><span class="s0">lastMapping = </span><span class="s1">null</span><span class="s2">;</span>
	
	    <span class="s0">aSourceMapConsumer.eachMapping(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">if </span><span class="s0">(lastMapping !== </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s5">// We add the code from &quot;lastMapping&quot; to &quot;mapping&quot;:</span>
	        <span class="s5">// First check if there is a new line in between.</span>
	        <span class="s1">if </span><span class="s0">(lastGeneratedLine &lt; mapping.generatedLine) {</span>
	          <span class="s5">// Associate first line with &quot;lastMapping&quot;</span>
	          <span class="s0">addMappingWithCode(lastMapping</span><span class="s2">, </span><span class="s0">shiftNextLine())</span><span class="s2">;</span>
	          <span class="s0">lastGeneratedLine++</span><span class="s2">;</span>
	          <span class="s0">lastGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	          <span class="s5">// The remaining code is added without mapping</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s5">// There is no new line in between.</span>
	          <span class="s5">// Associate the code between &quot;lastGeneratedColumn&quot; and</span>
	          <span class="s5">// &quot;mapping.generatedColumn&quot; with &quot;lastMapping&quot;</span>
	          <span class="s1">var </span><span class="s0">nextLine = remainingLines[remainingLinesIndex] || </span><span class="s3">''</span><span class="s2">;</span>
	          <span class="s1">var </span><span class="s0">code = nextLine.substr(</span><span class="s6">0</span><span class="s2">, </span><span class="s0">mapping.generatedColumn -</span>
	                                        <span class="s0">lastGeneratedColumn)</span><span class="s2">;</span>
	          <span class="s0">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -</span>
	                                              <span class="s0">lastGeneratedColumn)</span><span class="s2">;</span>
	          <span class="s0">lastGeneratedColumn = mapping.generatedColumn</span><span class="s2">;</span>
	          <span class="s0">addMappingWithCode(lastMapping</span><span class="s2">, </span><span class="s0">code)</span><span class="s2">;</span>
	          <span class="s5">// No more remaining code, continue</span>
	          <span class="s0">lastMapping = mapping</span><span class="s2">;</span>
	          <span class="s1">return</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	      <span class="s5">// We add the generated code until the first mapping</span>
	      <span class="s5">// to the SourceNode without any mapping.</span>
	      <span class="s5">// Each line is added as separate string.</span>
	      <span class="s1">while </span><span class="s0">(lastGeneratedLine &lt; mapping.generatedLine) {</span>
	        <span class="s0">node.add(shiftNextLine())</span><span class="s2">;</span>
	        <span class="s0">lastGeneratedLine++</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">if </span><span class="s0">(lastGeneratedColumn &lt; mapping.generatedColumn) {</span>
	        <span class="s1">var </span><span class="s0">nextLine = remainingLines[remainingLinesIndex] || </span><span class="s3">''</span><span class="s2">;</span>
	        <span class="s0">node.add(nextLine.substr(</span><span class="s6">0</span><span class="s2">, </span><span class="s0">mapping.generatedColumn))</span><span class="s2">;</span>
	        <span class="s0">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn)</span><span class="s2">;</span>
	        <span class="s0">lastGeneratedColumn = mapping.generatedColumn</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s0">lastMapping = mapping</span><span class="s2">;</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s5">// We have processed all mappings.</span>
	    <span class="s1">if </span><span class="s0">(remainingLinesIndex &lt; remainingLines.length) {</span>
	      <span class="s1">if </span><span class="s0">(lastMapping) {</span>
	        <span class="s5">// Associate the remaining code in the current line with &quot;lastMapping&quot;</span>
	        <span class="s0">addMappingWithCode(lastMapping</span><span class="s2">, </span><span class="s0">shiftNextLine())</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s5">// and add the remaining lines without any mapping</span>
	      <span class="s0">node.add(remainingLines.splice(remainingLinesIndex).join(</span><span class="s3">&quot;&quot;</span><span class="s0">))</span><span class="s2">;</span>
	    <span class="s0">}</span>
	
	    <span class="s5">// Copy sourcesContent into SourceNode</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(aRelativePath != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.join(aRelativePath</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s0">node.setSourceContent(sourceFile</span><span class="s2">, </span><span class="s0">content)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">})</span><span class="s2">;</span>
	
	    <span class="s1">return </span><span class="s0">node</span><span class="s2">;</span>
	
	    <span class="s1">function </span><span class="s0">addMappingWithCode(mapping</span><span class="s2">, </span><span class="s0">code) {</span>
	      <span class="s1">if </span><span class="s0">(mapping === </span><span class="s1">null </span><span class="s0">|| mapping.source === undefined) {</span>
	        <span class="s0">node.add(code)</span><span class="s2">;</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">var </span><span class="s0">source = aRelativePath</span>
	          <span class="s0">? util.join(aRelativePath</span><span class="s2">, </span><span class="s0">mapping.source)</span>
	          <span class="s0">: mapping.source</span><span class="s2">;</span>
	        <span class="s0">node.add(</span><span class="s1">new </span><span class="s0">SourceNode(mapping.originalLine</span><span class="s2">,</span>
	                                <span class="s0">mapping.originalColumn</span><span class="s2">,</span>
	                                <span class="s0">source</span><span class="s2">,</span>
	                                <span class="s0">code</span><span class="s2">,</span>
	                                <span class="s0">mapping.name))</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Add a chunk of generated JS to this source node.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aChunk A string snippet of generated JS code, another instance of</span>
	 <span class="s7">*        SourceNode, or an array where each member is one of those things.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.add = </span><span class="s1">function </span><span class="s0">SourceNode_add(aChunk) {</span>
	  <span class="s1">if </span><span class="s0">(Array.isArray(aChunk)) {</span>
	    <span class="s0">aChunk.forEach(</span><span class="s1">function </span><span class="s0">(chunk) {</span>
	      <span class="s1">this</span><span class="s0">.add(chunk)</span><span class="s2">;</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(aChunk[isSourceNode] || </span><span class="s1">typeof </span><span class="s0">aChunk === </span><span class="s3">&quot;string&quot;</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(aChunk) {</span>
	      <span class="s1">this</span><span class="s0">.children.push(aChunk)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">TypeError(</span>
	      <span class="s3">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ aChunk</span>
	    <span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Add a chunk of generated JS to the beginning of this source node.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aChunk A string snippet of generated JS code, another instance of</span>
	 <span class="s7">*        SourceNode, or an array where each member is one of those things.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.prepend = </span><span class="s1">function </span><span class="s0">SourceNode_prepend(aChunk) {</span>
	  <span class="s1">if </span><span class="s0">(Array.isArray(aChunk)) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = aChunk.length-</span><span class="s6">1</span><span class="s2">; </span><span class="s0">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i--) {</span>
	      <span class="s1">this</span><span class="s0">.prepend(aChunk[i])</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(aChunk[isSourceNode] || </span><span class="s1">typeof </span><span class="s0">aChunk === </span><span class="s3">&quot;string&quot;</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.children.unshift(aChunk)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">TypeError(</span>
	      <span class="s3">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ aChunk</span>
	    <span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Walk over the tree of JS snippets in this node and its children. The</span>
	 <span class="s7">* walking function is called once for each snippet of JS and is passed that</span>
	 <span class="s7">* snippet and the its original associated source's line/column location.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aFn The traversal function.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.walk = </span><span class="s1">function </span><span class="s0">SourceNode_walk(aFn) {</span>
	  <span class="s1">var </span><span class="s0">chunk</span><span class="s2">;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = </span><span class="s1">this</span><span class="s0">.children.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	    <span class="s0">chunk = </span><span class="s1">this</span><span class="s0">.children[i]</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(chunk[isSourceNode]) {</span>
	      <span class="s0">chunk.walk(aFn)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">if </span><span class="s0">(chunk !== </span><span class="s3">''</span><span class="s0">) {</span>
	        <span class="s0">aFn(chunk</span><span class="s2">, </span><span class="s0">{ source: </span><span class="s1">this</span><span class="s0">.source</span><span class="s2">,</span>
	                     <span class="s0">line: </span><span class="s1">this</span><span class="s0">.line</span><span class="s2">,</span>
	                     <span class="s0">column: </span><span class="s1">this</span><span class="s0">.column</span><span class="s2">,</span>
	                     <span class="s0">name: </span><span class="s1">this</span><span class="s0">.name })</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between</span>
	 <span class="s7">* each of `this.children`.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSep The separator.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.join = </span><span class="s1">function </span><span class="s0">SourceNode_join(aSep) {</span>
	  <span class="s1">var </span><span class="s0">newChildren</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">i</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">len = </span><span class="s1">this</span><span class="s0">.children.length</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(len &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s0">newChildren = []</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; len-</span><span class="s6">1</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s0">newChildren.push(</span><span class="s1">this</span><span class="s0">.children[i])</span><span class="s2">;</span>
	      <span class="s0">newChildren.push(aSep)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">newChildren.push(</span><span class="s1">this</span><span class="s0">.children[i])</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">.children = newChildren</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Call String.prototype.replace on the very right-most source snippet. Useful</span>
	 <span class="s7">* for trimming whitespace from the end of a source node, etc.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aPattern The pattern to replace.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aReplacement The thing to replace the pattern with.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.replaceRight = </span><span class="s1">function </span><span class="s0">SourceNode_replaceRight(aPattern</span><span class="s2">, </span><span class="s0">aReplacement) {</span>
	  <span class="s1">var </span><span class="s0">lastChild = </span><span class="s1">this</span><span class="s0">.children[</span><span class="s1">this</span><span class="s0">.children.length - </span><span class="s6">1</span><span class="s0">]</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(lastChild[isSourceNode]) {</span>
	    <span class="s0">lastChild.replaceRight(aPattern</span><span class="s2">, </span><span class="s0">aReplacement)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">lastChild === </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.children[</span><span class="s1">this</span><span class="s0">.children.length - </span><span class="s6">1</span><span class="s0">] = lastChild.replace(aPattern</span><span class="s2">, </span><span class="s0">aReplacement)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">this</span><span class="s0">.children.push(</span><span class="s3">''</span><span class="s0">.replace(aPattern</span><span class="s2">, </span><span class="s0">aReplacement))</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Set the source content for a source file. This will be added to the SourceMapGenerator</span>
	 <span class="s7">* in the sourcesContent field.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceFile The filename of the source file</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceContent The content of the source file</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.setSourceContent =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_setSourceContent(aSourceFile</span><span class="s2">, </span><span class="s0">aSourceContent) {</span>
	    <span class="s1">this</span><span class="s0">.sourceContents[util.toSetString(aSourceFile)] = aSourceContent</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Walk over the tree of SourceNodes. The walking function is called for each</span>
	 <span class="s7">* source file content and is passed the filename and source content.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aFn The traversal function.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.walkSourceContents =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_walkSourceContents(aFn) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = </span><span class="s1">this</span><span class="s0">.children.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.children[i][isSourceNode]) {</span>
	        <span class="s1">this</span><span class="s0">.children[i].walkSourceContents(aFn)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	
	    <span class="s1">var </span><span class="s0">sources = Object.keys(</span><span class="s1">this</span><span class="s0">.sourceContents)</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = sources.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s0">aFn(util.fromSetString(sources[i])</span><span class="s2">, </span><span class="s1">this</span><span class="s0">.sourceContents[sources[i]])</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Return the string representation of this source node. Walks over the tree</span>
	 <span class="s7">* and concatenates all the various snippets together to one string.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.toString = </span><span class="s1">function </span><span class="s0">SourceNode_toString() {</span>
	  <span class="s1">var </span><span class="s0">str = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.walk(</span><span class="s1">function </span><span class="s0">(chunk) {</span>
	    <span class="s0">str += chunk</span><span class="s2">;</span>
	  <span class="s0">})</span><span class="s2">;</span>
	  <span class="s1">return </span><span class="s0">str</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s7">/**</span>
	 <span class="s7">* Returns the string representation of this source node along with a source</span>
	 <span class="s7">* map.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.toStringWithSourceMap = </span><span class="s1">function </span><span class="s0">SourceNode_toStringWithSourceMap(aArgs) {</span>
	  <span class="s1">var </span><span class="s0">generated = {</span>
	    <span class="s0">code: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
	    <span class="s0">line: </span><span class="s6">1</span><span class="s2">,</span>
	    <span class="s0">column: </span><span class="s6">0</span>
	  <span class="s0">}</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">map = </span><span class="s1">new </span><span class="s0">SourceMapGenerator(aArgs)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalLine = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalColumn = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalName = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.walk(</span><span class="s1">function </span><span class="s0">(chunk</span><span class="s2">, </span><span class="s0">original) {</span>
	    <span class="s0">generated.code += chunk</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(original.source !== </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; original.line !== </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; original.column !== </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s1">if</span><span class="s0">(lastOriginalSource !== original.source</span>
	         <span class="s0">|| lastOriginalLine !== original.line</span>
	         <span class="s0">|| lastOriginalColumn !== original.column</span>
	         <span class="s0">|| lastOriginalName !== original.name) {</span>
	        <span class="s0">map.addMapping({</span>
	          <span class="s0">source: original.source</span><span class="s2">,</span>
	          <span class="s0">original: {</span>
	            <span class="s0">line: original.line</span><span class="s2">,</span>
	            <span class="s0">column: original.column</span>
	          <span class="s0">}</span><span class="s2">,</span>
	          <span class="s0">generated: {</span>
	            <span class="s0">line: generated.line</span><span class="s2">,</span>
	            <span class="s0">column: generated.column</span>
	          <span class="s0">}</span><span class="s2">,</span>
	          <span class="s0">name: original.name</span>
	        <span class="s0">})</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s0">lastOriginalSource = original.source</span><span class="s2">;</span>
	      <span class="s0">lastOriginalLine = original.line</span><span class="s2">;</span>
	      <span class="s0">lastOriginalColumn = original.column</span><span class="s2">;</span>
	      <span class="s0">lastOriginalName = original.name</span><span class="s2">;</span>
	      <span class="s0">sourceMappingActive = </span><span class="s1">true</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sourceMappingActive) {</span>
	      <span class="s0">map.addMapping({</span>
	        <span class="s0">generated: {</span>
	          <span class="s0">line: generated.line</span><span class="s2">,</span>
	          <span class="s0">column: generated.column</span>
	        <span class="s0">}</span>
	      <span class="s0">})</span><span class="s2">;</span>
	      <span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s2">;</span>
	      <span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">idx = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">length = chunk.length</span><span class="s2">; </span><span class="s0">idx &lt; length</span><span class="s2">; </span><span class="s0">idx++) {</span>
	      <span class="s1">if </span><span class="s0">(chunk.charCodeAt(idx) === NEWLINE_CODE) {</span>
	        <span class="s0">generated.line++</span><span class="s2">;</span>
	        <span class="s0">generated.column = </span><span class="s6">0</span><span class="s2">;</span>
	        <span class="s5">// Mappings end at eol</span>
	        <span class="s1">if </span><span class="s0">(idx + </span><span class="s6">1 </span><span class="s0">=== length) {</span>
	          <span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s2">;</span>
	          <span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s2">;</span>
	        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sourceMappingActive) {</span>
	          <span class="s0">map.addMapping({</span>
	            <span class="s0">source: original.source</span><span class="s2">,</span>
	            <span class="s0">original: {</span>
	              <span class="s0">line: original.line</span><span class="s2">,</span>
	              <span class="s0">column: original.column</span>
	            <span class="s0">}</span><span class="s2">,</span>
	            <span class="s0">generated: {</span>
	              <span class="s0">line: generated.line</span><span class="s2">,</span>
	              <span class="s0">column: generated.column</span>
	            <span class="s0">}</span><span class="s2">,</span>
	            <span class="s0">name: original.name</span>
	          <span class="s0">})</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">generated.column++</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">})</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.walkSourceContents(</span><span class="s1">function </span><span class="s0">(sourceFile</span><span class="s2">, </span><span class="s0">sourceContent) {</span>
	    <span class="s0">map.setSourceContent(sourceFile</span><span class="s2">, </span><span class="s0">sourceContent)</span><span class="s2">;</span>
	  <span class="s0">})</span><span class="s2">;</span>
	
	  <span class="s1">return </span><span class="s0">{ code: generated.code</span><span class="s2">, </span><span class="s0">map: map }</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>
	
	<span class="s0">exports.SourceNode = SourceNode</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span>
<span class="s4">/******/ </span><span class="s0">])</span>
<span class="s0">})</span><span class="s2">;</span>
<span class="s2">;</span>
<span class="s5">//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy93ZWJwYWNrL2Jvb3RzdHJhcCAxNjI0YzcyOTliODg3ZjdiZGY2NCIsIndlYnBhY2s6Ly8vLi9zb3VyY2UtbWFwLmpzIiwid2VicGFjazovLy8uL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmFzZTY0LXZscS5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmFzZTY0LmpzIiwid2VicGFjazovLy8uL2xpYi91dGlsLmpzIiwid2VicGFjazovLy8uL2xpYi9hcnJheS1zZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbGliL21hcHBpbmctbGlzdC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc291cmNlLW1hcC1jb25zdW1lci5qcyIsIndlYnBhY2s6Ly8vLi9saWIvYmluYXJ5LXNlYXJjaC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvcXVpY2stc29ydC5qcyIsIndlYnBhY2s6Ly8vLi9saWIvc291cmNlLW5vZGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELE87QUNWQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNQQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEwQyxTQUFTO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3hhQSxpQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBMkQ7QUFDM0QscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7O0FBRUg7QUFDQTtBQUNBOzs7Ozs7O0FDM0lBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQixpQkFBZ0I7O0FBRWhCLG9CQUFtQjtBQUNuQixxQkFBb0I7O0FBRXBCLGlCQUFnQjtBQUNoQixpQkFBZ0I7O0FBRWhCLGlCQUFnQjtBQUNoQixrQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDbEVBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWE7QUFDYjs7QUFFQTtBQUNBLGVBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7O0FDdmVBLGlCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUFzQyxTQUFTO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUN4SEEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFnQjtBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7Ozs7QUM5RUEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7O0FBRVg7QUFDQTtBQUNBLFFBQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTJCLE1BQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWEsa0NBQWtDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBeUIsY0FBYztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXVCLHdDQUF3QztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUErQyxtQkFBbUIsRUFBRTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBNkIsTUFBTTtBQUNuQztBQUNBLFFBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBTztBQUNQO0FBQ0E7QUFDQSxJQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsMkJBQTJCO0FBQzlDLHNCQUFxQiwrQ0FBK0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFtQiwyQkFBMkI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0Esc0JBQXFCLDRCQUE0QjtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ3huQ0EsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM5R0EsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFXLE1BQU07QUFDakI7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQSxZQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCO0FBQ0EsWUFBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUNqSEEsaUJBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLFNBQVM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx1Q0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxZQUFXO0FBQ1g7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsNkNBQTRDLGNBQWM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxjQUFhO0FBQ2I7QUFDQSxZQUFXO0FBQ1g7QUFDQSxRQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsSUFBRztBQUNIO0FBQ0E7QUFDQSxJQUFHOztBQUVILFdBQVU7QUFDVjs7QUFFQSIsImZpbGUiOiJzb3VyY2UtbWFwLmRlYnVnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wic291cmNlTWFwXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInNvdXJjZU1hcFwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0ZXhwb3J0czoge30sXG4gXHRcdFx0aWQ6IG1vZHVsZUlkLFxuIFx0XHRcdGxvYWRlZDogZmFsc2VcbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubG9hZGVkID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAxNjI0YzcyOTliODg3ZjdiZGY2NCIsIi8qXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRS50eHQgb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cbmV4cG9ydHMuU291cmNlTWFwR2VuZXJhdG9yID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1nZW5lcmF0b3InKS5Tb3VyY2VNYXBHZW5lcmF0b3I7XG5leHBvcnRzLlNvdXJjZU1hcENvbnN1bWVyID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW1hcC1jb25zdW1lcicpLlNvdXJjZU1hcENvbnN1bWVyO1xuZXhwb3J0cy5Tb3VyY2VOb2RlID0gcmVxdWlyZSgnLi9saWIvc291cmNlLW5vZGUnKS5Tb3VyY2VOb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zb3VyY2UtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qIC0qLSBNb2RlOiBqczsganMtaW5kZW50LWxldmVsOiAyOyAtKi0gKi9cbi8qXG4gKiBDb3B5cmlnaHQgMjAxMSBNb3ppbGxhIEZvdW5kYXRpb24gYW5kIGNvbnRyaWJ1dG9yc1xuICogTGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgbGljZW5zZS4gU2VlIExJQ0VOU0Ugb3I6XG4gKiBodHRwOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvQlNELTMtQ2xhdXNlXG4gKi9cblxudmFyIGJhc2U2NFZMUSA9IHJlcXVpcmUoJy4vYmFzZTY0LXZscScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBBcnJheVNldCA9IHJlcXVpcmUoJy4vYXJyYXktc2V0JykuQXJyYXlTZXQ7XG52YXIgTWFwcGluZ0xpc3QgPSByZXF1aXJlKCcuL21hcHBpbmctbGlzdCcpLk1hcHBpbmdMaXN0O1xuXG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IgcmVwcmVzZW50cyBhIHNvdXJjZSBtYXAgd2hpY2ggaXNcbiAqIGJlaW5nIGJ1aWx0IGluY3JlbWVudGFsbHkuIFlvdSBtYXkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nXG4gKiBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBmaWxlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIGdlbmVyYXRlZCBzb3VyY2UuXG4gKiAgIC0gc291cmNlUm9vdDogQSByb290IGZvciBhbGwgcmVsYXRpdmUgVVJMcyBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcihhQXJncykge1xuICBpZiAoIWFBcmdzKSB7XG4gICAgYUFyZ3MgPSB7fTtcbiAgfVxuICB0aGlzLl9maWxlID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdmaWxlJywgbnVsbCk7XG4gIHRoaXMuX3NvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZVJvb3QnLCBudWxsKTtcbiAgdGhpcy5fc2tpcFZhbGlkYXRpb24gPSB1dGlsLmdldEFyZyhhQXJncywgJ3NraXBWYWxpZGF0aW9uJywgZmFsc2UpO1xuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX21hcHBpbmdzID0gbmV3IE1hcHBpbmdMaXN0KCk7XG4gIHRoaXMuX3NvdXJjZXNDb250ZW50cyA9IG51bGw7XG59XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZlcnNpb24gPSAzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU291cmNlTWFwR2VuZXJhdG9yIGJhc2VkIG9uIGEgU291cmNlTWFwQ29uc3VtZXJcbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBTb3VyY2VNYXAuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5mcm9tU291cmNlTWFwID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX2Zyb21Tb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyKSB7XG4gICAgdmFyIHNvdXJjZVJvb3QgPSBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlUm9vdDtcbiAgICB2YXIgZ2VuZXJhdG9yID0gbmV3IFNvdXJjZU1hcEdlbmVyYXRvcih7XG4gICAgICBmaWxlOiBhU291cmNlTWFwQ29uc3VtZXIuZmlsZSxcbiAgICAgIHNvdXJjZVJvb3Q6IHNvdXJjZVJvb3RcbiAgICB9KTtcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuZWFjaE1hcHBpbmcoZnVuY3Rpb24gKG1hcHBpbmcpIHtcbiAgICAgIHZhciBuZXdNYXBwaW5nID0ge1xuICAgICAgICBnZW5lcmF0ZWQ6IHtcbiAgICAgICAgICBsaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtblxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICBuZXdNYXBwaW5nLnNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBpZiAoc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG5ld01hcHBpbmcuc291cmNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5ld01hcHBpbmcub3JpZ2luYWwgPSB7XG4gICAgICAgICAgbGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgICAgY29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSAhPSBudWxsKSB7XG4gICAgICAgICAgbmV3TWFwcGluZy5uYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGdlbmVyYXRvci5hZGRNYXBwaW5nKG5ld01hcHBpbmcpO1xuICAgIH0pO1xuICAgIGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VzLmZvckVhY2goZnVuY3Rpb24gKHNvdXJjZUZpbGUpIHtcbiAgICAgIHZhciBzb3VyY2VSZWxhdGl2ZSA9IHNvdXJjZUZpbGU7XG4gICAgICBpZiAoc291cmNlUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzb3VyY2VSZWxhdGl2ZSA9IHV0aWwucmVsYXRpdmUoc291cmNlUm9vdCwgc291cmNlRmlsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2VuZXJhdG9yLl9zb3VyY2VzLmhhcyhzb3VyY2VSZWxhdGl2ZSkpIHtcbiAgICAgICAgZ2VuZXJhdG9yLl9zb3VyY2VzLmFkZChzb3VyY2VSZWxhdGl2ZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZW50ID0gYVNvdXJjZU1hcENvbnN1bWVyLnNvdXJjZUNvbnRlbnRGb3Ioc291cmNlRmlsZSk7XG4gICAgICBpZiAoY29udGVudCAhPSBudWxsKSB7XG4gICAgICAgIGdlbmVyYXRvci5zZXRTb3VyY2VDb250ZW50KHNvdXJjZUZpbGUsIGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBnZW5lcmF0b3I7XG4gIH07XG5cbi8qKlxuICogQWRkIGEgc2luZ2xlIG1hcHBpbmcgZnJvbSBvcmlnaW5hbCBzb3VyY2UgbGluZSBhbmQgY29sdW1uIHRvIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBmb3IgdGhpcyBzb3VyY2UgbWFwIGJlaW5nIGNyZWF0ZWQuIFRoZSBtYXBwaW5nXG4gKiBvYmplY3Qgc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBnZW5lcmF0ZWQ6IEFuIG9iamVjdCB3aXRoIHRoZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucy5cbiAqICAgLSBvcmlnaW5hbDogQW4gb2JqZWN0IHdpdGggdGhlIG9yaWdpbmFsIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMuXG4gKiAgIC0gc291cmNlOiBUaGUgb3JpZ2luYWwgc291cmNlIGZpbGUgKHJlbGF0aXZlIHRvIHRoZSBzb3VyY2VSb290KS5cbiAqICAgLSBuYW1lOiBBbiBvcHRpb25hbCBvcmlnaW5hbCB0b2tlbiBuYW1lIGZvciB0aGlzIG1hcHBpbmcuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYWRkTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9hZGRNYXBwaW5nKGFBcmdzKSB7XG4gICAgdmFyIGdlbmVyYXRlZCA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnZ2VuZXJhdGVkJyk7XG4gICAgdmFyIG9yaWdpbmFsID0gdXRpbC5nZXRBcmcoYUFyZ3MsICdvcmlnaW5hbCcsIG51bGwpO1xuICAgIHZhciBzb3VyY2UgPSB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScsIG51bGwpO1xuICAgIHZhciBuYW1lID0gdXRpbC5nZXRBcmcoYUFyZ3MsICduYW1lJywgbnVsbCk7XG5cbiAgICBpZiAoIXRoaXMuX3NraXBWYWxpZGF0aW9uKSB7XG4gICAgICB0aGlzLl92YWxpZGF0ZU1hcHBpbmcoZ2VuZXJhdGVkLCBvcmlnaW5hbCwgc291cmNlLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoc291cmNlICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZSA9IFN0cmluZyhzb3VyY2UpO1xuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgIGlmICghdGhpcy5fbmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9tYXBwaW5ncy5hZGQoe1xuICAgICAgZ2VuZXJhdGVkTGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICBnZW5lcmF0ZWRDb2x1bW46IGdlbmVyYXRlZC5jb2x1bW4sXG4gICAgICBvcmlnaW5hbExpbmU6IG9yaWdpbmFsICE9IG51bGwgJiYgb3JpZ2luYWwubGluZSxcbiAgICAgIG9yaWdpbmFsQ29sdW1uOiBvcmlnaW5hbCAhPSBudWxsICYmIG9yaWdpbmFsLmNvbHVtbixcbiAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgbmFtZTogbmFtZVxuICAgIH0pO1xuICB9O1xuXG4vKipcbiAqIFNldCB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgc291cmNlIGZpbGUuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuc2V0U291cmNlQ29udGVudCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHZhciBzb3VyY2UgPSBhU291cmNlRmlsZTtcbiAgICBpZiAodGhpcy5fc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICBzb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHRoaXMuX3NvdXJjZVJvb3QsIHNvdXJjZSk7XG4gICAgfVxuXG4gICAgaWYgKGFTb3VyY2VDb250ZW50ICE9IG51bGwpIHtcbiAgICAgIC8vIEFkZCB0aGUgc291cmNlIGNvbnRlbnQgdG8gdGhlIF9zb3VyY2VzQ29udGVudHMgbWFwLlxuICAgICAgLy8gQ3JlYXRlIGEgbmV3IF9zb3VyY2VzQ29udGVudHMgbWFwIGlmIHRoZSBwcm9wZXJ0eSBpcyBudWxsLlxuICAgICAgaWYgKCF0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgICAgdGhpcy5fc291cmNlc0NvbnRlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50c1t1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zb3VyY2VzQ29udGVudHMpIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgc291cmNlIGZpbGUgZnJvbSB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAuXG4gICAgICAvLyBJZiB0aGUgX3NvdXJjZXNDb250ZW50cyBtYXAgaXMgZW1wdHksIHNldCB0aGUgcHJvcGVydHkgdG8gbnVsbC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zb3VyY2VzQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhzb3VyY2UpXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyh0aGlzLl9zb3VyY2VzQ29udGVudHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9zb3VyY2VzQ29udGVudHMgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBBcHBsaWVzIHRoZSBtYXBwaW5ncyBvZiBhIHN1Yi1zb3VyY2UtbWFwIGZvciBhIHNwZWNpZmljIHNvdXJjZSBmaWxlIHRvIHRoZVxuICogc291cmNlIG1hcCBiZWluZyBnZW5lcmF0ZWQuIEVhY2ggbWFwcGluZyB0byB0aGUgc3VwcGxpZWQgc291cmNlIGZpbGUgaXNcbiAqIHJld3JpdHRlbiB1c2luZyB0aGUgc3VwcGxpZWQgc291cmNlIG1hcC4gTm90ZTogVGhlIHJlc29sdXRpb24gZm9yIHRoZVxuICogcmVzdWx0aW5nIG1hcHBpbmdzIGlzIHRoZSBtaW5pbWl1bSBvZiB0aGlzIG1hcCBhbmQgdGhlIHN1cHBsaWVkIG1hcC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZU1hcENvbnN1bWVyIFRoZSBzb3VyY2UgbWFwIHRvIGJlIGFwcGxpZWQuXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgT3B0aW9uYWwuIFRoZSBmaWxlbmFtZSBvZiB0aGUgc291cmNlIGZpbGUuXG4gKiAgICAgICAgSWYgb21pdHRlZCwgU291cmNlTWFwQ29uc3VtZXIncyBmaWxlIHByb3BlcnR5IHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSBhU291cmNlTWFwUGF0aCBPcHRpb25hbC4gVGhlIGRpcm5hbWUgb2YgdGhlIHBhdGggdG8gdGhlIHNvdXJjZSBtYXBcbiAqICAgICAgICB0byBiZSBhcHBsaWVkLiBJZiByZWxhdGl2ZSwgaXQgaXMgcmVsYXRpdmUgdG8gdGhlIFNvdXJjZU1hcENvbnN1bWVyLlxuICogICAgICAgIFRoaXMgcGFyYW1ldGVyIGlzIG5lZWRlZCB3aGVuIHRoZSB0d28gc291cmNlIG1hcHMgYXJlbid0IGluIHRoZSBzYW1lXG4gKiAgICAgICAgZGlyZWN0b3J5LCBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gYmUgYXBwbGllZCBjb250YWlucyByZWxhdGl2ZSBzb3VyY2VcbiAqICAgICAgICBwYXRocy4gSWYgc28sIHRob3NlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBuZWVkIHRvIGJlIHJld3JpdHRlblxuICogICAgICAgIHJlbGF0aXZlIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuYXBwbHlTb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfYXBwbHlTb3VyY2VNYXAoYVNvdXJjZU1hcENvbnN1bWVyLCBhU291cmNlRmlsZSwgYVNvdXJjZU1hcFBhdGgpIHtcbiAgICB2YXIgc291cmNlRmlsZSA9IGFTb3VyY2VGaWxlO1xuICAgIC8vIElmIGFTb3VyY2VGaWxlIGlzIG9taXR0ZWQsIHdlIHdpbGwgdXNlIHRoZSBmaWxlIHByb3BlcnR5IG9mIHRoZSBTb3VyY2VNYXBcbiAgICBpZiAoYVNvdXJjZUZpbGUgPT0gbnVsbCkge1xuICAgICAgaWYgKGFTb3VyY2VNYXBDb25zdW1lci5maWxlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLmFwcGx5U291cmNlTWFwIHJlcXVpcmVzIGVpdGhlciBhbiBleHBsaWNpdCBzb3VyY2UgZmlsZSwgJyArXG4gICAgICAgICAgJ29yIHRoZSBzb3VyY2UgbWFwXFwncyBcImZpbGVcIiBwcm9wZXJ0eS4gQm90aCB3ZXJlIG9taXR0ZWQuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc291cmNlRmlsZSA9IGFTb3VyY2VNYXBDb25zdW1lci5maWxlO1xuICAgIH1cbiAgICB2YXIgc291cmNlUm9vdCA9IHRoaXMuX3NvdXJjZVJvb3Q7XG4gICAgLy8gTWFrZSBcInNvdXJjZUZpbGVcIiByZWxhdGl2ZSBpZiBhbiBhYnNvbHV0ZSBVcmwgaXMgcGFzc2VkLlxuICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZUZpbGUpO1xuICAgIH1cbiAgICAvLyBBcHBseWluZyB0aGUgU291cmNlTWFwIGNhbiBhZGQgYW5kIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBzb3VyY2VzIGFuZFxuICAgIC8vIHRoZSBuYW1lcyBhcnJheS5cbiAgICB2YXIgbmV3U291cmNlcyA9IG5ldyBBcnJheVNldCgpO1xuICAgIHZhciBuZXdOYW1lcyA9IG5ldyBBcnJheVNldCgpO1xuXG4gICAgLy8gRmluZCBtYXBwaW5ncyBmb3IgdGhlIFwic291cmNlRmlsZVwiXG4gICAgdGhpcy5fbWFwcGluZ3MudW5zb3J0ZWRGb3JFYWNoKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobWFwcGluZy5zb3VyY2UgPT09IHNvdXJjZUZpbGUgJiYgbWFwcGluZy5vcmlnaW5hbExpbmUgIT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiBpdCBjYW4gYmUgbWFwcGVkIGJ5IHRoZSBzb3VyY2UgbWFwLCB0aGVuIHVwZGF0ZSB0aGUgbWFwcGluZy5cbiAgICAgICAgdmFyIG9yaWdpbmFsID0gYVNvdXJjZU1hcENvbnN1bWVyLm9yaWdpbmFsUG9zaXRpb25Gb3Ioe1xuICAgICAgICAgIGxpbmU6IG1hcHBpbmcub3JpZ2luYWxMaW5lLFxuICAgICAgICAgIGNvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9yaWdpbmFsLnNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgLy8gQ29weSBtYXBwaW5nXG4gICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICAgICAgaWYgKGFTb3VyY2VNYXBQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gdXRpbC5qb2luKGFTb3VyY2VNYXBQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5zb3VyY2UgPSB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgPSBvcmlnaW5hbC5saW5lO1xuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxDb2x1bW4gPSBvcmlnaW5hbC5jb2x1bW47XG4gICAgICAgICAgaWYgKG9yaWdpbmFsLm5hbWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gb3JpZ2luYWwubmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZSAhPSBudWxsICYmICFuZXdTb3VyY2VzLmhhcyhzb3VyY2UpKSB7XG4gICAgICAgIG5ld1NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gbWFwcGluZy5uYW1lO1xuICAgICAgaWYgKG5hbWUgIT0gbnVsbCAmJiAhbmV3TmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIG5ld05hbWVzLmFkZChuYW1lKTtcbiAgICAgIH1cblxuICAgIH0sIHRoaXMpO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBuZXdTb3VyY2VzO1xuICAgIHRoaXMuX25hbWVzID0gbmV3TmFtZXM7XG5cbiAgICAvLyBDb3B5IHNvdXJjZXNDb250ZW50cyBvZiBhcHBsaWVkIG1hcC5cbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVNvdXJjZU1hcFBhdGggIT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZUZpbGUgPSB1dGlsLmpvaW4oYVNvdXJjZU1hcFBhdGgsIHNvdXJjZUZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgICBzb3VyY2VGaWxlID0gdXRpbC5yZWxhdGl2ZShzb3VyY2VSb290LCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gIH07XG5cbi8qKlxuICogQSBtYXBwaW5nIGNhbiBoYXZlIG9uZSBvZiB0aGUgdGhyZWUgbGV2ZWxzIG9mIGRhdGE6XG4gKlxuICogICAxLiBKdXN0IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uXG4gKiAgIDIuIFRoZSBHZW5lcmF0ZWQgcG9zaXRpb24sIG9yaWdpbmFsIHBvc2l0aW9uLCBhbmQgb3JpZ2luYWwgc291cmNlLlxuICogICAzLiBHZW5lcmF0ZWQgYW5kIG9yaWdpbmFsIHBvc2l0aW9uLCBvcmlnaW5hbCBzb3VyY2UsIGFzIHdlbGwgYXMgYSBuYW1lXG4gKiAgICAgIHRva2VuLlxuICpcbiAqIFRvIG1haW50YWluIGNvbnNpc3RlbmN5LCB3ZSB2YWxpZGF0ZSB0aGF0IGFueSBuZXcgbWFwcGluZyBiZWluZyBhZGRlZCBmYWxsc1xuICogaW4gdG8gb25lIG9mIHRoZXNlIGNhdGVnb3JpZXMuXG4gKi9cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX3ZhbGlkYXRlTWFwcGluZyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcEdlbmVyYXRvcl92YWxpZGF0ZU1hcHBpbmcoYUdlbmVyYXRlZCwgYU9yaWdpbmFsLCBhU291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFOYW1lKSB7XG4gICAgLy8gV2hlbiBhT3JpZ2luYWwgaXMgdHJ1dGh5IGJ1dCBoYXMgZW1wdHkgdmFsdWVzIGZvciAubGluZSBhbmQgLmNvbHVtbixcbiAgICAvLyBpdCBpcyBtb3N0IGxpa2VseSBhIHByb2dyYW1tZXIgZXJyb3IuIEluIHRoaXMgY2FzZSB3ZSB0aHJvdyBhIHZlcnlcbiAgICAvLyBzcGVjaWZpYyBlcnJvciBtZXNzYWdlIHRvIHRyeSB0byBndWlkZSB0aGVtIHRoZSByaWdodCB3YXkuXG4gICAgLy8gRm9yIGV4YW1wbGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXItYnVuZGxlci9wdWxsLzUxOVxuICAgIGlmIChhT3JpZ2luYWwgJiYgdHlwZW9mIGFPcmlnaW5hbC5saW5lICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgYU9yaWdpbmFsLmNvbHVtbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ29yaWdpbmFsLmxpbmUgYW5kIG9yaWdpbmFsLmNvbHVtbiBhcmUgbm90IG51bWJlcnMgLS0geW91IHByb2JhYmx5IG1lYW50IHRvIG9taXQgJyArXG4gICAgICAgICAgICAndGhlIG9yaWdpbmFsIG1hcHBpbmcgZW50aXJlbHkgYW5kIG9ubHkgbWFwIHRoZSBnZW5lcmF0ZWQgcG9zaXRpb24uIElmIHNvLCBwYXNzICcgK1xuICAgICAgICAgICAgJ251bGwgZm9yIHRoZSBvcmlnaW5hbCBtYXBwaW5nIGluc3RlYWQgb2YgYW4gb2JqZWN0IHdpdGggZW1wdHkgb3IgbnVsbCB2YWx1ZXMuJ1xuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmIChhR2VuZXJhdGVkICYmICdsaW5lJyBpbiBhR2VuZXJhdGVkICYmICdjb2x1bW4nIGluIGFHZW5lcmF0ZWRcbiAgICAgICAgJiYgYUdlbmVyYXRlZC5saW5lID4gMCAmJiBhR2VuZXJhdGVkLmNvbHVtbiA+PSAwXG4gICAgICAgICYmICFhT3JpZ2luYWwgJiYgIWFTb3VyY2UgJiYgIWFOYW1lKSB7XG4gICAgICAvLyBDYXNlIDEuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsc2UgaWYgKGFHZW5lcmF0ZWQgJiYgJ2xpbmUnIGluIGFHZW5lcmF0ZWQgJiYgJ2NvbHVtbicgaW4gYUdlbmVyYXRlZFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbCAmJiAnbGluZScgaW4gYU9yaWdpbmFsICYmICdjb2x1bW4nIGluIGFPcmlnaW5hbFxuICAgICAgICAgICAgICYmIGFHZW5lcmF0ZWQubGluZSA+IDAgJiYgYUdlbmVyYXRlZC5jb2x1bW4gPj0gMFxuICAgICAgICAgICAgICYmIGFPcmlnaW5hbC5saW5lID4gMCAmJiBhT3JpZ2luYWwuY29sdW1uID49IDBcbiAgICAgICAgICAgICAmJiBhU291cmNlKSB7XG4gICAgICAvLyBDYXNlcyAyIGFuZCAzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXBwaW5nOiAnICsgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBnZW5lcmF0ZWQ6IGFHZW5lcmF0ZWQsXG4gICAgICAgIHNvdXJjZTogYVNvdXJjZSxcbiAgICAgICAgb3JpZ2luYWw6IGFPcmlnaW5hbCxcbiAgICAgICAgbmFtZTogYU5hbWVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBhY2N1bXVsYXRlZCBtYXBwaW5ncyBpbiB0byB0aGUgc3RyZWFtIG9mIGJhc2UgNjQgVkxRc1xuICogc3BlY2lmaWVkIGJ5IHRoZSBzb3VyY2UgbWFwIGZvcm1hdC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS5fc2VyaWFsaXplTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3Jfc2VyaWFsaXplTWFwcGluZ3MoKSB7XG4gICAgdmFyIHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgICB2YXIgcHJldmlvdXNHZW5lcmF0ZWRMaW5lID0gMTtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgcHJldmlvdXNTb3VyY2UgPSAwO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgbWFwcGluZztcbiAgICB2YXIgbmFtZUlkeDtcbiAgICB2YXIgc291cmNlSWR4O1xuXG4gICAgdmFyIG1hcHBpbmdzID0gdGhpcy5fbWFwcGluZ3MudG9BcnJheSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtYXBwaW5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbWFwcGluZyA9IG1hcHBpbmdzW2ldO1xuICAgICAgbmV4dCA9ICcnXG5cbiAgICAgIGlmIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgIHdoaWxlIChtYXBwaW5nLmdlbmVyYXRlZExpbmUgIT09IHByZXZpb3VzR2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIG5leHQgKz0gJzsnO1xuICAgICAgICAgIHByZXZpb3VzR2VuZXJhdGVkTGluZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgaWYgKCF1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmcsIG1hcHBpbmdzW2kgLSAxXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuZXh0ICs9ICcsJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKG1hcHBpbmcuc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlSWR4ID0gdGhpcy5fc291cmNlcy5pbmRleE9mKG1hcHBpbmcuc291cmNlKTtcbiAgICAgICAgbmV4dCArPSBiYXNlNjRWTFEuZW5jb2RlKHNvdXJjZUlkeCAtIHByZXZpb3VzU291cmNlKTtcbiAgICAgICAgcHJldmlvdXNTb3VyY2UgPSBzb3VyY2VJZHg7XG5cbiAgICAgICAgLy8gbGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkIGluIFNvdXJjZU1hcCBzcGVjIHZlcnNpb24gM1xuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbExpbmUgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gcHJldmlvdXNPcmlnaW5hbExpbmUpO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsTGluZSA9IG1hcHBpbmcub3JpZ2luYWxMaW5lIC0gMTtcblxuICAgICAgICBuZXh0ICs9IGJhc2U2NFZMUS5lbmNvZGUobWFwcGluZy5vcmlnaW5hbENvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHByZXZpb3VzT3JpZ2luYWxDb2x1bW4pO1xuICAgICAgICBwcmV2aW91c09yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICBpZiAobWFwcGluZy5uYW1lICE9IG51bGwpIHtcbiAgICAgICAgICBuYW1lSWR4ID0gdGhpcy5fbmFtZXMuaW5kZXhPZihtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIG5leHQgKz0gYmFzZTY0VkxRLmVuY29kZShuYW1lSWR4IC0gcHJldmlvdXNOYW1lKTtcbiAgICAgICAgICBwcmV2aW91c05hbWUgPSBuYW1lSWR4O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJlc3VsdCArPSBuZXh0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cblNvdXJjZU1hcEdlbmVyYXRvci5wcm90b3R5cGUuX2dlbmVyYXRlU291cmNlc0NvbnRlbnQgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfZ2VuZXJhdGVTb3VyY2VzQ29udGVudChhU291cmNlcywgYVNvdXJjZVJvb3QpIHtcbiAgICByZXR1cm4gYVNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIGlmICghdGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGFTb3VyY2VSb290ICE9IG51bGwpIHtcbiAgICAgICAgc291cmNlID0gdXRpbC5yZWxhdGl2ZShhU291cmNlUm9vdCwgc291cmNlKTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXkgPSB1dGlsLnRvU2V0U3RyaW5nKHNvdXJjZSk7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuX3NvdXJjZXNDb250ZW50cywga2V5KVxuICAgICAgICA/IHRoaXMuX3NvdXJjZXNDb250ZW50c1trZXldXG4gICAgICAgIDogbnVsbDtcbiAgICB9LCB0aGlzKTtcbiAgfTtcblxuLyoqXG4gKiBFeHRlcm5hbGl6ZSB0aGUgc291cmNlIG1hcC5cbiAqL1xuU291cmNlTWFwR2VuZXJhdG9yLnByb3RvdHlwZS50b0pTT04gPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBHZW5lcmF0b3JfdG9KU09OKCkge1xuICAgIHZhciBtYXAgPSB7XG4gICAgICB2ZXJzaW9uOiB0aGlzLl92ZXJzaW9uLFxuICAgICAgc291cmNlczogdGhpcy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICBuYW1lczogdGhpcy5fbmFtZXMudG9BcnJheSgpLFxuICAgICAgbWFwcGluZ3M6IHRoaXMuX3NlcmlhbGl6ZU1hcHBpbmdzKClcbiAgICB9O1xuICAgIGlmICh0aGlzLl9maWxlICE9IG51bGwpIHtcbiAgICAgIG1hcC5maWxlID0gdGhpcy5fZmlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgICAgbWFwLnNvdXJjZVJvb3QgPSB0aGlzLl9zb3VyY2VSb290O1xuICAgIH1cbiAgICBpZiAodGhpcy5fc291cmNlc0NvbnRlbnRzKSB7XG4gICAgICBtYXAuc291cmNlc0NvbnRlbnQgPSB0aGlzLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KG1hcC5zb3VyY2VzLCBtYXAuc291cmNlUm9vdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfTtcblxuLyoqXG4gKiBSZW5kZXIgdGhlIHNvdXJjZSBtYXAgYmVpbmcgZ2VuZXJhdGVkIHRvIGEgc3RyaW5nLlxuICovXG5Tb3VyY2VNYXBHZW5lcmF0b3IucHJvdG90eXBlLnRvU3RyaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwR2VuZXJhdG9yX3RvU3RyaW5nKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKTtcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBHZW5lcmF0b3IgPSBTb3VyY2VNYXBHZW5lcmF0b3I7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9zb3VyY2UtbWFwLWdlbmVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICpcbiAqIEJhc2VkIG9uIHRoZSBCYXNlIDY0IFZMUSBpbXBsZW1lbnRhdGlvbiBpbiBDbG9zdXJlIENvbXBpbGVyOlxuICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jbG9zdXJlLWNvbXBpbGVyL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvZGVidWdnaW5nL3NvdXJjZW1hcC9CYXNlNjRWTFEuamF2YVxuICpcbiAqIENvcHlyaWdodCAyMDExIFRoZSBDbG9zdXJlIENvbXBpbGVyIEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmVcbiAqIG1ldDpcbiAqXG4gKiAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZVxuICogICAgY29weXJpZ2h0IG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmdcbiAqICAgIGRpc2NsYWltZXIgaW4gdGhlIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZFxuICogICAgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICogTmVpdGhlciB0aGUgbmFtZSBvZiBHb29nbGUgSW5jLiBub3IgdGhlIG5hbWVzIG9mIGl0c1xuICogICAgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkXG4gKiAgICBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SU1xuICogXCJBUyBJU1wiIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVFxuICogTElNSVRFRCBUTywgVEhFIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SXG4gKiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVFxuICogT1dORVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsXG4gKiBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG4gKiBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcbiAqIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWVxuICogVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCcuL2Jhc2U2NCcpO1xuXG4vLyBBIHNpbmdsZSBiYXNlIDY0IGRpZ2l0IGNhbiBjb250YWluIDYgYml0cyBvZiBkYXRhLiBGb3IgdGhlIGJhc2UgNjQgdmFyaWFibGVcbi8vIGxlbmd0aCBxdWFudGl0aWVzIHdlIHVzZSBpbiB0aGUgc291cmNlIG1hcCBzcGVjLCB0aGUgZmlyc3QgYml0IGlzIHRoZSBzaWduLFxuLy8gdGhlIG5leHQgZm91ciBiaXRzIGFyZSB0aGUgYWN0dWFsIHZhbHVlLCBhbmQgdGhlIDZ0aCBiaXQgaXMgdGhlXG4vLyBjb250aW51YXRpb24gYml0LiBUaGUgY29udGludWF0aW9uIGJpdCB0ZWxscyB1cyB3aGV0aGVyIHRoZXJlIGFyZSBtb3JlXG4vLyBkaWdpdHMgaW4gdGhpcyB2YWx1ZSBmb2xsb3dpbmcgdGhpcyBkaWdpdC5cbi8vXG4vLyAgIENvbnRpbnVhdGlvblxuLy8gICB8ICAgIFNpZ25cbi8vICAgfCAgICB8XG4vLyAgIFYgICAgVlxuLy8gICAxMDEwMTFcblxudmFyIFZMUV9CQVNFX1NISUZUID0gNTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQkFTRSA9IDEgPDwgVkxRX0JBU0VfU0hJRlQ7XG5cbi8vIGJpbmFyeTogMDExMTExXG52YXIgVkxRX0JBU0VfTUFTSyA9IFZMUV9CQVNFIC0gMTtcblxuLy8gYmluYXJ5OiAxMDAwMDBcbnZhciBWTFFfQ09OVElOVUFUSU9OX0JJVCA9IFZMUV9CQVNFO1xuXG4vKipcbiAqIENvbnZlcnRzIGZyb20gYSB0d28tY29tcGxlbWVudCB2YWx1ZSB0byBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDEgYmVjb21lcyAyICgxMCBiaW5hcnkpLCAtMSBiZWNvbWVzIDMgKDExIGJpbmFyeSlcbiAqICAgMiBiZWNvbWVzIDQgKDEwMCBiaW5hcnkpLCAtMiBiZWNvbWVzIDUgKDEwMSBiaW5hcnkpXG4gKi9cbmZ1bmN0aW9uIHRvVkxRU2lnbmVkKGFWYWx1ZSkge1xuICByZXR1cm4gYVZhbHVlIDwgMFxuICAgID8gKCgtYVZhbHVlKSA8PCAxKSArIDFcbiAgICA6IChhVmFsdWUgPDwgMSkgKyAwO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIHRvIGEgdHdvLWNvbXBsZW1lbnQgdmFsdWUgZnJvbSBhIHZhbHVlIHdoZXJlIHRoZSBzaWduIGJpdCBpc1xuICogcGxhY2VkIGluIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQuICBGb3IgZXhhbXBsZSwgYXMgZGVjaW1hbHM6XG4gKiAgIDIgKDEwIGJpbmFyeSkgYmVjb21lcyAxLCAzICgxMSBiaW5hcnkpIGJlY29tZXMgLTFcbiAqICAgNCAoMTAwIGJpbmFyeSkgYmVjb21lcyAyLCA1ICgxMDEgYmluYXJ5KSBiZWNvbWVzIC0yXG4gKi9cbmZ1bmN0aW9uIGZyb21WTFFTaWduZWQoYVZhbHVlKSB7XG4gIHZhciBpc05lZ2F0aXZlID0gKGFWYWx1ZSAmIDEpID09PSAxO1xuICB2YXIgc2hpZnRlZCA9IGFWYWx1ZSA+PiAxO1xuICByZXR1cm4gaXNOZWdhdGl2ZVxuICAgID8gLXNoaWZ0ZWRcbiAgICA6IHNoaWZ0ZWQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYmFzZSA2NCBWTFEgZW5jb2RlZCB2YWx1ZS5cbiAqL1xuZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbiBiYXNlNjRWTFFfZW5jb2RlKGFWYWx1ZSkge1xuICB2YXIgZW5jb2RlZCA9IFwiXCI7XG4gIHZhciBkaWdpdDtcblxuICB2YXIgdmxxID0gdG9WTFFTaWduZWQoYVZhbHVlKTtcblxuICBkbyB7XG4gICAgZGlnaXQgPSB2bHEgJiBWTFFfQkFTRV9NQVNLO1xuICAgIHZscSA+Pj49IFZMUV9CQVNFX1NISUZUO1xuICAgIGlmICh2bHEgPiAwKSB7XG4gICAgICAvLyBUaGVyZSBhcmUgc3RpbGwgbW9yZSBkaWdpdHMgaW4gdGhpcyB2YWx1ZSwgc28gd2UgbXVzdCBtYWtlIHN1cmUgdGhlXG4gICAgICAvLyBjb250aW51YXRpb24gYml0IGlzIG1hcmtlZC5cbiAgICAgIGRpZ2l0IHw9IFZMUV9DT05USU5VQVRJT05fQklUO1xuICAgIH1cbiAgICBlbmNvZGVkICs9IGJhc2U2NC5lbmNvZGUoZGlnaXQpO1xuICB9IHdoaWxlICh2bHEgPiAwKTtcblxuICByZXR1cm4gZW5jb2RlZDtcbn07XG5cbi8qKlxuICogRGVjb2RlcyB0aGUgbmV4dCBiYXNlIDY0IFZMUSB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBzdHJpbmcgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSBhbmQgdGhlIHJlc3Qgb2YgdGhlIHN0cmluZyB2aWEgdGhlIG91dCBwYXJhbWV0ZXIuXG4gKi9cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24gYmFzZTY0VkxRX2RlY29kZShhU3RyLCBhSW5kZXgsIGFPdXRQYXJhbSkge1xuICB2YXIgc3RyTGVuID0gYVN0ci5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSAwO1xuICB2YXIgc2hpZnQgPSAwO1xuICB2YXIgY29udGludWF0aW9uLCBkaWdpdDtcblxuICBkbyB7XG4gICAgaWYgKGFJbmRleCA+PSBzdHJMZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG1vcmUgZGlnaXRzIGluIGJhc2UgNjQgVkxRIHZhbHVlLlwiKTtcbiAgICB9XG5cbiAgICBkaWdpdCA9IGJhc2U2NC5kZWNvZGUoYVN0ci5jaGFyQ29kZUF0KGFJbmRleCsrKSk7XG4gICAgaWYgKGRpZ2l0ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBiYXNlNjQgZGlnaXQ6IFwiICsgYVN0ci5jaGFyQXQoYUluZGV4IC0gMSkpO1xuICAgIH1cblxuICAgIGNvbnRpbnVhdGlvbiA9ICEhKGRpZ2l0ICYgVkxRX0NPTlRJTlVBVElPTl9CSVQpO1xuICAgIGRpZ2l0ICY9IFZMUV9CQVNFX01BU0s7XG4gICAgcmVzdWx0ID0gcmVzdWx0ICsgKGRpZ2l0IDw8IHNoaWZ0KTtcbiAgICBzaGlmdCArPSBWTFFfQkFTRV9TSElGVDtcbiAgfSB3aGlsZSAoY29udGludWF0aW9uKTtcblxuICBhT3V0UGFyYW0udmFsdWUgPSBmcm9tVkxRU2lnbmVkKHJlc3VsdCk7XG4gIGFPdXRQYXJhbS5yZXN0ID0gYUluZGV4O1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Jhc2U2NC12bHEuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgaW50VG9DaGFyTWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nLnNwbGl0KCcnKTtcblxuLyoqXG4gKiBFbmNvZGUgYW4gaW50ZWdlciBpbiB0aGUgcmFuZ2Ugb2YgMCB0byA2MyB0byBhIHNpbmdsZSBiYXNlIDY0IGRpZ2l0LlxuICovXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgaWYgKDAgPD0gbnVtYmVyICYmIG51bWJlciA8IGludFRvQ2hhck1hcC5sZW5ndGgpIHtcbiAgICByZXR1cm4gaW50VG9DaGFyTWFwW251bWJlcl07XG4gIH1cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk11c3QgYmUgYmV0d2VlbiAwIGFuZCA2MzogXCIgKyBudW1iZXIpO1xufTtcblxuLyoqXG4gKiBEZWNvZGUgYSBzaW5nbGUgYmFzZSA2NCBjaGFyYWN0ZXIgY29kZSBkaWdpdCB0byBhbiBpbnRlZ2VyLiBSZXR1cm5zIC0xIG9uXG4gKiBmYWlsdXJlLlxuICovXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uIChjaGFyQ29kZSkge1xuICB2YXIgYmlnQSA9IDY1OyAgICAgLy8gJ0EnXG4gIHZhciBiaWdaID0gOTA7ICAgICAvLyAnWidcblxuICB2YXIgbGl0dGxlQSA9IDk3OyAgLy8gJ2EnXG4gIHZhciBsaXR0bGVaID0gMTIyOyAvLyAneidcblxuICB2YXIgemVybyA9IDQ4OyAgICAgLy8gJzAnXG4gIHZhciBuaW5lID0gNTc7ICAgICAvLyAnOSdcblxuICB2YXIgcGx1cyA9IDQzOyAgICAgLy8gJysnXG4gIHZhciBzbGFzaCA9IDQ3OyAgICAvLyAnLydcblxuICB2YXIgbGl0dGxlT2Zmc2V0ID0gMjY7XG4gIHZhciBudW1iZXJPZmZzZXQgPSA1MjtcblxuICAvLyAwIC0gMjU6IEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXG4gIGlmIChiaWdBIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IGJpZ1opIHtcbiAgICByZXR1cm4gKGNoYXJDb2RlIC0gYmlnQSk7XG4gIH1cblxuICAvLyAyNiAtIDUxOiBhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elxuICBpZiAobGl0dGxlQSA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBsaXR0bGVaKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIGxpdHRsZUEgKyBsaXR0bGVPZmZzZXQpO1xuICB9XG5cbiAgLy8gNTIgLSA2MTogMDEyMzQ1Njc4OVxuICBpZiAoemVybyA8PSBjaGFyQ29kZSAmJiBjaGFyQ29kZSA8PSBuaW5lKSB7XG4gICAgcmV0dXJuIChjaGFyQ29kZSAtIHplcm8gKyBudW1iZXJPZmZzZXQpO1xuICB9XG5cbiAgLy8gNjI6ICtcbiAgaWYgKGNoYXJDb2RlID09IHBsdXMpIHtcbiAgICByZXR1cm4gNjI7XG4gIH1cblxuICAvLyA2MzogL1xuICBpZiAoY2hhckNvZGUgPT0gc2xhc2gpIHtcbiAgICByZXR1cm4gNjM7XG4gIH1cblxuICAvLyBJbnZhbGlkIGJhc2U2NCBkaWdpdC5cbiAgcmV0dXJuIC0xO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2Jhc2U2NC5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8qKlxuICogVGhpcyBpcyBhIGhlbHBlciBmdW5jdGlvbiBmb3IgZ2V0dGluZyB2YWx1ZXMgZnJvbSBwYXJhbWV0ZXIvb3B0aW9uc1xuICogb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0gYXJncyBUaGUgb2JqZWN0IHdlIGFyZSBleHRyYWN0aW5nIHZhbHVlcyBmcm9tXG4gKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgd2UgYXJlIGdldHRpbmcuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHJldHVybiBpZiB0aGUgcHJvcGVydHkgaXMgbWlzc2luZ1xuICogZnJvbSB0aGUgb2JqZWN0LiBJZiB0aGlzIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBhblxuICogZXJyb3Igd2lsbCBiZSB0aHJvd24uXG4gKi9cbmZ1bmN0aW9uIGdldEFyZyhhQXJncywgYU5hbWUsIGFEZWZhdWx0VmFsdWUpIHtcbiAgaWYgKGFOYW1lIGluIGFBcmdzKSB7XG4gICAgcmV0dXJuIGFBcmdzW2FOYW1lXTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIGFEZWZhdWx0VmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdcIicgKyBhTmFtZSArICdcIiBpcyBhIHJlcXVpcmVkIGFyZ3VtZW50LicpO1xuICB9XG59XG5leHBvcnRzLmdldEFyZyA9IGdldEFyZztcblxudmFyIHVybFJlZ2V4cCA9IC9eKD86KFtcXHcrXFwtLl0rKTopP1xcL1xcLyg/OihcXHcrOlxcdyspQCk/KFtcXHcuLV0qKSg/OjooXFxkKykpPyguKikkLztcbnZhciBkYXRhVXJsUmVnZXhwID0gL15kYXRhOi4rXFwsLiskLztcblxuZnVuY3Rpb24gdXJsUGFyc2UoYVVybCkge1xuICB2YXIgbWF0Y2ggPSBhVXJsLm1hdGNoKHVybFJlZ2V4cCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNjaGVtZTogbWF0Y2hbMV0sXG4gICAgYXV0aDogbWF0Y2hbMl0sXG4gICAgaG9zdDogbWF0Y2hbM10sXG4gICAgcG9ydDogbWF0Y2hbNF0sXG4gICAgcGF0aDogbWF0Y2hbNV1cbiAgfTtcbn1cbmV4cG9ydHMudXJsUGFyc2UgPSB1cmxQYXJzZTtcblxuZnVuY3Rpb24gdXJsR2VuZXJhdGUoYVBhcnNlZFVybCkge1xuICB2YXIgdXJsID0gJyc7XG4gIGlmIChhUGFyc2VkVXJsLnNjaGVtZSkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLnNjaGVtZSArICc6JztcbiAgfVxuICB1cmwgKz0gJy8vJztcbiAgaWYgKGFQYXJzZWRVcmwuYXV0aCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmF1dGggKyAnQCc7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwuaG9zdCkge1xuICAgIHVybCArPSBhUGFyc2VkVXJsLmhvc3Q7XG4gIH1cbiAgaWYgKGFQYXJzZWRVcmwucG9ydCkge1xuICAgIHVybCArPSBcIjpcIiArIGFQYXJzZWRVcmwucG9ydFxuICB9XG4gIGlmIChhUGFyc2VkVXJsLnBhdGgpIHtcbiAgICB1cmwgKz0gYVBhcnNlZFVybC5wYXRoO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5leHBvcnRzLnVybEdlbmVyYXRlID0gdXJsR2VuZXJhdGU7XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIHBhdGgsIG9yIHRoZSBwYXRoIHBvcnRpb24gb2YgYSBVUkw6XG4gKlxuICogLSBSZXBsYWNlcyBjb25zZWN1dGl2ZSBzbGFzaGVzIHdpdGggb25lIHNsYXNoLlxuICogLSBSZW1vdmVzIHVubmVjZXNzYXJ5ICcuJyBwYXJ0cy5cbiAqIC0gUmVtb3ZlcyB1bm5lY2Vzc2FyeSAnPGRpcj4vLi4nIHBhcnRzLlxuICpcbiAqIEJhc2VkIG9uIGNvZGUgaW4gdGhlIE5vZGUuanMgJ3BhdGgnIGNvcmUgbW9kdWxlLlxuICpcbiAqIEBwYXJhbSBhUGF0aCBUaGUgcGF0aCBvciB1cmwgdG8gbm9ybWFsaXplLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemUoYVBhdGgpIHtcbiAgdmFyIHBhdGggPSBhUGF0aDtcbiAgdmFyIHVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgaWYgKHVybCkge1xuICAgIGlmICghdXJsLnBhdGgpIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG4gICAgcGF0aCA9IHVybC5wYXRoO1xuICB9XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpO1xuXG4gIHZhciBwYXJ0cyA9IHBhdGguc3BsaXQoL1xcLysvKTtcbiAgZm9yICh2YXIgcGFydCwgdXAgPSAwLCBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBwYXJ0ID0gcGFydHNbaV07XG4gICAgaWYgKHBhcnQgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gJy4uJykge1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwID4gMCkge1xuICAgICAgaWYgKHBhcnQgPT09ICcnKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCBwYXJ0IGlzIGJsYW5rIGlmIHRoZSBwYXRoIGlzIGFic29sdXRlLiBUcnlpbmcgdG8gZ29cbiAgICAgICAgLy8gYWJvdmUgdGhlIHJvb3QgaXMgYSBuby1vcC4gVGhlcmVmb3JlIHdlIGNhbiByZW1vdmUgYWxsICcuLicgcGFydHNcbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgdGhlIHJvb3QuXG4gICAgICAgIHBhcnRzLnNwbGljZShpICsgMSwgdXApO1xuICAgICAgICB1cCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJ0cy5zcGxpY2UoaSwgMik7XG4gICAgICAgIHVwLS07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHBhdGggPSBwYXJ0cy5qb2luKCcvJyk7XG5cbiAgaWYgKHBhdGggPT09ICcnKSB7XG4gICAgcGF0aCA9IGlzQWJzb2x1dGUgPyAnLycgOiAnLic7XG4gIH1cblxuICBpZiAodXJsKSB7XG4gICAgdXJsLnBhdGggPSBwYXRoO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZSh1cmwpO1xuICB9XG4gIHJldHVybiBwYXRoO1xufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG5cbi8qKlxuICogSm9pbnMgdHdvIHBhdGhzL1VSTHMuXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBqb2luZWQgd2l0aCB0aGUgcm9vdC5cbiAqXG4gKiAtIElmIGFQYXRoIGlzIGEgVVJMIG9yIGEgZGF0YSBVUkksIGFQYXRoIGlzIHJldHVybmVkLCB1bmxlc3MgYVBhdGggaXMgYVxuICogICBzY2hlbWUtcmVsYXRpdmUgVVJMOiBUaGVuIHRoZSBzY2hlbWUgb2YgYVJvb3QsIGlmIGFueSwgaXMgcHJlcGVuZGVkXG4gKiAgIGZpcnN0LlxuICogLSBPdGhlcndpc2UgYVBhdGggaXMgYSBwYXRoLiBJZiBhUm9vdCBpcyBhIFVSTCwgdGhlbiBpdHMgcGF0aCBwb3J0aW9uXG4gKiAgIGlzIHVwZGF0ZWQgd2l0aCB0aGUgcmVzdWx0IGFuZCBhUm9vdCBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlIHRoZSByZXN1bHRcbiAqICAgaXMgcmV0dXJuZWQuXG4gKiAgIC0gSWYgYVBhdGggaXMgYWJzb2x1dGUsIHRoZSByZXN1bHQgaXMgYVBhdGguXG4gKiAgIC0gT3RoZXJ3aXNlIHRoZSB0d28gcGF0aHMgYXJlIGpvaW5lZCB3aXRoIGEgc2xhc2guXG4gKiAtIEpvaW5pbmcgZm9yIGV4YW1wbGUgJ2h0dHA6Ly8nIGFuZCAnd3d3LmV4YW1wbGUuY29tJyBpcyBhbHNvIHN1cHBvcnRlZC5cbiAqL1xuZnVuY3Rpb24gam9pbihhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuICBpZiAoYVBhdGggPT09IFwiXCIpIHtcbiAgICBhUGF0aCA9IFwiLlwiO1xuICB9XG4gIHZhciBhUGF0aFVybCA9IHVybFBhcnNlKGFQYXRoKTtcbiAgdmFyIGFSb290VXJsID0gdXJsUGFyc2UoYVJvb3QpO1xuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdCA9IGFSb290VXJsLnBhdGggfHwgJy8nO1xuICB9XG5cbiAgLy8gYGpvaW4oZm9vLCAnLy93d3cuZXhhbXBsZS5vcmcnKWBcbiAgaWYgKGFQYXRoVXJsICYmICFhUGF0aFVybC5zY2hlbWUpIHtcbiAgICBpZiAoYVJvb3RVcmwpIHtcbiAgICAgIGFQYXRoVXJsLnNjaGVtZSA9IGFSb290VXJsLnNjaGVtZTtcbiAgICB9XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFQYXRoVXJsKTtcbiAgfVxuXG4gIGlmIChhUGF0aFVybCB8fCBhUGF0aC5tYXRjaChkYXRhVXJsUmVnZXhwKSkge1xuICAgIHJldHVybiBhUGF0aDtcbiAgfVxuXG4gIC8vIGBqb2luKCdodHRwOi8vJywgJ3d3dy5leGFtcGxlLmNvbScpYFxuICBpZiAoYVJvb3RVcmwgJiYgIWFSb290VXJsLmhvc3QgJiYgIWFSb290VXJsLnBhdGgpIHtcbiAgICBhUm9vdFVybC5ob3N0ID0gYVBhdGg7XG4gICAgcmV0dXJuIHVybEdlbmVyYXRlKGFSb290VXJsKTtcbiAgfVxuXG4gIHZhciBqb2luZWQgPSBhUGF0aC5jaGFyQXQoMCkgPT09ICcvJ1xuICAgID8gYVBhdGhcbiAgICA6IG5vcm1hbGl6ZShhUm9vdC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIGFQYXRoKTtcblxuICBpZiAoYVJvb3RVcmwpIHtcbiAgICBhUm9vdFVybC5wYXRoID0gam9pbmVkO1xuICAgIHJldHVybiB1cmxHZW5lcmF0ZShhUm9vdFVybCk7XG4gIH1cbiAgcmV0dXJuIGpvaW5lZDtcbn1cbmV4cG9ydHMuam9pbiA9IGpvaW47XG5cbmV4cG9ydHMuaXNBYnNvbHV0ZSA9IGZ1bmN0aW9uIChhUGF0aCkge1xuICByZXR1cm4gYVBhdGguY2hhckF0KDApID09PSAnLycgfHwgdXJsUmVnZXhwLnRlc3QoYVBhdGgpO1xufTtcblxuLyoqXG4gKiBNYWtlIGEgcGF0aCByZWxhdGl2ZSB0byBhIFVSTCBvciBhbm90aGVyIHBhdGguXG4gKlxuICogQHBhcmFtIGFSb290IFRoZSByb290IHBhdGggb3IgVVJMLlxuICogQHBhcmFtIGFQYXRoIFRoZSBwYXRoIG9yIFVSTCB0byBiZSBtYWRlIHJlbGF0aXZlIHRvIGFSb290LlxuICovXG5mdW5jdGlvbiByZWxhdGl2ZShhUm9vdCwgYVBhdGgpIHtcbiAgaWYgKGFSb290ID09PSBcIlwiKSB7XG4gICAgYVJvb3QgPSBcIi5cIjtcbiAgfVxuXG4gIGFSb290ID0gYVJvb3QucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhdGggdG8gYmUgYWJvdmUgdGhlIHJvb3QuIEluIHRoaXMgY2FzZSwgc2ltcGx5XG4gIC8vIGNoZWNraW5nIHdoZXRoZXIgdGhlIHJvb3QgaXMgYSBwcmVmaXggb2YgdGhlIHBhdGggd29uJ3Qgd29yay4gSW5zdGVhZCwgd2VcbiAgLy8gbmVlZCB0byByZW1vdmUgY29tcG9uZW50cyBmcm9tIHRoZSByb290IG9uZSBieSBvbmUsIHVudGlsIGVpdGhlciB3ZSBmaW5kXG4gIC8vIGEgcHJlZml4IHRoYXQgZml0cywgb3Igd2UgcnVuIG91dCBvZiBjb21wb25lbnRzIHRvIHJlbW92ZS5cbiAgdmFyIGxldmVsID0gMDtcbiAgd2hpbGUgKGFQYXRoLmluZGV4T2YoYVJvb3QgKyAnLycpICE9PSAwKSB7XG4gICAgdmFyIGluZGV4ID0gYVJvb3QubGFzdEluZGV4T2YoXCIvXCIpO1xuICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgIHJldHVybiBhUGF0aDtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgb25seSBwYXJ0IG9mIHRoZSByb290IHRoYXQgaXMgbGVmdCBpcyB0aGUgc2NoZW1lIChpLmUuIGh0dHA6Ly8sXG4gICAgLy8gZmlsZTovLy8sIGV0Yy4pLCBvbmUgb3IgbW9yZSBzbGFzaGVzICgvKSwgb3Igc2ltcGx5IG5vdGhpbmcgYXQgYWxsLCB3ZVxuICAgIC8vIGhhdmUgZXhoYXVzdGVkIGFsbCBjb21wb25lbnRzLCBzbyB0aGUgcGF0aCBpcyBub3QgcmVsYXRpdmUgdG8gdGhlIHJvb3QuXG4gICAgYVJvb3QgPSBhUm9vdC5zbGljZSgwLCBpbmRleCk7XG4gICAgaWYgKGFSb290Lm1hdGNoKC9eKFteXFwvXSs6XFwvKT9cXC8qJC8pKSB7XG4gICAgICByZXR1cm4gYVBhdGg7XG4gICAgfVxuXG4gICAgKytsZXZlbDtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSB3ZSBhZGQgYSBcIi4uL1wiIGZvciBlYWNoIGNvbXBvbmVudCB3ZSByZW1vdmVkIGZyb20gdGhlIHJvb3QuXG4gIHJldHVybiBBcnJheShsZXZlbCArIDEpLmpvaW4oXCIuLi9cIikgKyBhUGF0aC5zdWJzdHIoYVJvb3QubGVuZ3RoICsgMSk7XG59XG5leHBvcnRzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG5cbnZhciBzdXBwb3J0c051bGxQcm90byA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICByZXR1cm4gISgnX19wcm90b19fJyBpbiBvYmopO1xufSgpKTtcblxuZnVuY3Rpb24gaWRlbnRpdHkgKHMpIHtcbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogQmVjYXVzZSBiZWhhdmlvciBnb2VzIHdhY2t5IHdoZW4geW91IHNldCBgX19wcm90b19fYCBvbiBvYmplY3RzLCB3ZVxuICogaGF2ZSB0byBwcmVmaXggYWxsIHRoZSBzdHJpbmdzIGluIG91ciBzZXQgd2l0aCBhbiBhcmJpdHJhcnkgY2hhcmFjdGVyLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL3B1bGwvMzEgYW5kXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8zMFxuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5mdW5jdGlvbiB0b1NldFN0cmluZyhhU3RyKSB7XG4gIGlmIChpc1Byb3RvU3RyaW5nKGFTdHIpKSB7XG4gICAgcmV0dXJuICckJyArIGFTdHI7XG4gIH1cblxuICByZXR1cm4gYVN0cjtcbn1cbmV4cG9ydHMudG9TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogdG9TZXRTdHJpbmc7XG5cbmZ1bmN0aW9uIGZyb21TZXRTdHJpbmcoYVN0cikge1xuICBpZiAoaXNQcm90b1N0cmluZyhhU3RyKSkge1xuICAgIHJldHVybiBhU3RyLnNsaWNlKDEpO1xuICB9XG5cbiAgcmV0dXJuIGFTdHI7XG59XG5leHBvcnRzLmZyb21TZXRTdHJpbmcgPSBzdXBwb3J0c051bGxQcm90byA/IGlkZW50aXR5IDogZnJvbVNldFN0cmluZztcblxuZnVuY3Rpb24gaXNQcm90b1N0cmluZyhzKSB7XG4gIGlmICghcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBzLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgOSAvKiBcIl9fcHJvdG9fX1wiLmxlbmd0aCAqLykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChzLmNoYXJDb2RlQXQobGVuZ3RoIC0gMSkgIT09IDk1ICAvKiAnXycgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSAyKSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDMpICE9PSAxMTEgLyogJ28nICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNCkgIT09IDExNiAvKiAndCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA1KSAhPT0gMTExIC8qICdvJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDYpICE9PSAxMTQgLyogJ3InICovIHx8XG4gICAgICBzLmNoYXJDb2RlQXQobGVuZ3RoIC0gNykgIT09IDExMiAvKiAncCcgKi8gfHxcbiAgICAgIHMuY2hhckNvZGVBdChsZW5ndGggLSA4KSAhPT0gOTUgIC8qICdfJyAqLyB8fFxuICAgICAgcy5jaGFyQ29kZUF0KGxlbmd0aCAtIDkpICE9PSA5NSAgLyogJ18nICovKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGxlbmd0aCAtIDEwOyBpID49IDA7IGktLSkge1xuICAgIGlmIChzLmNoYXJDb2RlQXQoaSkgIT09IDM2IC8qICckJyAqLykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENvbXBhcmF0b3IgYmV0d2VlbiB0d28gbWFwcGluZ3Mgd2hlcmUgdGhlIG9yaWdpbmFsIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4sIGJ1dCBkaWZmZXJlbnQgZ2VuZXJhdGVkXG4gKiBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYSBtYXBwaW5nIHdpdGggYVxuICogc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZU9yaWdpbmFsKSB7XG4gIHZhciBjbXAgPSBzdHJjbXAobWFwcGluZ0Euc291cmNlLCBtYXBwaW5nQi5zb3VyY2UpO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsTGluZSAtIG1hcHBpbmdCLm9yaWdpbmFsTGluZTtcbiAgaWYgKGNtcCAhPT0gMCkge1xuICAgIHJldHVybiBjbXA7XG4gIH1cblxuICBjbXAgPSBtYXBwaW5nQS5vcmlnaW5hbENvbHVtbiAtIG1hcHBpbmdCLm9yaWdpbmFsQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlT3JpZ2luYWwpIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLmdlbmVyYXRlZExpbmUgLSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIHJldHVybiBzdHJjbXAobWFwcGluZ0EubmFtZSwgbWFwcGluZ0IubmFtZSk7XG59XG5leHBvcnRzLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zID0gY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnM7XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGRlZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBpbmRpY2VzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKlxuICogT3B0aW9uYWxseSBwYXNzIGluIGB0cnVlYCBhcyBgb25seUNvbXBhcmVHZW5lcmF0ZWRgIHRvIGNvbnNpZGVyIHR3b1xuICogbWFwcGluZ3Mgd2l0aCB0aGUgc2FtZSBnZW5lcmF0ZWQgbGluZSBhbmQgY29sdW1uLCBidXQgZGlmZmVyZW50XG4gKiBzb3VyY2UvbmFtZS9vcmlnaW5hbCBsaW5lIGFuZCBjb2x1bW4gdGhlIHNhbWUuIFVzZWZ1bCB3aGVuIHNlYXJjaGluZyBmb3IgYVxuICogbWFwcGluZyB3aXRoIGEgc3R1YmJlZCBvdXQgbWFwcGluZy5cbiAqL1xuZnVuY3Rpb24gY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQobWFwcGluZ0EsIG1hcHBpbmdCLCBvbmx5Q29tcGFyZUdlbmVyYXRlZCkge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwIHx8IG9ubHlDb21wYXJlR2VuZXJhdGVkKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNEZWZsYXRlZDtcblxuZnVuY3Rpb24gc3RyY21wKGFTdHIxLCBhU3RyMikge1xuICBpZiAoYVN0cjEgPT09IGFTdHIyKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBpZiAoYVN0cjEgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTsgLy8gYVN0cjIgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMiA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTsgLy8gYVN0cjEgIT09IG51bGxcbiAgfVxuXG4gIGlmIChhU3RyMSA+IGFTdHIyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQ29tcGFyYXRvciBiZXR3ZWVuIHR3byBtYXBwaW5ncyB3aXRoIGluZmxhdGVkIHNvdXJjZSBhbmQgbmFtZSBzdHJpbmdzIHdoZXJlXG4gKiB0aGUgZ2VuZXJhdGVkIHBvc2l0aW9ucyBhcmUgY29tcGFyZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0luZmxhdGVkKG1hcHBpbmdBLCBtYXBwaW5nQikge1xuICB2YXIgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkTGluZSAtIG1hcHBpbmdCLmdlbmVyYXRlZExpbmU7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0EuZ2VuZXJhdGVkQ29sdW1uIC0gbWFwcGluZ0IuZ2VuZXJhdGVkQ29sdW1uO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IHN0cmNtcChtYXBwaW5nQS5zb3VyY2UsIG1hcHBpbmdCLnNvdXJjZSk7XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgY21wID0gbWFwcGluZ0Eub3JpZ2luYWxMaW5lIC0gbWFwcGluZ0Iub3JpZ2luYWxMaW5lO1xuICBpZiAoY21wICE9PSAwKSB7XG4gICAgcmV0dXJuIGNtcDtcbiAgfVxuXG4gIGNtcCA9IG1hcHBpbmdBLm9yaWdpbmFsQ29sdW1uIC0gbWFwcGluZ0Iub3JpZ2luYWxDb2x1bW47XG4gIGlmIChjbXAgIT09IDApIHtcbiAgICByZXR1cm4gY21wO1xuICB9XG5cbiAgcmV0dXJuIHN0cmNtcChtYXBwaW5nQS5uYW1lLCBtYXBwaW5nQi5uYW1lKTtcbn1cbmV4cG9ydHMuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zSW5mbGF0ZWQgPSBjb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZDtcblxuLyoqXG4gKiBTdHJpcCBhbnkgSlNPTiBYU1NJIGF2b2lkYW5jZSBwcmVmaXggZnJvbSB0aGUgc3RyaW5nIChhcyBkb2N1bWVudGVkXG4gKiBpbiB0aGUgc291cmNlIG1hcHMgc3BlY2lmaWNhdGlvbiksIGFuZCB0aGVuIHBhcnNlIHRoZSBzdHJpbmcgYXNcbiAqIEpTT04uXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU291cmNlTWFwSW5wdXQoc3RyKSB7XG4gIHJldHVybiBKU09OLnBhcnNlKHN0ci5yZXBsYWNlKC9eXFwpXX0nW15cXG5dKlxcbi8sICcnKSk7XG59XG5leHBvcnRzLnBhcnNlU291cmNlTWFwSW5wdXQgPSBwYXJzZVNvdXJjZU1hcElucHV0O1xuXG4vKipcbiAqIENvbXB1dGUgdGhlIFVSTCBvZiBhIHNvdXJjZSBnaXZlbiB0aGUgdGhlIHNvdXJjZSByb290LCB0aGUgc291cmNlJ3NcbiAqIFVSTCwgYW5kIHRoZSBzb3VyY2UgbWFwJ3MgVVJMLlxuICovXG5mdW5jdGlvbiBjb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZVVSTCwgc291cmNlTWFwVVJMKSB7XG4gIHNvdXJjZVVSTCA9IHNvdXJjZVVSTCB8fCAnJztcblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIC8vIFRoaXMgZm9sbG93cyB3aGF0IENocm9tZSBkb2VzLlxuICAgIGlmIChzb3VyY2VSb290W3NvdXJjZVJvb3QubGVuZ3RoIC0gMV0gIT09ICcvJyAmJiBzb3VyY2VVUkxbMF0gIT09ICcvJykge1xuICAgICAgc291cmNlUm9vdCArPSAnLyc7XG4gICAgfVxuICAgIC8vIFRoZSBzcGVjIHNheXM6XG4gICAgLy8gICBMaW5lIDQ6IEFuIG9wdGlvbmFsIHNvdXJjZSByb290LCB1c2VmdWwgZm9yIHJlbG9jYXRpbmcgc291cmNlXG4gICAgLy8gICBmaWxlcyBvbiBhIHNlcnZlciBvciByZW1vdmluZyByZXBlYXRlZCB2YWx1ZXMgaW4gdGhlXG4gICAgLy8gICDigJxzb3VyY2Vz4oCdIGVudHJ5LiAgVGhpcyB2YWx1ZSBpcyBwcmVwZW5kZWQgdG8gdGhlIGluZGl2aWR1YWxcbiAgICAvLyAgIGVudHJpZXMgaW4gdGhlIOKAnHNvdXJjZeKAnSBmaWVsZC5cbiAgICBzb3VyY2VVUkwgPSBzb3VyY2VSb290ICsgc291cmNlVVJMO1xuICB9XG5cbiAgLy8gSGlzdG9yaWNhbGx5LCBTb3VyY2VNYXBDb25zdW1lciBkaWQgbm90IHRha2UgdGhlIHNvdXJjZU1hcFVSTCBhc1xuICAvLyBhIHBhcmFtZXRlci4gIFRoaXMgbW9kZSBpcyBzdGlsbCBzb21ld2hhdCBzdXBwb3J0ZWQsIHdoaWNoIGlzIHdoeVxuICAvLyB0aGlzIGNvZGUgYmxvY2sgaXMgY29uZGl0aW9uYWwuICBIb3dldmVyLCBpdCdzIHByZWZlcmFibGUgdG8gcGFzc1xuICAvLyB0aGUgc291cmNlIG1hcCBVUkwgdG8gU291cmNlTWFwQ29uc3VtZXIsIHNvIHRoYXQgdGhpcyBmdW5jdGlvblxuICAvLyBjYW4gaW1wbGVtZW50IHRoZSBzb3VyY2UgVVJMIHJlc29sdXRpb24gYWxnb3JpdGhtIGFzIG91dGxpbmVkIGluXG4gIC8vIHRoZSBzcGVjLiAgVGhpcyBibG9jayBpcyBiYXNpY2FsbHkgdGhlIGVxdWl2YWxlbnQgb2Y6XG4gIC8vICAgIG5ldyBVUkwoc291cmNlVVJMLCBzb3VyY2VNYXBVUkwpLnRvU3RyaW5nKClcbiAgLy8gLi4uIGV4Y2VwdCBpdCBhdm9pZHMgdXNpbmcgVVJMLCB3aGljaCB3YXNuJ3QgYXZhaWxhYmxlIGluIHRoZVxuICAvLyBvbGRlciByZWxlYXNlcyBvZiBub2RlIHN0aWxsIHN1cHBvcnRlZCBieSB0aGlzIGxpYnJhcnkuXG4gIC8vXG4gIC8vIFRoZSBzcGVjIHNheXM6XG4gIC8vICAgSWYgdGhlIHNvdXJjZXMgYXJlIG5vdCBhYnNvbHV0ZSBVUkxzIGFmdGVyIHByZXBlbmRpbmcgb2YgdGhlXG4gIC8vICAg4oCcc291cmNlUm9vdOKAnSwgdGhlIHNvdXJjZXMgYXJlIHJlc29sdmVkIHJlbGF0aXZlIHRvIHRoZVxuICAvLyAgIFNvdXJjZU1hcCAobGlrZSByZXNvbHZpbmcgc2NyaXB0IHNyYyBpbiBhIGh0bWwgZG9jdW1lbnQpLlxuICBpZiAoc291cmNlTWFwVVJMKSB7XG4gICAgdmFyIHBhcnNlZCA9IHVybFBhcnNlKHNvdXJjZU1hcFVSTCk7XG4gICAgaWYgKCFwYXJzZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInNvdXJjZU1hcFVSTCBjb3VsZCBub3QgYmUgcGFyc2VkXCIpO1xuICAgIH1cbiAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgIC8vIFN0cmlwIHRoZSBsYXN0IHBhdGggY29tcG9uZW50LCBidXQga2VlcCB0aGUgXCIvXCIuXG4gICAgICB2YXIgaW5kZXggPSBwYXJzZWQucGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBwYXJzZWQucGF0aC5zdWJzdHJpbmcoMCwgaW5kZXggKyAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc291cmNlVVJMID0gam9pbih1cmxHZW5lcmF0ZShwYXJzZWQpLCBzb3VyY2VVUkwpO1xuICB9XG5cbiAgcmV0dXJuIG5vcm1hbGl6ZShzb3VyY2VVUkwpO1xufVxuZXhwb3J0cy5jb21wdXRlU291cmNlVVJMID0gY29tcHV0ZVNvdXJjZVVSTDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgaGFzTmF0aXZlTWFwID0gdHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuLyoqXG4gKiBBIGRhdGEgc3RydWN0dXJlIHdoaWNoIGlzIGEgY29tYmluYXRpb24gb2YgYW4gYXJyYXkgYW5kIGEgc2V0LiBBZGRpbmcgYSBuZXdcbiAqIG1lbWJlciBpcyBPKDEpLCB0ZXN0aW5nIGZvciBtZW1iZXJzaGlwIGlzIE8oMSksIGFuZCBmaW5kaW5nIHRoZSBpbmRleCBvZiBhblxuICogZWxlbWVudCBpcyBPKDEpLiBSZW1vdmluZyBlbGVtZW50cyBmcm9tIHRoZSBzZXQgaXMgbm90IHN1cHBvcnRlZC4gT25seVxuICogc3RyaW5ncyBhcmUgc3VwcG9ydGVkIGZvciBtZW1iZXJzaGlwLlxuICovXG5mdW5jdGlvbiBBcnJheVNldCgpIHtcbiAgdGhpcy5fYXJyYXkgPSBbXTtcbiAgdGhpcy5fc2V0ID0gaGFzTmF0aXZlTWFwID8gbmV3IE1hcCgpIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcbn1cblxuLyoqXG4gKiBTdGF0aWMgbWV0aG9kIGZvciBjcmVhdGluZyBBcnJheVNldCBpbnN0YW5jZXMgZnJvbSBhbiBleGlzdGluZyBhcnJheS5cbiAqL1xuQXJyYXlTZXQuZnJvbUFycmF5ID0gZnVuY3Rpb24gQXJyYXlTZXRfZnJvbUFycmF5KGFBcnJheSwgYUFsbG93RHVwbGljYXRlcykge1xuICB2YXIgc2V0ID0gbmV3IEFycmF5U2V0KCk7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhQXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzZXQuYWRkKGFBcnJheVtpXSwgYUFsbG93RHVwbGljYXRlcyk7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhvdyBtYW55IHVuaXF1ZSBpdGVtcyBhcmUgaW4gdGhpcyBBcnJheVNldC4gSWYgZHVwbGljYXRlcyBoYXZlIGJlZW5cbiAqIGFkZGVkLCB0aGFuIHRob3NlIGRvIG5vdCBjb3VudCB0b3dhcmRzIHRoZSBzaXplLlxuICpcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5BcnJheVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIEFycmF5U2V0X3NpemUoKSB7XG4gIHJldHVybiBoYXNOYXRpdmVNYXAgPyB0aGlzLl9zZXQuc2l6ZSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMuX3NldCkubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHN0cmluZyB0byB0aGlzIHNldC5cbiAqXG4gKiBAcGFyYW0gU3RyaW5nIGFTdHJcbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIEFycmF5U2V0X2FkZChhU3RyLCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gIHZhciBzU3RyID0gaGFzTmF0aXZlTWFwID8gYVN0ciA6IHV0aWwudG9TZXRTdHJpbmcoYVN0cik7XG4gIHZhciBpc0R1cGxpY2F0ZSA9IGhhc05hdGl2ZU1hcCA/IHRoaXMuaGFzKGFTdHIpIDogaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKTtcbiAgdmFyIGlkeCA9IHRoaXMuX2FycmF5Lmxlbmd0aDtcbiAgaWYgKCFpc0R1cGxpY2F0ZSB8fCBhQWxsb3dEdXBsaWNhdGVzKSB7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhU3RyKTtcbiAgfVxuICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgaWYgKGhhc05hdGl2ZU1hcCkge1xuICAgICAgdGhpcy5fc2V0LnNldChhU3RyLCBpZHgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZXRbc1N0cl0gPSBpZHg7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIElzIHRoZSBnaXZlbiBzdHJpbmcgYSBtZW1iZXIgb2YgdGhpcyBzZXQ/XG4gKlxuICogQHBhcmFtIFN0cmluZyBhU3RyXG4gKi9cbkFycmF5U2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBBcnJheVNldF9oYXMoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NldC5oYXMoYVN0cik7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHNTdHIgPSB1dGlsLnRvU2V0U3RyaW5nKGFTdHIpO1xuICAgIHJldHVybiBoYXMuY2FsbCh0aGlzLl9zZXQsIHNTdHIpO1xuICB9XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGluZGV4IG9mIHRoZSBnaXZlbiBzdHJpbmcgaW4gdGhlIGFycmF5P1xuICpcbiAqIEBwYXJhbSBTdHJpbmcgYVN0clxuICovXG5BcnJheVNldC5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIEFycmF5U2V0X2luZGV4T2YoYVN0cikge1xuICBpZiAoaGFzTmF0aXZlTWFwKSB7XG4gICAgdmFyIGlkeCA9IHRoaXMuX3NldC5nZXQoYVN0cik7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBpZHg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBzU3RyID0gdXRpbC50b1NldFN0cmluZyhhU3RyKTtcbiAgICBpZiAoaGFzLmNhbGwodGhpcy5fc2V0LCBzU3RyKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NldFtzU3RyXTtcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTdHIgKyAnXCIgaXMgbm90IGluIHRoZSBzZXQuJyk7XG59O1xuXG4vKipcbiAqIFdoYXQgaXMgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4P1xuICpcbiAqIEBwYXJhbSBOdW1iZXIgYUlkeFxuICovXG5BcnJheVNldC5wcm90b3R5cGUuYXQgPSBmdW5jdGlvbiBBcnJheVNldF9hdChhSWR4KSB7XG4gIGlmIChhSWR4ID49IDAgJiYgYUlkeCA8IHRoaXMuX2FycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLl9hcnJheVthSWR4XTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ05vIGVsZW1lbnQgaW5kZXhlZCBieSAnICsgYUlkeCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgc2V0ICh3aGljaCBoYXMgdGhlIHByb3BlciBpbmRpY2VzXG4gKiBpbmRpY2F0ZWQgYnkgaW5kZXhPZikuIE5vdGUgdGhhdCB0aGlzIGlzIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgYXJyYXkgdXNlZFxuICogZm9yIHN0b3JpbmcgdGhlIG1lbWJlcnMgc28gdGhhdCBubyBvbmUgY2FuIG1lc3Mgd2l0aCBpbnRlcm5hbCBzdGF0ZS5cbiAqL1xuQXJyYXlTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBBcnJheVNldF90b0FycmF5KCkge1xuICByZXR1cm4gdGhpcy5fYXJyYXkuc2xpY2UoKTtcbn07XG5cbmV4cG9ydHMuQXJyYXlTZXQgPSBBcnJheVNldDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbGliL2FycmF5LXNldC5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTQgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgbWFwcGluZ0IgaXMgYWZ0ZXIgbWFwcGluZ0Egd2l0aCByZXNwZWN0IHRvIGdlbmVyYXRlZFxuICogcG9zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlZFBvc2l0aW9uQWZ0ZXIobWFwcGluZ0EsIG1hcHBpbmdCKSB7XG4gIC8vIE9wdGltaXplZCBmb3IgbW9zdCBjb21tb24gY2FzZVxuICB2YXIgbGluZUEgPSBtYXBwaW5nQS5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgbGluZUIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRMaW5lO1xuICB2YXIgY29sdW1uQSA9IG1hcHBpbmdBLmdlbmVyYXRlZENvbHVtbjtcbiAgdmFyIGNvbHVtbkIgPSBtYXBwaW5nQi5nZW5lcmF0ZWRDb2x1bW47XG4gIHJldHVybiBsaW5lQiA+IGxpbmVBIHx8IGxpbmVCID09IGxpbmVBICYmIGNvbHVtbkIgPj0gY29sdW1uQSB8fFxuICAgICAgICAgdXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZChtYXBwaW5nQSwgbWFwcGluZ0IpIDw9IDA7XG59XG5cbi8qKlxuICogQSBkYXRhIHN0cnVjdHVyZSB0byBwcm92aWRlIGEgc29ydGVkIHZpZXcgb2YgYWNjdW11bGF0ZWQgbWFwcGluZ3MgaW4gYVxuICogcGVyZm9ybWFuY2UgY29uc2Npb3VzIG1hbm5lci4gSXQgdHJhZGVzIGEgbmVnbGliYWJsZSBvdmVyaGVhZCBpbiBnZW5lcmFsXG4gKiBjYXNlIGZvciBhIGxhcmdlIHNwZWVkdXAgaW4gY2FzZSBvZiBtYXBwaW5ncyBiZWluZyBhZGRlZCBpbiBvcmRlci5cbiAqL1xuZnVuY3Rpb24gTWFwcGluZ0xpc3QoKSB7XG4gIHRoaXMuX2FycmF5ID0gW107XG4gIHRoaXMuX3NvcnRlZCA9IHRydWU7XG4gIC8vIFNlcnZlcyBhcyBpbmZpbXVtXG4gIHRoaXMuX2xhc3QgPSB7Z2VuZXJhdGVkTGluZTogLTEsIGdlbmVyYXRlZENvbHVtbjogMH07XG59XG5cbi8qKlxuICogSXRlcmF0ZSB0aHJvdWdoIGludGVybmFsIGl0ZW1zLiBUaGlzIG1ldGhvZCB0YWtlcyB0aGUgc2FtZSBhcmd1bWVudHMgdGhhdFxuICogYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCB0YWtlcy5cbiAqXG4gKiBOT1RFOiBUaGUgb3JkZXIgb2YgdGhlIG1hcHBpbmdzIGlzIE5PVCBndWFyYW50ZWVkLlxuICovXG5NYXBwaW5nTGlzdC5wcm90b3R5cGUudW5zb3J0ZWRGb3JFYWNoID1cbiAgZnVuY3Rpb24gTWFwcGluZ0xpc3RfZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKSB7XG4gICAgdGhpcy5fYXJyYXkuZm9yRWFjaChhQ2FsbGJhY2ssIGFUaGlzQXJnKTtcbiAgfTtcblxuLyoqXG4gKiBBZGQgdGhlIGdpdmVuIHNvdXJjZSBtYXBwaW5nLlxuICpcbiAqIEBwYXJhbSBPYmplY3QgYU1hcHBpbmdcbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIE1hcHBpbmdMaXN0X2FkZChhTWFwcGluZykge1xuICBpZiAoZ2VuZXJhdGVkUG9zaXRpb25BZnRlcih0aGlzLl9sYXN0LCBhTWFwcGluZykpIHtcbiAgICB0aGlzLl9sYXN0ID0gYU1hcHBpbmc7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fc29ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fYXJyYXkucHVzaChhTWFwcGluZyk7XG4gIH1cbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmxhdCwgc29ydGVkIGFycmF5IG9mIG1hcHBpbmdzLiBUaGUgbWFwcGluZ3MgYXJlIHNvcnRlZCBieVxuICogZ2VuZXJhdGVkIHBvc2l0aW9uLlxuICpcbiAqIFdBUk5JTkc6IFRoaXMgbWV0aG9kIHJldHVybnMgaW50ZXJuYWwgZGF0YSB3aXRob3V0IGNvcHlpbmcsIGZvclxuICogcGVyZm9ybWFuY2UuIFRoZSByZXR1cm4gdmFsdWUgbXVzdCBOT1QgYmUgbXV0YXRlZCwgYW5kIHNob3VsZCBiZSB0cmVhdGVkIGFzXG4gKiBhbiBpbW11dGFibGUgYm9ycm93LiBJZiB5b3Ugd2FudCB0byB0YWtlIG93bmVyc2hpcCwgeW91IG11c3QgbWFrZSB5b3VyIG93blxuICogY29weS5cbiAqL1xuTWFwcGluZ0xpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiBNYXBwaW5nTGlzdF90b0FycmF5KCkge1xuICBpZiAoIXRoaXMuX3NvcnRlZCkge1xuICAgIHRoaXMuX2FycmF5LnNvcnQodXRpbC5jb21wYXJlQnlHZW5lcmF0ZWRQb3NpdGlvbnNJbmZsYXRlZCk7XG4gICAgdGhpcy5fc29ydGVkID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gdGhpcy5fYXJyYXk7XG59O1xuXG5leHBvcnRzLk1hcHBpbmdMaXN0ID0gTWFwcGluZ0xpc3Q7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2xpYi9tYXBwaW5nLWxpc3QuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyogLSotIE1vZGU6IGpzOyBqcy1pbmRlbnQtbGV2ZWw6IDI7IC0qLSAqL1xuLypcbiAqIENvcHlyaWdodCAyMDExIE1vemlsbGEgRm91bmRhdGlvbiBhbmQgY29udHJpYnV0b3JzXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTmV3IEJTRCBsaWNlbnNlLiBTZWUgTElDRU5TRSBvcjpcbiAqIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAqL1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xudmFyIGJpbmFyeVNlYXJjaCA9IHJlcXVpcmUoJy4vYmluYXJ5LXNlYXJjaCcpO1xudmFyIEFycmF5U2V0ID0gcmVxdWlyZSgnLi9hcnJheS1zZXQnKS5BcnJheVNldDtcbnZhciBiYXNlNjRWTFEgPSByZXF1aXJlKCcuL2Jhc2U2NC12bHEnKTtcbnZhciBxdWlja1NvcnQgPSByZXF1aXJlKCcuL3F1aWNrLXNvcnQnKS5xdWlja1NvcnQ7XG5cbmZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICByZXR1cm4gc291cmNlTWFwLnNlY3Rpb25zICE9IG51bGxcbiAgICA/IG5ldyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKVxuICAgIDogbmV3IEJhc2ljU291cmNlTWFwQ29uc3VtZXIoc291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcCA9IGZ1bmN0aW9uKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgcmV0dXJuIEJhc2ljU291cmNlTWFwQ29uc3VtZXIuZnJvbVNvdXJjZU1hcChhU291cmNlTWFwLCBhU291cmNlTWFwVVJMKTtcbn1cblxuLyoqXG4gKiBUaGUgdmVyc2lvbiBvZiB0aGUgc291cmNlIG1hcHBpbmcgc3BlYyB0aGF0IHdlIGFyZSBjb25zdW1pbmcuXG4gKi9cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8vIGBfX2dlbmVyYXRlZE1hcHBpbmdzYCBhbmQgYF9fb3JpZ2luYWxNYXBwaW5nc2AgYXJlIGFycmF5cyB0aGF0IGhvbGQgdGhlXG4vLyBwYXJzZWQgbWFwcGluZyBjb29yZGluYXRlcyBmcm9tIHRoZSBzb3VyY2UgbWFwJ3MgXCJtYXBwaW5nc1wiIGF0dHJpYnV0ZS4gVGhleVxuLy8gYXJlIGxhemlseSBpbnN0YW50aWF0ZWQsIGFjY2Vzc2VkIHZpYSB0aGUgYF9nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4vLyBgX29yaWdpbmFsTWFwcGluZ3NgIGdldHRlcnMgcmVzcGVjdGl2ZWx5LCBhbmQgd2Ugb25seSBwYXJzZSB0aGUgbWFwcGluZ3Ncbi8vIGFuZCBjcmVhdGUgdGhlc2UgYXJyYXlzIG9uY2UgcXVlcmllZCBmb3IgYSBzb3VyY2UgbG9jYXRpb24uIFdlIGp1bXAgdGhyb3VnaFxuLy8gdGhlc2UgaG9vcHMgYmVjYXVzZSB0aGVyZSBjYW4gYmUgbWFueSB0aG91c2FuZHMgb2YgbWFwcGluZ3MsIGFuZCBwYXJzaW5nXG4vLyB0aGVtIGlzIGV4cGVuc2l2ZSwgc28gd2Ugb25seSB3YW50IHRvIGRvIGl0IGlmIHdlIG11c3QuXG4vL1xuLy8gRWFjaCBvYmplY3QgaW4gdGhlIGFycmF5cyBpcyBvZiB0aGUgZm9ybTpcbi8vXG4vLyAgICAge1xuLy8gICAgICAgZ2VuZXJhdGVkTGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIGdlbmVyYXRlZENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBjb2RlLFxuLy8gICAgICAgc291cmNlOiBUaGUgcGF0aCB0byB0aGUgb3JpZ2luYWwgc291cmNlIGZpbGUgdGhhdCBnZW5lcmF0ZWQgdGhpc1xuLy8gICAgICAgICAgICAgICBjaHVuayBvZiBjb2RlLFxuLy8gICAgICAgb3JpZ2luYWxMaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgIGNvcnJlc3BvbmRzIHRvIHRoaXMgY2h1bmsgb2YgZ2VuZXJhdGVkIGNvZGUsXG4vLyAgICAgICBvcmlnaW5hbENvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSB0aGF0XG4vLyAgICAgICAgICAgICAgICAgICAgICAgY29ycmVzcG9uZHMgdG8gdGhpcyBjaHVuayBvZiBnZW5lcmF0ZWQgY29kZSxcbi8vICAgICAgIG5hbWU6IFRoZSBuYW1lIG9mIHRoZSBvcmlnaW5hbCBzeW1ib2wgd2hpY2ggZ2VuZXJhdGVkIHRoaXMgY2h1bmsgb2Zcbi8vICAgICAgICAgICAgIGNvZGUuXG4vLyAgICAgfVxuLy9cbi8vIEFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCBmb3IgYGdlbmVyYXRlZExpbmVgIGFuZCBgZ2VuZXJhdGVkQ29sdW1uYCBjYW4gYmVcbi8vIGBudWxsYC5cbi8vXG4vLyBgX2dlbmVyYXRlZE1hcHBpbmdzYCBpcyBvcmRlcmVkIGJ5IHRoZSBnZW5lcmF0ZWQgcG9zaXRpb25zLlxuLy9cbi8vIGBfb3JpZ2luYWxNYXBwaW5nc2AgaXMgb3JkZXJlZCBieSB0aGUgb3JpZ2luYWwgcG9zaXRpb25zLlxuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19nZW5lcmF0ZWRNYXBwaW5ncyA9IG51bGw7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnX2dlbmVyYXRlZE1hcHBpbmdzJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3M7XG4gIH1cbn0pO1xuXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX19vcmlnaW5hbE1hcHBpbmdzID0gbnVsbDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdfb3JpZ2luYWxNYXBwaW5ncycsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX19vcmlnaW5hbE1hcHBpbmdzKSB7XG4gICAgICB0aGlzLl9wYXJzZU1hcHBpbmdzKHRoaXMuX21hcHBpbmdzLCB0aGlzLnNvdXJjZVJvb3QpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncztcbiAgfVxufSk7XG5cblNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fY2hhcklzTWFwcGluZ1NlcGFyYXRvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NoYXJJc01hcHBpbmdTZXBhcmF0b3IoYVN0ciwgaW5kZXgpIHtcbiAgICB2YXIgYyA9IGFTdHIuY2hhckF0KGluZGV4KTtcbiAgICByZXR1cm4gYyA9PT0gXCI7XCIgfHwgYyA9PT0gXCIsXCI7XG4gIH07XG5cbi8qKlxuICogUGFyc2UgdGhlIG1hcHBpbmdzIGluIGEgc3RyaW5nIGluIHRvIGEgZGF0YSBzdHJ1Y3R1cmUgd2hpY2ggd2UgY2FuIGVhc2lseVxuICogcXVlcnkgKHRoZSBvcmRlcmVkIGFycmF5cyBpbiB0aGUgYHRoaXMuX19nZW5lcmF0ZWRNYXBwaW5nc2AgYW5kXG4gKiBgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3NgIHByb3BlcnRpZXMpLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudCBfcGFyc2VNYXBwaW5nc1wiKTtcbiAgfTtcblxuU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSID0gMTtcblNvdXJjZU1hcENvbnN1bWVyLk9SSUdJTkFMX09SREVSID0gMjtcblxuU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuU291cmNlTWFwQ29uc3VtZXIuTEVBU1RfVVBQRVJfQk9VTkQgPSAyO1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIG1hcHBpbmcgYmV0d2VlbiBhbiBvcmlnaW5hbCBzb3VyY2UvbGluZS9jb2x1bW4gYW5kIGFcbiAqIGdlbmVyYXRlZCBsaW5lL2NvbHVtbiBpbiB0aGlzIHNvdXJjZSBtYXAuXG4gKlxuICogQHBhcmFtIEZ1bmN0aW9uIGFDYWxsYmFja1xuICogICAgICAgIFRoZSBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aXRoIGVhY2ggbWFwcGluZy5cbiAqIEBwYXJhbSBPYmplY3QgYUNvbnRleHRcbiAqICAgICAgICBPcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB0aGlzIG9iamVjdCB3aWxsIGJlIHRoZSB2YWx1ZSBvZiBgdGhpc2AgZXZlcnlcbiAqICAgICAgICB0aW1lIHRoYXQgYGFDYWxsYmFja2AgaXMgY2FsbGVkLlxuICogQHBhcmFtIGFPcmRlclxuICogICAgICAgIEVpdGhlciBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYCBvclxuICogICAgICAgIGBTb3VyY2VNYXBDb25zdW1lci5PUklHSU5BTF9PUkRFUmAuIFNwZWNpZmllcyB3aGV0aGVyIHlvdSB3YW50IHRvXG4gKiAgICAgICAgaXRlcmF0ZSBvdmVyIHRoZSBtYXBwaW5ncyBzb3J0ZWQgYnkgdGhlIGdlbmVyYXRlZCBmaWxlJ3MgbGluZS9jb2x1bW5cbiAqICAgICAgICBvcmRlciBvciB0aGUgb3JpZ2luYWwncyBzb3VyY2UvbGluZS9jb2x1bW4gb3JkZXIsIHJlc3BlY3RpdmVseS4gRGVmYXVsdHMgdG9cbiAqICAgICAgICBgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSYC5cbiAqL1xuU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmVhY2hNYXBwaW5nID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfZWFjaE1hcHBpbmcoYUNhbGxiYWNrLCBhQ29udGV4dCwgYU9yZGVyKSB7XG4gICAgdmFyIGNvbnRleHQgPSBhQ29udGV4dCB8fCBudWxsO1xuICAgIHZhciBvcmRlciA9IGFPcmRlciB8fCBTb3VyY2VNYXBDb25zdW1lci5HRU5FUkFURURfT1JERVI7XG5cbiAgICB2YXIgbWFwcGluZ3M7XG4gICAgc3dpdGNoIChvcmRlcikge1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuR0VORVJBVEVEX09SREVSOlxuICAgICAgbWFwcGluZ3MgPSB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU291cmNlTWFwQ29uc3VtZXIuT1JJR0lOQUxfT1JERVI6XG4gICAgICBtYXBwaW5ncyA9IHRoaXMuX29yaWdpbmFsTWFwcGluZ3M7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBvcmRlciBvZiBpdGVyYXRpb24uXCIpO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VSb290ID0gdGhpcy5zb3VyY2VSb290O1xuICAgIG1hcHBpbmdzLm1hcChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNvdXJjZSA9IG1hcHBpbmcuc291cmNlID09PSBudWxsID8gbnVsbCA6IHRoaXMuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgc291cmNlID0gdXRpbC5jb21wdXRlU291cmNlVVJMKHNvdXJjZVJvb3QsIHNvdXJjZSwgdGhpcy5fc291cmNlTWFwVVJMKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICBnZW5lcmF0ZWRMaW5lOiBtYXBwaW5nLmdlbmVyYXRlZExpbmUsXG4gICAgICAgIGdlbmVyYXRlZENvbHVtbjogbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4sXG4gICAgICAgIG9yaWdpbmFsTGluZTogbWFwcGluZy5vcmlnaW5hbExpbmUsXG4gICAgICAgIG9yaWdpbmFsQ29sdW1uOiBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uLFxuICAgICAgICBuYW1lOiBtYXBwaW5nLm5hbWUgPT09IG51bGwgPyBudWxsIDogdGhpcy5fbmFtZXMuYXQobWFwcGluZy5uYW1lKVxuICAgICAgfTtcbiAgICB9LCB0aGlzKS5mb3JFYWNoKGFDYWxsYmFjaywgY29udGV4dCk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyBhbGwgZ2VuZXJhdGVkIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIG9yaWdpbmFsIHNvdXJjZSxcbiAqIGxpbmUsIGFuZCBjb2x1bW4gcHJvdmlkZWQuIElmIG5vIGNvbHVtbiBpcyBwcm92aWRlZCwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gYSBlaXRoZXIgdGhlIGxpbmUgd2UgYXJlIHNlYXJjaGluZyBmb3Igb3IgdGhlIG5leHRcbiAqIGNsb3Nlc3QgbGluZSB0aGF0IGhhcyBhbnkgbWFwcGluZ3MuIE90aGVyd2lzZSwgcmV0dXJucyBhbGwgbWFwcGluZ3NcbiAqIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgYW5kIGVpdGhlciB0aGUgY29sdW1uIHdlIGFyZSBzZWFyY2hpbmcgZm9yXG4gKiBvciB0aGUgbmV4dCBjbG9zZXN0IGNvbHVtbiB0aGF0IGhhcyBhbnkgb2Zmc2V0cy5cbiAqXG4gKiBUaGUgb25seSBhcmd1bWVudCBpcyBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIGZpbGVuYW1lIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UuXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UuICBUaGUgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IE9wdGlvbmFsLiB0aGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLlxuICogICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpcyByZXR1cm5lZCwgZWFjaCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICBsaW5lIG51bWJlciBpcyAxLWJhc2VkLlxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5Tb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yID1cbiAgZnVuY3Rpb24gU291cmNlTWFwQ29uc3VtZXJfYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKGFBcmdzKSB7XG4gICAgdmFyIGxpbmUgPSB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKTtcblxuICAgIC8vIFdoZW4gdGhlcmUgaXMgbm8gZXhhY3QgbWF0Y2gsIEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kTWFwcGluZ1xuICAgIC8vIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IG1hcHBpbmcgbGVzcyB0aGFuIHRoZSBuZWVkbGUuIEJ5XG4gICAgLy8gc2V0dGluZyBuZWVkbGUub3JpZ2luYWxDb2x1bW4gdG8gMCwgd2UgdGh1cyBmaW5kIHRoZSBsYXN0IG1hcHBpbmcgZm9yXG4gICAgLy8gdGhlIGdpdmVuIGxpbmUsIHByb3ZpZGVkIHN1Y2ggYSBtYXBwaW5nIGV4aXN0cy5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiB1dGlsLmdldEFyZyhhQXJncywgJ3NvdXJjZScpLFxuICAgICAgb3JpZ2luYWxMaW5lOiBsaW5lLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJywgMClcbiAgICB9O1xuXG4gICAgbmVlZGxlLnNvdXJjZSA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChuZWVkbGUuc291cmNlKTtcbiAgICBpZiAobmVlZGxlLnNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICB2YXIgbWFwcGluZ3MgPSBbXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKG5lZWRsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwib3JpZ2luYWxMaW5lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcmlnaW5hbENvbHVtblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgdmFyIG1hcHBpbmcgPSB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKGFBcmdzLmNvbHVtbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBvcmlnaW5hbExpbmUgPSBtYXBwaW5nLm9yaWdpbmFsTGluZTtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIGZvdW5kLiBTaW5jZVxuICAgICAgICAvLyBtYXBwaW5ncyBhcmUgc29ydGVkLCB0aGlzIGlzIGd1YXJhbnRlZWQgdG8gZmluZCBhbGwgbWFwcGluZ3MgZm9yXG4gICAgICAgIC8vIHRoZSBsaW5lIHdlIGZvdW5kLlxuICAgICAgICB3aGlsZSAobWFwcGluZyAmJiBtYXBwaW5nLm9yaWdpbmFsTGluZSA9PT0gb3JpZ2luYWxMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsQ29sdW1uID0gbWFwcGluZy5vcmlnaW5hbENvbHVtbjtcblxuICAgICAgICAvLyBJdGVyYXRlIHVudGlsIGVpdGhlciB3ZSBydW4gb3V0IG9mIG1hcHBpbmdzLCBvciB3ZSBydW4gaW50b1xuICAgICAgICAvLyBhIG1hcHBpbmcgZm9yIGEgZGlmZmVyZW50IGxpbmUgdGhhbiB0aGUgb25lIHdlIHdlcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgLy8gU2luY2UgbWFwcGluZ3MgYXJlIHNvcnRlZCwgdGhpcyBpcyBndWFyYW50ZWVkIHRvIGZpbmQgYWxsIG1hcHBpbmdzIGZvclxuICAgICAgICAvLyB0aGUgbGluZSB3ZSBhcmUgc2VhcmNoaW5nIGZvci5cbiAgICAgICAgd2hpbGUgKG1hcHBpbmcgJiZcbiAgICAgICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID09PSBsaW5lICYmXG4gICAgICAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID09IG9yaWdpbmFsQ29sdW1uKSB7XG4gICAgICAgICAgbWFwcGluZ3MucHVzaCh7XG4gICAgICAgICAgICBsaW5lOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkTGluZScsIG51bGwpLFxuICAgICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgICBsYXN0Q29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbGFzdEdlbmVyYXRlZENvbHVtbicsIG51bGwpXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1srK2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXBwaW5ncztcbiAgfTtcblxuZXhwb3J0cy5Tb3VyY2VNYXBDb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIEEgQmFzaWNTb3VyY2VNYXBDb25zdW1lciBpbnN0YW5jZSByZXByZXNlbnRzIGEgcGFyc2VkIHNvdXJjZSBtYXAgd2hpY2ggd2UgY2FuXG4gKiBxdWVyeSBmb3IgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG9yaWdpbmFsIGZpbGUgcG9zaXRpb25zIGJ5IGdpdmluZyBpdCBhIGZpbGVcbiAqIHBvc2l0aW9uIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLlxuICpcbiAqIFRoZSBmaXJzdCBwYXJhbWV0ZXIgaXMgdGhlIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3JcbiAqIGFscmVhZHkgcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYywgc291cmNlIG1hcHMgaGF2ZSB0aGVcbiAqIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqICAgLSB2ZXJzaW9uOiBXaGljaCB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwIHNwZWMgdGhpcyBtYXAgaXMgZm9sbG93aW5nLlxuICogICAtIHNvdXJjZXM6IEFuIGFycmF5IG9mIFVSTHMgdG8gdGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlcy5cbiAqICAgLSBuYW1lczogQW4gYXJyYXkgb2YgaWRlbnRpZmllcnMgd2hpY2ggY2FuIGJlIHJlZmVycmVuY2VkIGJ5IGluZGl2aWR1YWwgbWFwcGluZ3MuXG4gKiAgIC0gc291cmNlUm9vdDogT3B0aW9uYWwuIFRoZSBVUkwgcm9vdCBmcm9tIHdoaWNoIGFsbCBzb3VyY2VzIGFyZSByZWxhdGl2ZS5cbiAqICAgLSBzb3VyY2VzQ29udGVudDogT3B0aW9uYWwuIEFuIGFycmF5IG9mIGNvbnRlbnRzIG9mIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMuXG4gKiAgIC0gbWFwcGluZ3M6IEEgc3RyaW5nIG9mIGJhc2U2NCBWTFFzIHdoaWNoIGNvbnRhaW4gdGhlIGFjdHVhbCBtYXBwaW5ncy5cbiAqICAgLSBmaWxlOiBPcHRpb25hbC4gVGhlIGdlbmVyYXRlZCBmaWxlIHRoaXMgc291cmNlIG1hcCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gKlxuICogSGVyZSBpcyBhbiBleGFtcGxlIHNvdXJjZSBtYXAsIHRha2VuIGZyb20gdGhlIHNvdXJjZSBtYXAgc3BlY1swXTpcbiAqXG4gKiAgICAge1xuICogICAgICAgdmVyc2lvbiA6IDMsXG4gKiAgICAgICBmaWxlOiBcIm91dC5qc1wiLFxuICogICAgICAgc291cmNlUm9vdCA6IFwiXCIsXG4gKiAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICBuYW1lczogW1wic3JjXCIsIFwibWFwc1wiLCBcImFyZVwiLCBcImZ1blwiXSxcbiAqICAgICAgIG1hcHBpbmdzOiBcIkFBLEFCOztBQkNERTtcIlxuICogICAgIH1cbiAqXG4gKiBUaGUgc2Vjb25kIHBhcmFtZXRlciwgaWYgZ2l2ZW4sIGlzIGEgc3RyaW5nIHdob3NlIHZhbHVlIGlzIHRoZSBVUkxcbiAqIGF0IHdoaWNoIHRoZSBzb3VyY2UgbWFwIHdhcyBmb3VuZC4gIFRoaXMgVVJMIGlzIHVzZWQgdG8gY29tcHV0ZSB0aGVcbiAqIHNvdXJjZXMgYXJyYXkuXG4gKlxuICogWzBdOiBodHRwczovL2RvY3MuZ29vZ2xlLmNvbS9kb2N1bWVudC9kLzFVMVJHQWVoUXdSeXBVVG92RjFLUmxwaU9GemUwYi1fMmdjNmZBSDBLWTBrL2VkaXQ/cGxpPTEjXG4gKi9cbmZ1bmN0aW9uIEJhc2ljU291cmNlTWFwQ29uc3VtZXIoYVNvdXJjZU1hcCwgYVNvdXJjZU1hcFVSTCkge1xuICB2YXIgc291cmNlTWFwID0gYVNvdXJjZU1hcDtcbiAgaWYgKHR5cGVvZiBhU291cmNlTWFwID09PSAnc3RyaW5nJykge1xuICAgIHNvdXJjZU1hcCA9IHV0aWwucGFyc2VTb3VyY2VNYXBJbnB1dChhU291cmNlTWFwKTtcbiAgfVxuXG4gIHZhciB2ZXJzaW9uID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAndmVyc2lvbicpO1xuICB2YXIgc291cmNlcyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXMnKTtcbiAgLy8gU2FzcyAzLjMgbGVhdmVzIG91dCB0aGUgJ25hbWVzJyBhcnJheSwgc28gd2UgZGV2aWF0ZSBmcm9tIHRoZSBzcGVjICh3aGljaFxuICAvLyByZXF1aXJlcyB0aGUgYXJyYXkpIHRvIHBsYXkgbmljZSBoZXJlLlxuICB2YXIgbmFtZXMgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICduYW1lcycsIFtdKTtcbiAgdmFyIHNvdXJjZVJvb3QgPSB1dGlsLmdldEFyZyhzb3VyY2VNYXAsICdzb3VyY2VSb290JywgbnVsbCk7XG4gIHZhciBzb3VyY2VzQ29udGVudCA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3NvdXJjZXNDb250ZW50JywgbnVsbCk7XG4gIHZhciBtYXBwaW5ncyA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ21hcHBpbmdzJyk7XG4gIHZhciBmaWxlID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnZmlsZScsIG51bGwpO1xuXG4gIC8vIE9uY2UgYWdhaW4sIFNhc3MgZGV2aWF0ZXMgZnJvbSB0aGUgc3BlYyBhbmQgc3VwcGxpZXMgdGhlIHZlcnNpb24gYXMgYVxuICAvLyBzdHJpbmcgcmF0aGVyIHRoYW4gYSBudW1iZXIsIHNvIHdlIHVzZSBsb29zZSBlcXVhbGl0eSBjaGVja2luZyBoZXJlLlxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICBpZiAoc291cmNlUm9vdCkge1xuICAgIHNvdXJjZVJvb3QgPSB1dGlsLm5vcm1hbGl6ZShzb3VyY2VSb290KTtcbiAgfVxuXG4gIHNvdXJjZXMgPSBzb3VyY2VzXG4gICAgLm1hcChTdHJpbmcpXG4gICAgLy8gU29tZSBzb3VyY2UgbWFwcyBwcm9kdWNlIHJlbGF0aXZlIHNvdXJjZSBwYXRocyBsaWtlIFwiLi9mb28uanNcIiBpbnN0ZWFkIG9mXG4gICAgLy8gXCJmb28uanNcIi4gIE5vcm1hbGl6ZSB0aGVzZSBmaXJzdCBzbyB0aGF0IGZ1dHVyZSBjb21wYXJpc29ucyB3aWxsIHN1Y2NlZWQuXG4gICAgLy8gU2VlIGJ1Z3ppbC5sYS8xMDkwNzY4LlxuICAgIC5tYXAodXRpbC5ub3JtYWxpemUpXG4gICAgLy8gQWx3YXlzIGVuc3VyZSB0aGF0IGFic29sdXRlIHNvdXJjZXMgYXJlIGludGVybmFsbHkgc3RvcmVkIHJlbGF0aXZlIHRvXG4gICAgLy8gdGhlIHNvdXJjZSByb290LCBpZiB0aGUgc291cmNlIHJvb3QgaXMgYWJzb2x1dGUuIE5vdCBkb2luZyB0aGlzIHdvdWxkXG4gICAgLy8gYmUgcGFydGljdWxhcmx5IHByb2JsZW1hdGljIHdoZW4gdGhlIHNvdXJjZSByb290IGlzIGEgcHJlZml4IG9mIHRoZVxuICAgIC8vIHNvdXJjZSAodmFsaWQsIGJ1dCB3aHk/PykuIFNlZSBnaXRodWIgaXNzdWUgIzE5OSBhbmQgYnVnemlsLmxhLzExODg5ODIuXG4gICAgLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gc291cmNlUm9vdCAmJiB1dGlsLmlzQWJzb2x1dGUoc291cmNlUm9vdCkgJiYgdXRpbC5pc0Fic29sdXRlKHNvdXJjZSlcbiAgICAgICAgPyB1dGlsLnJlbGF0aXZlKHNvdXJjZVJvb3QsIHNvdXJjZSlcbiAgICAgICAgOiBzb3VyY2U7XG4gICAgfSk7XG5cbiAgLy8gUGFzcyBgdHJ1ZWAgYmVsb3cgdG8gYWxsb3cgZHVwbGljYXRlIG5hbWVzIGFuZCBzb3VyY2VzLiBXaGlsZSBzb3VyY2UgbWFwc1xuICAvLyBhcmUgaW50ZW5kZWQgdG8gYmUgY29tcHJlc3NlZCBhbmQgZGVkdXBsaWNhdGVkLCB0aGUgVHlwZVNjcmlwdCBjb21waWxlclxuICAvLyBzb21ldGltZXMgZ2VuZXJhdGVzIHNvdXJjZSBtYXBzIHdpdGggZHVwbGljYXRlcyBpbiB0aGVtLiBTZWUgR2l0aHViIGlzc3VlXG4gIC8vICM3MiBhbmQgYnVnemlsLmxhLzg4OTQ5Mi5cbiAgdGhpcy5fbmFtZXMgPSBBcnJheVNldC5mcm9tQXJyYXkobmFtZXMubWFwKFN0cmluZyksIHRydWUpO1xuICB0aGlzLl9zb3VyY2VzID0gQXJyYXlTZXQuZnJvbUFycmF5KHNvdXJjZXMsIHRydWUpO1xuXG4gIHRoaXMuX2Fic29sdXRlU291cmNlcyA9IHRoaXMuX3NvdXJjZXMudG9BcnJheSgpLm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc291cmNlUm9vdCwgcywgYVNvdXJjZU1hcFVSTCk7XG4gIH0pO1xuXG4gIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gIHRoaXMuc291cmNlc0NvbnRlbnQgPSBzb3VyY2VzQ29udGVudDtcbiAgdGhpcy5fbWFwcGluZ3MgPSBtYXBwaW5ncztcbiAgdGhpcy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgdGhpcy5maWxlID0gZmlsZTtcbn1cblxuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdW1lciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gZmluZCB0aGUgaW5kZXggb2YgYSBzb3VyY2UuICBSZXR1cm5zIC0xIGlmIG5vdFxuICogZm91bmQuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLl9maW5kU291cmNlSW5kZXggPSBmdW5jdGlvbihhU291cmNlKSB7XG4gIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gIGlmICh0aGlzLnNvdXJjZVJvb3QgIT0gbnVsbCkge1xuICAgIHJlbGF0aXZlU291cmNlID0gdXRpbC5yZWxhdGl2ZSh0aGlzLnNvdXJjZVJvb3QsIHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb3VyY2VzLmhhcyhyZWxhdGl2ZVNvdXJjZSkpIHtcbiAgICByZXR1cm4gdGhpcy5fc291cmNlcy5pbmRleE9mKHJlbGF0aXZlU291cmNlKTtcbiAgfVxuXG4gIC8vIE1heWJlIGFTb3VyY2UgaXMgYW4gYWJzb2x1dGUgVVJMIGFzIHJldHVybmVkIGJ5IHxzb3VyY2VzfC4gIEluXG4gIC8vIHRoaXMgY2FzZSB3ZSBjYW4ndCBzaW1wbHkgdW5kbyB0aGUgdHJhbnNmb3JtLlxuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2Fic29sdXRlU291cmNlcy5sZW5ndGg7ICsraSkge1xuICAgIGlmICh0aGlzLl9hYnNvbHV0ZVNvdXJjZXNbaV0gPT0gYVNvdXJjZSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBCYXNpY1NvdXJjZU1hcENvbnN1bWVyIGZyb20gYSBTb3VyY2VNYXBHZW5lcmF0b3IuXG4gKlxuICogQHBhcmFtIFNvdXJjZU1hcEdlbmVyYXRvciBhU291cmNlTWFwXG4gKiAgICAgICAgVGhlIHNvdXJjZSBtYXAgdGhhdCB3aWxsIGJlIGNvbnN1bWVkLlxuICogQHBhcmFtIFN0cmluZyBhU291cmNlTWFwVVJMXG4gKiAgICAgICAgVGhlIFVSTCBhdCB3aGljaCB0aGUgc291cmNlIG1hcCBjYW4gYmUgZm91bmQgKG9wdGlvbmFsKVxuICogQHJldHVybnMgQmFzaWNTb3VyY2VNYXBDb25zdW1lclxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLmZyb21Tb3VyY2VNYXAgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9mcm9tU291cmNlTWFwKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgICB2YXIgc21jID0gT2JqZWN0LmNyZWF0ZShCYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZSk7XG5cbiAgICB2YXIgbmFtZXMgPSBzbWMuX25hbWVzID0gQXJyYXlTZXQuZnJvbUFycmF5KGFTb3VyY2VNYXAuX25hbWVzLnRvQXJyYXkoKSwgdHJ1ZSk7XG4gICAgdmFyIHNvdXJjZXMgPSBzbWMuX3NvdXJjZXMgPSBBcnJheVNldC5mcm9tQXJyYXkoYVNvdXJjZU1hcC5fc291cmNlcy50b0FycmF5KCksIHRydWUpO1xuICAgIHNtYy5zb3VyY2VSb290ID0gYVNvdXJjZU1hcC5fc291cmNlUm9vdDtcbiAgICBzbWMuc291cmNlc0NvbnRlbnQgPSBhU291cmNlTWFwLl9nZW5lcmF0ZVNvdXJjZXNDb250ZW50KHNtYy5fc291cmNlcy50b0FycmF5KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbWMuc291cmNlUm9vdCk7XG4gICAgc21jLmZpbGUgPSBhU291cmNlTWFwLl9maWxlO1xuICAgIHNtYy5fc291cmNlTWFwVVJMID0gYVNvdXJjZU1hcFVSTDtcbiAgICBzbWMuX2Fic29sdXRlU291cmNlcyA9IHNtYy5fc291cmNlcy50b0FycmF5KCkubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgICByZXR1cm4gdXRpbC5jb21wdXRlU291cmNlVVJMKHNtYy5zb3VyY2VSb290LCBzLCBhU291cmNlTWFwVVJMKTtcbiAgICB9KTtcblxuICAgIC8vIEJlY2F1c2Ugd2UgYXJlIG1vZGlmeWluZyB0aGUgZW50cmllcyAoYnkgY29udmVydGluZyBzdHJpbmcgc291cmNlcyBhbmRcbiAgICAvLyBuYW1lcyB0byBpbmRpY2VzIGludG8gdGhlIHNvdXJjZXMgYW5kIG5hbWVzIEFycmF5U2V0cyksIHdlIGhhdmUgdG8gbWFrZVxuICAgIC8vIGEgY29weSBvZiB0aGUgZW50cnkgb3IgZWxzZSBiYWQgdGhpbmdzIGhhcHBlbi4gU2hhcmVkIG11dGFibGUgc3RhdGVcbiAgICAvLyBzdHJpa2VzIGFnYWluISBTZWUgZ2l0aHViIGlzc3VlICMxOTEuXG5cbiAgICB2YXIgZ2VuZXJhdGVkTWFwcGluZ3MgPSBhU291cmNlTWFwLl9tYXBwaW5ncy50b0FycmF5KCkuc2xpY2UoKTtcbiAgICB2YXIgZGVzdEdlbmVyYXRlZE1hcHBpbmdzID0gc21jLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBbXTtcbiAgICB2YXIgZGVzdE9yaWdpbmFsTWFwcGluZ3MgPSBzbWMuX19vcmlnaW5hbE1hcHBpbmdzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzcmNNYXBwaW5nID0gZ2VuZXJhdGVkTWFwcGluZ3NbaV07XG4gICAgICB2YXIgZGVzdE1hcHBpbmcgPSBuZXcgTWFwcGluZztcbiAgICAgIGRlc3RNYXBwaW5nLmdlbmVyYXRlZExpbmUgPSBzcmNNYXBwaW5nLmdlbmVyYXRlZExpbmU7XG4gICAgICBkZXN0TWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gPSBzcmNNYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgaWYgKHNyY01hcHBpbmcuc291cmNlKSB7XG4gICAgICAgIGRlc3RNYXBwaW5nLnNvdXJjZSA9IHNvdXJjZXMuaW5kZXhPZihzcmNNYXBwaW5nLnNvdXJjZSk7XG4gICAgICAgIGRlc3RNYXBwaW5nLm9yaWdpbmFsTGluZSA9IHNyY01hcHBpbmcub3JpZ2luYWxMaW5lO1xuICAgICAgICBkZXN0TWFwcGluZy5vcmlnaW5hbENvbHVtbiA9IHNyY01hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgaWYgKHNyY01hcHBpbmcubmFtZSkge1xuICAgICAgICAgIGRlc3RNYXBwaW5nLm5hbWUgPSBuYW1lcy5pbmRleE9mKHNyY01hcHBpbmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZXN0T3JpZ2luYWxNYXBwaW5ncy5wdXNoKGRlc3RNYXBwaW5nKTtcbiAgICAgIH1cblxuICAgICAgZGVzdEdlbmVyYXRlZE1hcHBpbmdzLnB1c2goZGVzdE1hcHBpbmcpO1xuICAgIH1cblxuICAgIHF1aWNrU29ydChzbWMuX19vcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcblxuICAgIHJldHVybiBzbWM7XG4gIH07XG5cbi8qKlxuICogVGhlIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXBwaW5nIHNwZWMgdGhhdCB3ZSBhcmUgY29uc3VtaW5nLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLCAnc291cmNlcycsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Fic29sdXRlU291cmNlcy5zbGljZSgpO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlIHRoZSBKSVQgd2l0aCBhIG5pY2Ugc2hhcGUgLyBoaWRkZW4gY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIE1hcHBpbmcoKSB7XG4gIHRoaXMuZ2VuZXJhdGVkTGluZSA9IDA7XG4gIHRoaXMuZ2VuZXJhdGVkQ29sdW1uID0gMDtcbiAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB0aGlzLm9yaWdpbmFsTGluZSA9IG51bGw7XG4gIHRoaXMub3JpZ2luYWxDb2x1bW4gPSBudWxsO1xuICB0aGlzLm5hbWUgPSBudWxsO1xufVxuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuQmFzaWNTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUuX3BhcnNlTWFwcGluZ3MgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdmFyIGdlbmVyYXRlZExpbmUgPSAxO1xuICAgIHZhciBwcmV2aW91c0dlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gMDtcbiAgICB2YXIgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IDA7XG4gICAgdmFyIHByZXZpb3VzU291cmNlID0gMDtcbiAgICB2YXIgcHJldmlvdXNOYW1lID0gMDtcbiAgICB2YXIgbGVuZ3RoID0gYVN0ci5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgY2FjaGVkU2VnbWVudHMgPSB7fTtcbiAgICB2YXIgdGVtcCA9IHt9O1xuICAgIHZhciBvcmlnaW5hbE1hcHBpbmdzID0gW107XG4gICAgdmFyIGdlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdmFyIG1hcHBpbmcsIHN0ciwgc2VnbWVudCwgZW5kLCB2YWx1ZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKGFTdHIuY2hhckF0KGluZGV4KSA9PT0gJzsnKSB7XG4gICAgICAgIGdlbmVyYXRlZExpbmUrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSAwO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoYVN0ci5jaGFyQXQoaW5kZXgpID09PSAnLCcpIHtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBtYXBwaW5nID0gbmV3IE1hcHBpbmcoKTtcbiAgICAgICAgbWFwcGluZy5nZW5lcmF0ZWRMaW5lID0gZ2VuZXJhdGVkTGluZTtcblxuICAgICAgICAvLyBCZWNhdXNlIGVhY2ggb2Zmc2V0IGlzIGVuY29kZWQgcmVsYXRpdmUgdG8gdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgLy8gbWFueSBzZWdtZW50cyBvZnRlbiBoYXZlIHRoZSBzYW1lIGVuY29kaW5nLiBXZSBjYW4gZXhwbG9pdCB0aGlzXG4gICAgICAgIC8vIGZhY3QgYnkgY2FjaGluZyB0aGUgcGFyc2VkIHZhcmlhYmxlIGxlbmd0aCBmaWVsZHMgb2YgZWFjaCBzZWdtZW50LFxuICAgICAgICAvLyBhbGxvd2luZyB1cyB0byBhdm9pZCBhIHNlY29uZCBwYXJzZSBpZiB3ZSBlbmNvdW50ZXIgdGhlIHNhbWVcbiAgICAgICAgLy8gc2VnbWVudCBhZ2Fpbi5cbiAgICAgICAgZm9yIChlbmQgPSBpbmRleDsgZW5kIDwgbGVuZ3RoOyBlbmQrKykge1xuICAgICAgICAgIGlmICh0aGlzLl9jaGFySXNNYXBwaW5nU2VwYXJhdG9yKGFTdHIsIGVuZCkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdHIgPSBhU3RyLnNsaWNlKGluZGV4LCBlbmQpO1xuXG4gICAgICAgIHNlZ21lbnQgPSBjYWNoZWRTZWdtZW50c1tzdHJdO1xuICAgICAgICBpZiAoc2VnbWVudCkge1xuICAgICAgICAgIGluZGV4ICs9IHN0ci5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VnbWVudCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChpbmRleCA8IGVuZCkge1xuICAgICAgICAgICAgYmFzZTY0VkxRLmRlY29kZShhU3RyLCBpbmRleCwgdGVtcCk7XG4gICAgICAgICAgICB2YWx1ZSA9IHRlbXAudmFsdWU7XG4gICAgICAgICAgICBpbmRleCA9IHRlbXAucmVzdDtcbiAgICAgICAgICAgIHNlZ21lbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlLCBidXQgbm8gbGluZSBhbmQgY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGEgc291cmNlIGFuZCBsaW5lLCBidXQgbm8gY29sdW1uJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY2FjaGVkU2VnbWVudHNbc3RyXSA9IHNlZ21lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZW5lcmF0ZWQgY29sdW1uLlxuICAgICAgICBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiA9IHByZXZpb3VzR2VuZXJhdGVkQ29sdW1uICsgc2VnbWVudFswXTtcbiAgICAgICAgcHJldmlvdXNHZW5lcmF0ZWRDb2x1bW4gPSBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbjtcblxuICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgLy8gT3JpZ2luYWwgc291cmNlLlxuICAgICAgICAgIG1hcHBpbmcuc291cmNlID0gcHJldmlvdXNTb3VyY2UgKyBzZWdtZW50WzFdO1xuICAgICAgICAgIHByZXZpb3VzU291cmNlICs9IHNlZ21lbnRbMV07XG5cbiAgICAgICAgICAvLyBPcmlnaW5hbCBsaW5lLlxuICAgICAgICAgIG1hcHBpbmcub3JpZ2luYWxMaW5lID0gcHJldmlvdXNPcmlnaW5hbExpbmUgKyBzZWdtZW50WzJdO1xuICAgICAgICAgIHByZXZpb3VzT3JpZ2luYWxMaW5lID0gbWFwcGluZy5vcmlnaW5hbExpbmU7XG4gICAgICAgICAgLy8gTGluZXMgYXJlIHN0b3JlZCAwLWJhc2VkXG4gICAgICAgICAgbWFwcGluZy5vcmlnaW5hbExpbmUgKz0gMTtcblxuICAgICAgICAgIC8vIE9yaWdpbmFsIGNvbHVtbi5cbiAgICAgICAgICBtYXBwaW5nLm9yaWdpbmFsQ29sdW1uID0gcHJldmlvdXNPcmlnaW5hbENvbHVtbiArIHNlZ21lbnRbM107XG4gICAgICAgICAgcHJldmlvdXNPcmlnaW5hbENvbHVtbiA9IG1hcHBpbmcub3JpZ2luYWxDb2x1bW47XG5cbiAgICAgICAgICBpZiAoc2VnbWVudC5sZW5ndGggPiA0KSB7XG4gICAgICAgICAgICAvLyBPcmlnaW5hbCBuYW1lLlxuICAgICAgICAgICAgbWFwcGluZy5uYW1lID0gcHJldmlvdXNOYW1lICsgc2VnbWVudFs0XTtcbiAgICAgICAgICAgIHByZXZpb3VzTmFtZSArPSBzZWdtZW50WzRdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlbmVyYXRlZE1hcHBpbmdzLnB1c2gobWFwcGluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbWFwcGluZy5vcmlnaW5hbExpbmUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb3JpZ2luYWxNYXBwaW5ncy5wdXNoKG1hcHBpbmcpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcXVpY2tTb3J0KGdlbmVyYXRlZE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkKTtcbiAgICB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MgPSBnZW5lcmF0ZWRNYXBwaW5ncztcblxuICAgIHF1aWNrU29ydChvcmlnaW5hbE1hcHBpbmdzLCB1dGlsLmNvbXBhcmVCeU9yaWdpbmFsUG9zaXRpb25zKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncyA9IG9yaWdpbmFsTWFwcGluZ3M7XG4gIH07XG5cbi8qKlxuICogRmluZCB0aGUgbWFwcGluZyB0aGF0IGJlc3QgbWF0Y2hlcyB0aGUgaHlwb3RoZXRpY2FsIFwibmVlZGxlXCIgbWFwcGluZyB0aGF0XG4gKiB3ZSBhcmUgc2VhcmNoaW5nIGZvciBpbiB0aGUgZ2l2ZW4gXCJoYXlzdGFja1wiIG9mIG1hcHBpbmdzLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fZmluZE1hcHBpbmcgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9maW5kTWFwcGluZyhhTmVlZGxlLCBhTWFwcGluZ3MsIGFMaW5lTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvbHVtbk5hbWUsIGFDb21wYXJhdG9yLCBhQmlhcykge1xuICAgIC8vIFRvIHJldHVybiB0aGUgcG9zaXRpb24gd2UgYXJlIHNlYXJjaGluZyBmb3IsIHdlIG11c3QgZmlyc3QgZmluZCB0aGVcbiAgICAvLyBtYXBwaW5nIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24gYW5kIHRoZW4gcmV0dXJuIHRoZSBvcHBvc2l0ZSBwb3NpdGlvbiBpdFxuICAgIC8vIHBvaW50cyB0by4gQmVjYXVzZSB0aGUgbWFwcGluZ3MgYXJlIHNvcnRlZCwgd2UgY2FuIHVzZSBiaW5hcnkgc2VhcmNoIHRvXG4gICAgLy8gZmluZCB0aGUgYmVzdCBtYXBwaW5nLlxuXG4gICAgaWYgKGFOZWVkbGVbYUxpbmVOYW1lXSA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdMaW5lIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDEsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthTGluZU5hbWVdKTtcbiAgICB9XG4gICAgaWYgKGFOZWVkbGVbYUNvbHVtbk5hbWVdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ29sdW1uIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAsIGdvdCAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICsgYU5lZWRsZVthQ29sdW1uTmFtZV0pO1xuICAgIH1cblxuICAgIHJldHVybiBiaW5hcnlTZWFyY2guc2VhcmNoKGFOZWVkbGUsIGFNYXBwaW5ncywgYUNvbXBhcmF0b3IsIGFCaWFzKTtcbiAgfTtcblxuLyoqXG4gKiBDb21wdXRlIHRoZSBsYXN0IGNvbHVtbiBmb3IgZWFjaCBnZW5lcmF0ZWQgbWFwcGluZy4gVGhlIGxhc3QgY29sdW1uIGlzXG4gKiBpbmNsdXNpdmUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmNvbXB1dGVDb2x1bW5TcGFucyA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2NvbXB1dGVDb2x1bW5TcGFucygpIHtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgLy8gTWFwcGluZ3MgZG8gbm90IGNvbnRhaW4gYSBmaWVsZCBmb3IgdGhlIGxhc3QgZ2VuZXJhdGVkIGNvbHVtbnQuIFdlXG4gICAgICAvLyBjYW4gY29tZSB1cCB3aXRoIGFuIG9wdGltaXN0aWMgZXN0aW1hdGUsIGhvd2V2ZXIsIGJ5IGFzc3VtaW5nIHRoYXRcbiAgICAgIC8vIG1hcHBpbmdzIGFyZSBjb250aWd1b3VzIChpLmUuIGdpdmVuIHR3byBjb25zZWN1dGl2ZSBtYXBwaW5ncywgdGhlXG4gICAgICAvLyBmaXJzdCBtYXBwaW5nIGVuZHMgd2hlcmUgdGhlIHNlY29uZCBvbmUgc3RhcnRzKS5cbiAgICAgIGlmIChpbmRleCArIDEgPCB0aGlzLl9nZW5lcmF0ZWRNYXBwaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRNYXBwaW5nID0gdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3NbaW5kZXggKyAxXTtcblxuICAgICAgICBpZiAobWFwcGluZy5nZW5lcmF0ZWRMaW5lID09PSBuZXh0TWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gbmV4dE1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC0gMTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgbGFzdCBtYXBwaW5nIGZvciBlYWNoIGxpbmUgc3BhbnMgdGhlIGVudGlyZSBsaW5lLlxuICAgICAgbWFwcGluZy5sYXN0R2VuZXJhdGVkQ29sdW1uID0gSW5maW5pdHk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9yaWdpbmFsIHNvdXJjZSwgbGluZSwgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbiBmb3IgdGhlIGdlbmVyYXRlZFxuICogc291cmNlJ3MgbGluZSBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gbGluZTogVGhlIGxpbmUgbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGxpbmUgbnVtYmVyXG4gKiAgICAgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBnZW5lcmF0ZWQgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIHNvdXJjZTogVGhlIG9yaWdpbmFsIHNvdXJjZSBmaWxlLCBvciBudWxsLlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgbGluZSBudW1iZXIgaXMgMS1iYXNlZC5cbiAqICAgLSBjb2x1bW46IFRoZSBjb2x1bW4gbnVtYmVyIGluIHRoZSBvcmlnaW5hbCBzb3VyY2UsIG9yIG51bGwuICBUaGVcbiAqICAgICBjb2x1bW4gbnVtYmVyIGlzIDAtYmFzZWQuXG4gKiAgIC0gbmFtZTogVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIsIG9yIG51bGwuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9vcmlnaW5hbFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIG5lZWRsZSA9IHtcbiAgICAgIGdlbmVyYXRlZExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgZ2VuZXJhdGVkQ29sdW1uOiB1dGlsLmdldEFyZyhhQXJncywgJ2NvbHVtbicpXG4gICAgfTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRNYXBwaW5nKFxuICAgICAgbmVlZGxlLFxuICAgICAgdGhpcy5fZ2VuZXJhdGVkTWFwcGluZ3MsXG4gICAgICBcImdlbmVyYXRlZExpbmVcIixcbiAgICAgIFwiZ2VuZXJhdGVkQ29sdW1uXCIsXG4gICAgICB1dGlsLmNvbXBhcmVCeUdlbmVyYXRlZFBvc2l0aW9uc0RlZmxhdGVkLFxuICAgICAgdXRpbC5nZXRBcmcoYUFyZ3MsICdiaWFzJywgU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQpXG4gICAgKTtcblxuICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICB2YXIgbWFwcGluZyA9IHRoaXMuX2dlbmVyYXRlZE1hcHBpbmdzW2luZGV4XTtcblxuICAgICAgaWYgKG1hcHBpbmcuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmUpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdzb3VyY2UnLCBudWxsKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuYXQoc291cmNlKTtcbiAgICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwodGhpcy5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5hbWUgPSB1dGlsLmdldEFyZyhtYXBwaW5nLCAnbmFtZScsIG51bGwpO1xuICAgICAgICBpZiAobmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIG5hbWUgPSB0aGlzLl9uYW1lcy5hdChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbExpbmUnLCBudWxsKSxcbiAgICAgICAgICBjb2x1bW46IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdvcmlnaW5hbENvbHVtbicsIG51bGwpLFxuICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlOiBudWxsLFxuICAgICAgbGluZTogbnVsbCxcbiAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgIG5hbWU6IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHdlIGhhdmUgdGhlIHNvdXJjZSBjb250ZW50IGZvciBldmVyeSBzb3VyY2UgaW4gdGhlIHNvdXJjZVxuICogbWFwLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gQmFzaWNTb3VyY2VNYXBDb25zdW1lcl9oYXNDb250ZW50c09mQWxsU291cmNlcygpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnQubGVuZ3RoID49IHRoaXMuX3NvdXJjZXMuc2l6ZSgpICYmXG4gICAgICAhdGhpcy5zb3VyY2VzQ29udGVudC5zb21lKGZ1bmN0aW9uIChzYykgeyByZXR1cm4gc2MgPT0gbnVsbDsgfSk7XG4gIH07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3JpZ2luYWwgc291cmNlIGNvbnRlbnQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIHRoZSB1cmwgb2YgdGhlXG4gKiBvcmlnaW5hbCBzb3VyY2UgZmlsZS4gUmV0dXJucyBudWxsIGlmIG5vIG9yaWdpbmFsIHNvdXJjZSBjb250ZW50IGlzXG4gKiBhdmFpbGFibGUuXG4gKi9cbkJhc2ljU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IgPVxuICBmdW5jdGlvbiBTb3VyY2VNYXBDb25zdW1lcl9zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIG51bGxPbk1pc3NpbmcpIHtcbiAgICBpZiAoIXRoaXMuc291cmNlc0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbmRleCA9IHRoaXMuX2ZpbmRTb3VyY2VJbmRleChhU291cmNlKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlc0NvbnRlbnRbaW5kZXhdO1xuICAgIH1cblxuICAgIHZhciByZWxhdGl2ZVNvdXJjZSA9IGFTb3VyY2U7XG4gICAgaWYgKHRoaXMuc291cmNlUm9vdCAhPSBudWxsKSB7XG4gICAgICByZWxhdGl2ZVNvdXJjZSA9IHV0aWwucmVsYXRpdmUodGhpcy5zb3VyY2VSb290LCByZWxhdGl2ZVNvdXJjZSk7XG4gICAgfVxuXG4gICAgdmFyIHVybDtcbiAgICBpZiAodGhpcy5zb3VyY2VSb290ICE9IG51bGxcbiAgICAgICAgJiYgKHVybCA9IHV0aWwudXJsUGFyc2UodGhpcy5zb3VyY2VSb290KSkpIHtcbiAgICAgIC8vIFhYWDogZmlsZTovLyBVUklzIGFuZCBhYnNvbHV0ZSBwYXRocyBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgZm9yXG4gICAgICAvLyBtYW55IHVzZXJzLiBXZSBjYW4gaGVscCB0aGVtIG91dCB3aGVuIHRoZXkgZXhwZWN0IGZpbGU6Ly8gVVJJcyB0b1xuICAgICAgLy8gYmVoYXZlIGxpa2UgaXQgd291bGQgaWYgdGhleSB3ZXJlIHJ1bm5pbmcgYSBsb2NhbCBIVFRQIHNlcnZlci4gU2VlXG4gICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD04ODU1OTcuXG4gICAgICB2YXIgZmlsZVVyaUFic1BhdGggPSByZWxhdGl2ZVNvdXJjZS5yZXBsYWNlKC9eZmlsZTpcXC9cXC8vLCBcIlwiKTtcbiAgICAgIGlmICh1cmwuc2NoZW1lID09IFwiZmlsZVwiXG4gICAgICAgICAgJiYgdGhpcy5fc291cmNlcy5oYXMoZmlsZVVyaUFic1BhdGgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihmaWxlVXJpQWJzUGF0aCldXG4gICAgICB9XG5cbiAgICAgIGlmICgoIXVybC5wYXRoIHx8IHVybC5wYXRoID09IFwiL1wiKVxuICAgICAgICAgICYmIHRoaXMuX3NvdXJjZXMuaGFzKFwiL1wiICsgcmVsYXRpdmVTb3VyY2UpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZXNDb250ZW50W3RoaXMuX3NvdXJjZXMuaW5kZXhPZihcIi9cIiArIHJlbGF0aXZlU291cmNlKV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IGZyb21cbiAgICAvLyBJbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLnNvdXJjZUNvbnRlbnRGb3IuIEluIHRoYXQgY2FzZSwgd2VcbiAgICAvLyBkb24ndCB3YW50IHRvIHRocm93IGlmIHdlIGNhbid0IGZpbmQgdGhlIHNvdXJjZSAtIHdlIGp1c3Qgd2FudCB0b1xuICAgIC8vIHJldHVybiBudWxsLCBzbyB3ZSBwcm92aWRlIGEgZmxhZyB0byBleGl0IGdyYWNlZnVsbHkuXG4gICAgaWYgKG51bGxPbk1pc3NpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgcmVsYXRpdmVTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIGJpYXM6IEVpdGhlciAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnIG9yXG4gKiAgICAgJ1NvdXJjZU1hcENvbnN1bWVyLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnU291cmNlTWFwQ29uc3VtZXIuR1JFQVRFU1RfTE9XRVJfQk9VTkQnLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC5cbiAqICAgICBUaGUgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICovXG5CYXNpY1NvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIFNvdXJjZU1hcENvbnN1bWVyX2dlbmVyYXRlZFBvc2l0aW9uRm9yKGFBcmdzKSB7XG4gICAgdmFyIHNvdXJjZSA9IHV0aWwuZ2V0QXJnKGFBcmdzLCAnc291cmNlJyk7XG4gICAgc291cmNlID0gdGhpcy5fZmluZFNvdXJjZUluZGV4KHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZSA8IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxpbmU6IG51bGwsXG4gICAgICAgIGNvbHVtbjogbnVsbCxcbiAgICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbmVlZGxlID0ge1xuICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICBvcmlnaW5hbExpbmU6IHV0aWwuZ2V0QXJnKGFBcmdzLCAnbGluZScpLFxuICAgICAgb3JpZ2luYWxDb2x1bW46IHV0aWwuZ2V0QXJnKGFBcmdzLCAnY29sdW1uJylcbiAgICB9O1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fZmluZE1hcHBpbmcoXG4gICAgICBuZWVkbGUsXG4gICAgICB0aGlzLl9vcmlnaW5hbE1hcHBpbmdzLFxuICAgICAgXCJvcmlnaW5hbExpbmVcIixcbiAgICAgIFwib3JpZ2luYWxDb2x1bW5cIixcbiAgICAgIHV0aWwuY29tcGFyZUJ5T3JpZ2luYWxQb3NpdGlvbnMsXG4gICAgICB1dGlsLmdldEFyZyhhQXJncywgJ2JpYXMnLCBTb3VyY2VNYXBDb25zdW1lci5HUkVBVEVTVF9MT1dFUl9CT1VORClcbiAgICApO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBtYXBwaW5nID0gdGhpcy5fb3JpZ2luYWxNYXBwaW5nc1tpbmRleF07XG5cbiAgICAgIGlmIChtYXBwaW5nLnNvdXJjZSA9PT0gbmVlZGxlLnNvdXJjZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxpbmU6IHV0aWwuZ2V0QXJnKG1hcHBpbmcsICdnZW5lcmF0ZWRMaW5lJywgbnVsbCksXG4gICAgICAgICAgY29sdW1uOiB1dGlsLmdldEFyZyhtYXBwaW5nLCAnZ2VuZXJhdGVkQ29sdW1uJywgbnVsbCksXG4gICAgICAgICAgbGFzdENvbHVtbjogdXRpbC5nZXRBcmcobWFwcGluZywgJ2xhc3RHZW5lcmF0ZWRDb2x1bW4nLCBudWxsKVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBsaW5lOiBudWxsLFxuICAgICAgY29sdW1uOiBudWxsLFxuICAgICAgbGFzdENvbHVtbjogbnVsbFxuICAgIH07XG4gIH07XG5cbmV4cG9ydHMuQmFzaWNTb3VyY2VNYXBDb25zdW1lciA9IEJhc2ljU291cmNlTWFwQ29uc3VtZXI7XG5cbi8qKlxuICogQW4gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyIGluc3RhbmNlIHJlcHJlc2VudHMgYSBwYXJzZWQgc291cmNlIG1hcCB3aGljaFxuICogd2UgY2FuIHF1ZXJ5IGZvciBpbmZvcm1hdGlvbi4gSXQgZGlmZmVycyBmcm9tIEJhc2ljU291cmNlTWFwQ29uc3VtZXIgaW5cbiAqIHRoYXQgaXQgdGFrZXMgXCJpbmRleGVkXCIgc291cmNlIG1hcHMgKGkuZS4gb25lcyB3aXRoIGEgXCJzZWN0aW9uc1wiIGZpZWxkKSBhc1xuICogaW5wdXQuXG4gKlxuICogVGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIHJhdyBzb3VyY2UgbWFwIChlaXRoZXIgYXMgYSBKU09OIHN0cmluZywgb3IgYWxyZWFkeVxuICogcGFyc2VkIHRvIGFuIG9iamVjdCkuIEFjY29yZGluZyB0byB0aGUgc3BlYyBmb3IgaW5kZXhlZCBzb3VyY2UgbWFwcywgdGhleVxuICogaGF2ZSB0aGUgZm9sbG93aW5nIGF0dHJpYnV0ZXM6XG4gKlxuICogICAtIHZlcnNpb246IFdoaWNoIHZlcnNpb24gb2YgdGhlIHNvdXJjZSBtYXAgc3BlYyB0aGlzIG1hcCBpcyBmb2xsb3dpbmcuXG4gKiAgIC0gZmlsZTogT3B0aW9uYWwuIFRoZSBnZW5lcmF0ZWQgZmlsZSB0aGlzIHNvdXJjZSBtYXAgaXMgYXNzb2NpYXRlZCB3aXRoLlxuICogICAtIHNlY3Rpb25zOiBBIGxpc3Qgb2Ygc2VjdGlvbiBkZWZpbml0aW9ucy5cbiAqXG4gKiBFYWNoIHZhbHVlIHVuZGVyIHRoZSBcInNlY3Rpb25zXCIgZmllbGQgaGFzIHR3byBmaWVsZHM6XG4gKiAgIC0gb2Zmc2V0OiBUaGUgb2Zmc2V0IGludG8gdGhlIG9yaWdpbmFsIHNwZWNpZmllZCBhdCB3aGljaCB0aGlzIHNlY3Rpb25cbiAqICAgICAgIGJlZ2lucyB0byBhcHBseSwgZGVmaW5lZCBhcyBhbiBvYmplY3Qgd2l0aCBhIFwibGluZVwiIGFuZCBcImNvbHVtblwiXG4gKiAgICAgICBmaWVsZC5cbiAqICAgLSBtYXA6IEEgc291cmNlIG1hcCBkZWZpbml0aW9uLiBUaGlzIHNvdXJjZSBtYXAgY291bGQgYWxzbyBiZSBpbmRleGVkLFxuICogICAgICAgYnV0IGRvZXNuJ3QgaGF2ZSB0byBiZS5cbiAqXG4gKiBJbnN0ZWFkIG9mIHRoZSBcIm1hcFwiIGZpZWxkLCBpdCdzIGFsc28gcG9zc2libGUgdG8gaGF2ZSBhIFwidXJsXCIgZmllbGRcbiAqIHNwZWNpZnlpbmcgYSBVUkwgdG8gcmV0cmlldmUgYSBzb3VyY2UgbWFwIGZyb20sIGJ1dCB0aGF0J3MgY3VycmVudGx5XG4gKiB1bnN1cHBvcnRlZC5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBzb3VyY2UgbWFwLCB0YWtlbiBmcm9tIHRoZSBzb3VyY2UgbWFwIHNwZWNbMF0sIGJ1dFxuICogbW9kaWZpZWQgdG8gb21pdCBhIHNlY3Rpb24gd2hpY2ggdXNlcyB0aGUgXCJ1cmxcIiBmaWVsZC5cbiAqXG4gKiAge1xuICogICAgdmVyc2lvbiA6IDMsXG4gKiAgICBmaWxlOiBcImFwcC5qc1wiLFxuICogICAgc2VjdGlvbnM6IFt7XG4gKiAgICAgIG9mZnNldDoge2xpbmU6MTAwLCBjb2x1bW46MTB9LFxuICogICAgICBtYXA6IHtcbiAqICAgICAgICB2ZXJzaW9uIDogMyxcbiAqICAgICAgICBmaWxlOiBcInNlY3Rpb24uanNcIixcbiAqICAgICAgICBzb3VyY2VzOiBbXCJmb28uanNcIiwgXCJiYXIuanNcIl0sXG4gKiAgICAgICAgbmFtZXM6IFtcInNyY1wiLCBcIm1hcHNcIiwgXCJhcmVcIiwgXCJmdW5cIl0sXG4gKiAgICAgICAgbWFwcGluZ3M6IFwiQUFBQSxFOztBQkNERTtcIlxuICogICAgICB9XG4gKiAgICB9XSxcbiAqICB9XG4gKlxuICogVGhlIHNlY29uZCBwYXJhbWV0ZXIsIGlmIGdpdmVuLCBpcyBhIHN0cmluZyB3aG9zZSB2YWx1ZSBpcyB0aGUgVVJMXG4gKiBhdCB3aGljaCB0aGUgc291cmNlIG1hcCB3YXMgZm91bmQuICBUaGlzIFVSTCBpcyB1c2VkIHRvIGNvbXB1dGUgdGhlXG4gKiBzb3VyY2VzIGFycmF5LlxuICpcbiAqIFswXTogaHR0cHM6Ly9kb2NzLmdvb2dsZS5jb20vZG9jdW1lbnQvZC8xVTFSR0FlaFF3UnlwVVRvdkYxS1JscGlPRnplMGItXzJnYzZmQUgwS1kway9lZGl0I2hlYWRpbmc9aC41MzVlczN4ZXByZ3RcbiAqL1xuZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyKGFTb3VyY2VNYXAsIGFTb3VyY2VNYXBVUkwpIHtcbiAgdmFyIHNvdXJjZU1hcCA9IGFTb3VyY2VNYXA7XG4gIGlmICh0eXBlb2YgYVNvdXJjZU1hcCA9PT0gJ3N0cmluZycpIHtcbiAgICBzb3VyY2VNYXAgPSB1dGlsLnBhcnNlU291cmNlTWFwSW5wdXQoYVNvdXJjZU1hcCk7XG4gIH1cblxuICB2YXIgdmVyc2lvbiA9IHV0aWwuZ2V0QXJnKHNvdXJjZU1hcCwgJ3ZlcnNpb24nKTtcbiAgdmFyIHNlY3Rpb25zID0gdXRpbC5nZXRBcmcoc291cmNlTWFwLCAnc2VjdGlvbnMnKTtcblxuICBpZiAodmVyc2lvbiAhPSB0aGlzLl92ZXJzaW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCB2ZXJzaW9uOiAnICsgdmVyc2lvbik7XG4gIH1cblxuICB0aGlzLl9zb3VyY2VzID0gbmV3IEFycmF5U2V0KCk7XG4gIHRoaXMuX25hbWVzID0gbmV3IEFycmF5U2V0KCk7XG5cbiAgdmFyIGxhc3RPZmZzZXQgPSB7XG4gICAgbGluZTogLTEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHRoaXMuX3NlY3Rpb25zID0gc2VjdGlvbnMubWFwKGZ1bmN0aW9uIChzKSB7XG4gICAgaWYgKHMudXJsKSB7XG4gICAgICAvLyBUaGUgdXJsIGZpZWxkIHdpbGwgcmVxdWlyZSBzdXBwb3J0IGZvciBhc3luY2hyb25pY2l0eS5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9zb3VyY2UtbWFwL2lzc3Vlcy8xNlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdXBwb3J0IGZvciB1cmwgZmllbGQgaW4gc2VjdGlvbnMgbm90IGltcGxlbWVudGVkLicpO1xuICAgIH1cbiAgICB2YXIgb2Zmc2V0ID0gdXRpbC5nZXRBcmcocywgJ29mZnNldCcpO1xuICAgIHZhciBvZmZzZXRMaW5lID0gdXRpbC5nZXRBcmcob2Zmc2V0LCAnbGluZScpO1xuICAgIHZhciBvZmZzZXRDb2x1bW4gPSB1dGlsLmdldEFyZyhvZmZzZXQsICdjb2x1bW4nKTtcblxuICAgIGlmIChvZmZzZXRMaW5lIDwgbGFzdE9mZnNldC5saW5lIHx8XG4gICAgICAgIChvZmZzZXRMaW5lID09PSBsYXN0T2Zmc2V0LmxpbmUgJiYgb2Zmc2V0Q29sdW1uIDwgbGFzdE9mZnNldC5jb2x1bW4pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3Rpb24gb2Zmc2V0cyBtdXN0IGJlIG9yZGVyZWQgYW5kIG5vbi1vdmVybGFwcGluZy4nKTtcbiAgICB9XG4gICAgbGFzdE9mZnNldCA9IG9mZnNldDtcblxuICAgIHJldHVybiB7XG4gICAgICBnZW5lcmF0ZWRPZmZzZXQ6IHtcbiAgICAgICAgLy8gVGhlIG9mZnNldCBmaWVsZHMgYXJlIDAtYmFzZWQsIGJ1dCB3ZSB1c2UgMS1iYXNlZCBpbmRpY2VzIHdoZW5cbiAgICAgICAgLy8gZW5jb2RpbmcvZGVjb2RpbmcgZnJvbSBWTFEuXG4gICAgICAgIGdlbmVyYXRlZExpbmU6IG9mZnNldExpbmUgKyAxLFxuICAgICAgICBnZW5lcmF0ZWRDb2x1bW46IG9mZnNldENvbHVtbiArIDFcbiAgICAgIH0sXG4gICAgICBjb25zdW1lcjogbmV3IFNvdXJjZU1hcENvbnN1bWVyKHV0aWwuZ2V0QXJnKHMsICdtYXAnKSwgYVNvdXJjZU1hcFVSTClcbiAgICB9XG4gIH0pO1xufVxuXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUpO1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNvdXJjZU1hcENvbnN1bWVyO1xuXG4vKipcbiAqIFRoZSB2ZXJzaW9uIG9mIHRoZSBzb3VyY2UgbWFwcGluZyBzcGVjIHRoYXQgd2UgYXJlIGNvbnN1bWluZy5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fdmVyc2lvbiA9IDM7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2Ygb3JpZ2luYWwgc291cmNlcy5cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lci5wcm90b3R5cGUsICdzb3VyY2VzJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc291cmNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBzb3VyY2VzLnB1c2godGhpcy5fc2VjdGlvbnNbaV0uY29uc3VtZXIuc291cmNlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xuICB9XG59KTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UsIGxpbmUsIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBnZW5lcmF0ZWRcbiAqIHNvdXJjZSdzIGxpbmUgYW5kIGNvbHVtbiBwb3NpdGlvbnMgcHJvdmlkZWQuIFRoZSBvbmx5IGFyZ3VtZW50IGlzIGFuIG9iamVjdFxuICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZS4gIFRoZSBjb2x1bW5cbiAqICAgICBudW1iZXIgaXMgMC1iYXNlZC5cbiAqXG4gKiBhbmQgYW4gb2JqZWN0IGlzIHJldHVybmVkIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgLSBzb3VyY2U6IFRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZSwgb3IgbnVsbC5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLCBvciBudWxsLiAgVGhlXG4gKiAgICAgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkLlxuICogICAtIG5hbWU6IFRoZSBvcmlnaW5hbCBpZGVudGlmaWVyLCBvciBudWxsLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLm9yaWdpbmFsUG9zaXRpb25Gb3IgPVxuICBmdW5jdGlvbiBJbmRleGVkU291cmNlTWFwQ29uc3VtZXJfb3JpZ2luYWxQb3NpdGlvbkZvcihhQXJncykge1xuICAgIHZhciBuZWVkbGUgPSB7XG4gICAgICBnZW5lcmF0ZWRMaW5lOiB1dGlsLmdldEFyZyhhQXJncywgJ2xpbmUnKSxcbiAgICAgIGdlbmVyYXRlZENvbHVtbjogdXRpbC5nZXRBcmcoYUFyZ3MsICdjb2x1bW4nKVxuICAgIH07XG5cbiAgICAvLyBGaW5kIHRoZSBzZWN0aW9uIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRlZCBwb3NpdGlvbiB3ZSdyZSB0cnlpbmcgdG8gbWFwXG4gICAgLy8gdG8gYW4gb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgdmFyIHNlY3Rpb25JbmRleCA9IGJpbmFyeVNlYXJjaC5zZWFyY2gobmVlZGxlLCB0aGlzLl9zZWN0aW9ucyxcbiAgICAgIGZ1bmN0aW9uKG5lZWRsZSwgc2VjdGlvbikge1xuICAgICAgICB2YXIgY21wID0gbmVlZGxlLmdlbmVyYXRlZExpbmUgLSBzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lO1xuICAgICAgICBpZiAoY21wKSB7XG4gICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobmVlZGxlLmdlbmVyYXRlZENvbHVtbiAtXG4gICAgICAgICAgICAgICAgc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgIH0pO1xuICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbc2VjdGlvbkluZGV4XTtcblxuICAgIGlmICghc2VjdGlvbikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiBudWxsLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGwsXG4gICAgICAgIG5hbWU6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlY3Rpb24uY29uc3VtZXIub3JpZ2luYWxQb3NpdGlvbkZvcih7XG4gICAgICBsaW5lOiBuZWVkbGUuZ2VuZXJhdGVkTGluZSAtXG4gICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICBjb2x1bW46IG5lZWRsZS5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbmVlZGxlLmdlbmVyYXRlZExpbmVcbiAgICAgICAgID8gc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkQ29sdW1uIC0gMVxuICAgICAgICAgOiAwKSxcbiAgICAgIGJpYXM6IGFBcmdzLmJpYXNcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB3ZSBoYXZlIHRoZSBzb3VyY2UgY29udGVudCBmb3IgZXZlcnkgc291cmNlIGluIHRoZSBzb3VyY2VcbiAqIG1hcCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5JbmRleGVkU291cmNlTWFwQ29uc3VtZXIucHJvdG90eXBlLmhhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX2hhc0NvbnRlbnRzT2ZBbGxTb3VyY2VzKCkge1xuICAgIHJldHVybiB0aGlzLl9zZWN0aW9ucy5ldmVyeShmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIHMuY29uc3VtZXIuaGFzQ29udGVudHNPZkFsbFNvdXJjZXMoKTtcbiAgICB9KTtcbiAgfTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvcmlnaW5hbCBzb3VyY2UgY29udGVudC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgdGhlIHVybCBvZiB0aGVcbiAqIG9yaWdpbmFsIHNvdXJjZSBmaWxlLiBSZXR1cm5zIG51bGwgaWYgbm8gb3JpZ2luYWwgc291cmNlIGNvbnRlbnQgaXNcbiAqIGF2YWlsYWJsZS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5zb3VyY2VDb250ZW50Rm9yID1cbiAgZnVuY3Rpb24gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyX3NvdXJjZUNvbnRlbnRGb3IoYVNvdXJjZSwgbnVsbE9uTWlzc2luZykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIHZhciBjb250ZW50ID0gc2VjdGlvbi5jb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKGFTb3VyY2UsIHRydWUpO1xuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChudWxsT25NaXNzaW5nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiJyArIGFTb3VyY2UgKyAnXCIgaXMgbm90IGluIHRoZSBTb3VyY2VNYXAuJyk7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGdlbmVyYXRlZCBsaW5lIGFuZCBjb2x1bW4gaW5mb3JtYXRpb24gZm9yIHRoZSBvcmlnaW5hbCBzb3VyY2UsXG4gKiBsaW5lLCBhbmQgY29sdW1uIHBvc2l0aW9ucyBwcm92aWRlZC4gVGhlIG9ubHkgYXJndW1lbnQgaXMgYW4gb2JqZWN0IHdpdGhcbiAqIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIC0gc291cmNlOiBUaGUgZmlsZW5hbWUgb2YgdGhlIG9yaWdpbmFsIHNvdXJjZS5cbiAqICAgLSBsaW5lOiBUaGUgbGluZSBudW1iZXIgaW4gdGhlIG9yaWdpbmFsIHNvdXJjZS4gIFRoZSBsaW5lIG51bWJlclxuICogICAgIGlzIDEtYmFzZWQuXG4gKiAgIC0gY29sdW1uOiBUaGUgY29sdW1uIG51bWJlciBpbiB0aGUgb3JpZ2luYWwgc291cmNlLiAgVGhlIGNvbHVtblxuICogICAgIG51bWJlciBpcyAwLWJhc2VkLlxuICpcbiAqIGFuZCBhbiBvYmplY3QgaXMgcmV0dXJuZWQgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGxpbmU6IFRoZSBsaW5lIG51bWJlciBpbiB0aGUgZ2VuZXJhdGVkIHNvdXJjZSwgb3IgbnVsbC4gIFRoZVxuICogICAgIGxpbmUgbnVtYmVyIGlzIDEtYmFzZWQuIFxuICogICAtIGNvbHVtbjogVGhlIGNvbHVtbiBudW1iZXIgaW4gdGhlIGdlbmVyYXRlZCBzb3VyY2UsIG9yIG51bGwuXG4gKiAgICAgVGhlIGNvbHVtbiBudW1iZXIgaXMgMC1iYXNlZC5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5nZW5lcmF0ZWRQb3NpdGlvbkZvciA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fc2VjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWN0aW9uID0gdGhpcy5fc2VjdGlvbnNbaV07XG5cbiAgICAgIC8vIE9ubHkgY29uc2lkZXIgdGhpcyBzZWN0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgc291cmNlIGlzIGluIHRoZSBsaXN0IG9mXG4gICAgICAvLyBzb3VyY2VzIG9mIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChzZWN0aW9uLmNvbnN1bWVyLl9maW5kU291cmNlSW5kZXgodXRpbC5nZXRBcmcoYUFyZ3MsICdzb3VyY2UnKSkgPT09IC0xKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGdlbmVyYXRlZFBvc2l0aW9uID0gc2VjdGlvbi5jb25zdW1lci5nZW5lcmF0ZWRQb3NpdGlvbkZvcihhQXJncyk7XG4gICAgICBpZiAoZ2VuZXJhdGVkUG9zaXRpb24pIHtcbiAgICAgICAgdmFyIHJldCA9IHtcbiAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWRQb3NpdGlvbi5saW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWRQb3NpdGlvbi5jb2x1bW4gK1xuICAgICAgICAgICAgKHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZExpbmUgPT09IGdlbmVyYXRlZFBvc2l0aW9uLmxpbmVcbiAgICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgICA6IDApXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmU6IG51bGwsXG4gICAgICBjb2x1bW46IG51bGxcbiAgICB9O1xuICB9O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBtYXBwaW5ncyBpbiBhIHN0cmluZyBpbiB0byBhIGRhdGEgc3RydWN0dXJlIHdoaWNoIHdlIGNhbiBlYXNpbHlcbiAqIHF1ZXJ5ICh0aGUgb3JkZXJlZCBhcnJheXMgaW4gdGhlIGB0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3NgIGFuZFxuICogYHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzYCBwcm9wZXJ0aWVzKS5cbiAqL1xuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyLnByb3RvdHlwZS5fcGFyc2VNYXBwaW5ncyA9XG4gIGZ1bmN0aW9uIEluZGV4ZWRTb3VyY2VNYXBDb25zdW1lcl9wYXJzZU1hcHBpbmdzKGFTdHIsIGFTb3VyY2VSb290KSB7XG4gICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzID0gW107XG4gICAgdGhpcy5fX29yaWdpbmFsTWFwcGluZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3NlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VjdGlvbiA9IHRoaXMuX3NlY3Rpb25zW2ldO1xuICAgICAgdmFyIHNlY3Rpb25NYXBwaW5ncyA9IHNlY3Rpb24uY29uc3VtZXIuX2dlbmVyYXRlZE1hcHBpbmdzO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZWN0aW9uTWFwcGluZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG1hcHBpbmcgPSBzZWN0aW9uTWFwcGluZ3Nbal07XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IHNlY3Rpb24uY29uc3VtZXIuX3NvdXJjZXMuYXQobWFwcGluZy5zb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSB1dGlsLmNvbXB1dGVTb3VyY2VVUkwoc2VjdGlvbi5jb25zdW1lci5zb3VyY2VSb290LCBzb3VyY2UsIHRoaXMuX3NvdXJjZU1hcFVSTCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZXMuYWRkKHNvdXJjZSk7XG4gICAgICAgIHNvdXJjZSA9IHRoaXMuX3NvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuXG4gICAgICAgIHZhciBuYW1lID0gbnVsbDtcbiAgICAgICAgaWYgKG1hcHBpbmcubmFtZSkge1xuICAgICAgICAgIG5hbWUgPSBzZWN0aW9uLmNvbnN1bWVyLl9uYW1lcy5hdChtYXBwaW5nLm5hbWUpO1xuICAgICAgICAgIHRoaXMuX25hbWVzLmFkZChuYW1lKTtcbiAgICAgICAgICBuYW1lID0gdGhpcy5fbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBtYXBwaW5ncyBjb21pbmcgZnJvbSB0aGUgY29uc3VtZXIgZm9yIHRoZSBzZWN0aW9uIGhhdmVcbiAgICAgICAgLy8gZ2VuZXJhdGVkIHBvc2l0aW9ucyByZWxhdGl2ZSB0byB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24sIHNvIHdlXG4gICAgICAgIC8vIG5lZWQgdG8gb2Zmc2V0IHRoZW0gdG8gYmUgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBjb25jYXRlbmF0ZWRcbiAgICAgICAgLy8gZ2VuZXJhdGVkIGZpbGUuXG4gICAgICAgIHZhciBhZGp1c3RlZE1hcHBpbmcgPSB7XG4gICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgZ2VuZXJhdGVkTGluZTogbWFwcGluZy5nZW5lcmF0ZWRMaW5lICtcbiAgICAgICAgICAgIChzZWN0aW9uLmdlbmVyYXRlZE9mZnNldC5nZW5lcmF0ZWRMaW5lIC0gMSksXG4gICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uOiBtYXBwaW5nLmdlbmVyYXRlZENvbHVtbiArXG4gICAgICAgICAgICAoc2VjdGlvbi5nZW5lcmF0ZWRPZmZzZXQuZ2VuZXJhdGVkTGluZSA9PT0gbWFwcGluZy5nZW5lcmF0ZWRMaW5lXG4gICAgICAgICAgICA/IHNlY3Rpb24uZ2VuZXJhdGVkT2Zmc2V0LmdlbmVyYXRlZENvbHVtbiAtIDFcbiAgICAgICAgICAgIDogMCksXG4gICAgICAgICAgb3JpZ2luYWxMaW5lOiBtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICBvcmlnaW5hbENvbHVtbjogbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICBuYW1lOiBuYW1lXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5fX2dlbmVyYXRlZE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhZGp1c3RlZE1hcHBpbmcub3JpZ2luYWxMaW5lID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX19vcmlnaW5hbE1hcHBpbmdzLnB1c2goYWRqdXN0ZWRNYXBwaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHF1aWNrU29ydCh0aGlzLl9fZ2VuZXJhdGVkTWFwcGluZ3MsIHV0aWwuY29tcGFyZUJ5R2VuZXJhdGVkUG9zaXRpb25zRGVmbGF0ZWQpO1xuICAgIHF1aWNrU29ydCh0aGlzLl9fb3JpZ2luYWxNYXBwaW5ncywgdXRpbC5jb21wYXJlQnlPcmlnaW5hbFBvc2l0aW9ucyk7XG4gIH07XG5cbmV4cG9ydHMuSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyID0gSW5kZXhlZFNvdXJjZU1hcENvbnN1bWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc291cmNlLW1hcC1jb25zdW1lci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbmV4cG9ydHMuR1JFQVRFU1RfTE9XRVJfQk9VTkQgPSAxO1xuZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCA9IDI7XG5cbi8qKlxuICogUmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9mIGJpbmFyeSBzZWFyY2guXG4gKlxuICogQHBhcmFtIGFMb3cgSW5kaWNlcyBoZXJlIGFuZCBsb3dlciBkbyBub3QgY29udGFpbiB0aGUgbmVlZGxlLlxuICogQHBhcmFtIGFIaWdoIEluZGljZXMgaGVyZSBhbmQgaGlnaGVyIGRvIG5vdCBjb250YWluIHRoZSBuZWVkbGUuXG4gKiBAcGFyYW0gYU5lZWRsZSBUaGUgZWxlbWVudCBiZWluZyBzZWFyY2hlZCBmb3IuXG4gKiBAcGFyYW0gYUhheXN0YWNrIFRoZSBub24tZW1wdHkgYXJyYXkgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgRnVuY3Rpb24gd2hpY2ggdGFrZXMgdHdvIGVsZW1lbnRzIGFuZCByZXR1cm5zIC0xLCAwLCBvciAxLlxuICogQHBhcmFtIGFCaWFzIEVpdGhlciAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJyBvclxuICogICAgICdiaW5hcnlTZWFyY2guTEVBU1RfVVBQRVJfQk9VTkQnLiBTcGVjaWZpZXMgd2hldGhlciB0byByZXR1cm4gdGhlXG4gKiAgICAgY2xvc2VzdCBlbGVtZW50IHRoYXQgaXMgc21hbGxlciB0aGFuIG9yIGdyZWF0ZXIgdGhhbiB0aGUgb25lIHdlIGFyZVxuICogICAgIHNlYXJjaGluZyBmb3IsIHJlc3BlY3RpdmVseSwgaWYgdGhlIGV4YWN0IGVsZW1lbnQgY2Fubm90IGJlIGZvdW5kLlxuICovXG5mdW5jdGlvbiByZWN1cnNpdmVTZWFyY2goYUxvdywgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdGVybWluYXRlcyB3aGVuIG9uZSBvZiB0aGUgZm9sbG93aW5nIGlzIHRydWU6XG4gIC8vXG4gIC8vICAgMS4gV2UgZmluZCB0aGUgZXhhY3QgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gIC8vXG4gIC8vICAgMi4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBidXQgd2UgY2FuIHJldHVybiB0aGUgaW5kZXggb2ZcbiAgLy8gICAgICB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQuXG4gIC8vXG4gIC8vICAgMy4gV2UgZGlkIG5vdCBmaW5kIHRoZSBleGFjdCBlbGVtZW50LCBhbmQgdGhlcmUgaXMgbm8gbmV4dC1jbG9zZXN0XG4gIC8vICAgICAgZWxlbWVudCB0aGFuIHRoZSBvbmUgd2UgYXJlIHNlYXJjaGluZyBmb3IsIHNvIHdlIHJldHVybiAtMS5cbiAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGFIaWdoIC0gYUxvdykgLyAyKSArIGFMb3c7XG4gIHZhciBjbXAgPSBhQ29tcGFyZShhTmVlZGxlLCBhSGF5c3RhY2tbbWlkXSwgdHJ1ZSk7XG4gIGlmIChjbXAgPT09IDApIHtcbiAgICAvLyBGb3VuZCB0aGUgZWxlbWVudCB3ZSBhcmUgbG9va2luZyBmb3IuXG4gICAgcmV0dXJuIG1pZDtcbiAgfVxuICBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBncmVhdGVyIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKGFIaWdoIC0gbWlkID4gMSkge1xuICAgICAgLy8gVGhlIGVsZW1lbnQgaXMgaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICByZXR1cm4gcmVjdXJzaXZlU2VhcmNoKG1pZCwgYUhpZ2gsIGFOZWVkbGUsIGFIYXlzdGFjaywgYUNvbXBhcmUsIGFCaWFzKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZXhhY3QgbmVlZGxlIGVsZW1lbnQgd2FzIG5vdCBmb3VuZCBpbiB0aGlzIGhheXN0YWNrLiBEZXRlcm1pbmUgaWZcbiAgICAvLyB3ZSBhcmUgaW4gdGVybWluYXRpb24gY2FzZSAoMykgb3IgKDIpIGFuZCByZXR1cm4gdGhlIGFwcHJvcHJpYXRlIHRoaW5nLlxuICAgIGlmIChhQmlhcyA9PSBleHBvcnRzLkxFQVNUX1VQUEVSX0JPVU5EKSB7XG4gICAgICByZXR1cm4gYUhpZ2ggPCBhSGF5c3RhY2subGVuZ3RoID8gYUhpZ2ggOiAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gT3VyIG5lZWRsZSBpcyBsZXNzIHRoYW4gYUhheXN0YWNrW21pZF0uXG4gICAgaWYgKG1pZCAtIGFMb3cgPiAxKSB7XG4gICAgICAvLyBUaGUgZWxlbWVudCBpcyBpbiB0aGUgbG93ZXIgaGFsZi5cbiAgICAgIHJldHVybiByZWN1cnNpdmVTZWFyY2goYUxvdywgbWlkLCBhTmVlZGxlLCBhSGF5c3RhY2ssIGFDb21wYXJlLCBhQmlhcyk7XG4gICAgfVxuXG4gICAgLy8gd2UgYXJlIGluIHRlcm1pbmF0aW9uIGNhc2UgKDMpIG9yICgyKSBhbmQgcmV0dXJuIHRoZSBhcHByb3ByaWF0ZSB0aGluZy5cbiAgICBpZiAoYUJpYXMgPT0gZXhwb3J0cy5MRUFTVF9VUFBFUl9CT1VORCkge1xuICAgICAgcmV0dXJuIG1pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFMb3cgPCAwID8gLTEgOiBhTG93O1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYmluYXJ5IHNlYXJjaCB3aGljaCB3aWxsIGFsd2F5cyB0cnkgYW5kIHJldHVyblxuICogdGhlIGluZGV4IG9mIHRoZSBjbG9zZXN0IGVsZW1lbnQgaWYgdGhlcmUgaXMgbm8gZXhhY3QgaGl0LiBUaGlzIGlzIGJlY2F1c2VcbiAqIG1hcHBpbmdzIGJldHdlZW4gb3JpZ2luYWwgYW5kIGdlbmVyYXRlZCBsaW5lL2NvbCBwYWlycyBhcmUgc2luZ2xlIHBvaW50cyxcbiAqIGFuZCB0aGVyZSBpcyBhbiBpbXBsaWNpdCByZWdpb24gYmV0d2VlbiBlYWNoIG9mIHRoZW0sIHNvIGEgbWlzcyBqdXN0IG1lYW5zXG4gKiB0aGF0IHlvdSBhcmVuJ3Qgb24gdGhlIHZlcnkgc3RhcnQgb2YgYSByZWdpb24uXG4gKlxuICogQHBhcmFtIGFOZWVkbGUgVGhlIGVsZW1lbnQgeW91IGFyZSBsb29raW5nIGZvci5cbiAqIEBwYXJhbSBhSGF5c3RhY2sgVGhlIGFycmF5IHRoYXQgaXMgYmVpbmcgc2VhcmNoZWQuXG4gKiBAcGFyYW0gYUNvbXBhcmUgQSBmdW5jdGlvbiB3aGljaCB0YWtlcyB0aGUgbmVlZGxlIGFuZCBhbiBlbGVtZW50IGluIHRoZVxuICogICAgIGFycmF5IGFuZCByZXR1cm5zIC0xLCAwLCBvciAxIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBuZWVkbGUgaXMgbGVzc1xuICogICAgIHRoYW4sIGVxdWFsIHRvLCBvciBncmVhdGVyIHRoYW4gdGhlIGVsZW1lbnQsIHJlc3BlY3RpdmVseS5cbiAqIEBwYXJhbSBhQmlhcyBFaXRoZXIgJ2JpbmFyeVNlYXJjaC5HUkVBVEVTVF9MT1dFUl9CT1VORCcgb3JcbiAqICAgICAnYmluYXJ5U2VhcmNoLkxFQVNUX1VQUEVSX0JPVU5EJy4gU3BlY2lmaWVzIHdoZXRoZXIgdG8gcmV0dXJuIHRoZVxuICogICAgIGNsb3Nlc3QgZWxlbWVudCB0aGF0IGlzIHNtYWxsZXIgdGhhbiBvciBncmVhdGVyIHRoYW4gdGhlIG9uZSB3ZSBhcmVcbiAqICAgICBzZWFyY2hpbmcgZm9yLCByZXNwZWN0aXZlbHksIGlmIHRoZSBleGFjdCBlbGVtZW50IGNhbm5vdCBiZSBmb3VuZC5cbiAqICAgICBEZWZhdWx0cyB0byAnYmluYXJ5U2VhcmNoLkdSRUFURVNUX0xPV0VSX0JPVU5EJy5cbiAqL1xuZXhwb3J0cy5zZWFyY2ggPSBmdW5jdGlvbiBzZWFyY2goYU5lZWRsZSwgYUhheXN0YWNrLCBhQ29tcGFyZSwgYUJpYXMpIHtcbiAgaWYgKGFIYXlzdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICB2YXIgaW5kZXggPSByZWN1cnNpdmVTZWFyY2goLTEsIGFIYXlzdGFjay5sZW5ndGgsIGFOZWVkbGUsIGFIYXlzdGFjayxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFDb21wYXJlLCBhQmlhcyB8fCBleHBvcnRzLkdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8vIFdlIGhhdmUgZm91bmQgZWl0aGVyIHRoZSBleGFjdCBlbGVtZW50LCBvciB0aGUgbmV4dC1jbG9zZXN0IGVsZW1lbnQgdGhhblxuICAvLyB0aGUgb25lIHdlIGFyZSBzZWFyY2hpbmcgZm9yLiBIb3dldmVyLCB0aGVyZSBtYXkgYmUgbW9yZSB0aGFuIG9uZSBzdWNoXG4gIC8vIGVsZW1lbnQuIE1ha2Ugc3VyZSB3ZSBhbHdheXMgcmV0dXJuIHRoZSBzbWFsbGVzdCBvZiB0aGVzZS5cbiAgd2hpbGUgKGluZGV4IC0gMSA+PSAwKSB7XG4gICAgaWYgKGFDb21wYXJlKGFIYXlzdGFja1tpbmRleF0sIGFIYXlzdGFja1tpbmRleCAtIDFdLCB0cnVlKSAhPT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC0taW5kZXg7XG4gIH1cblxuICByZXR1cm4gaW5kZXg7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvYmluYXJ5LXNlYXJjaC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbi8vIEl0IHR1cm5zIG91dCB0aGF0IHNvbWUgKG1vc3Q/KSBKYXZhU2NyaXB0IGVuZ2luZXMgZG9uJ3Qgc2VsZi1ob3N0XG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgLiBUaGlzIG1ha2VzIHNlbnNlIGJlY2F1c2UgQysrIHdpbGwgbGlrZWx5IHJlbWFpblxuLy8gZmFzdGVyIHRoYW4gSlMgd2hlbiBkb2luZyByYXcgQ1BVLWludGVuc2l2ZSBzb3J0aW5nLiBIb3dldmVyLCB3aGVuIHVzaW5nIGFcbi8vIGN1c3RvbSBjb21wYXJhdG9yIGZ1bmN0aW9uLCBjYWxsaW5nIGJhY2sgYW5kIGZvcnRoIGJldHdlZW4gdGhlIFZNJ3MgQysrIGFuZFxuLy8gSklUJ2QgSlMgaXMgcmF0aGVyIHNsb3cgKmFuZCogbG9zZXMgSklUIHR5cGUgaW5mb3JtYXRpb24sIHJlc3VsdGluZyBpblxuLy8gd29yc2UgZ2VuZXJhdGVkIGNvZGUgZm9yIHRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIHRoYW4gd291bGQgYmUgb3B0aW1hbC4gSW5cbi8vIGZhY3QsIHdoZW4gc29ydGluZyB3aXRoIGEgY29tcGFyYXRvciwgdGhlc2UgY29zdHMgb3V0d2VpZ2ggdGhlIGJlbmVmaXRzIG9mXG4vLyBzb3J0aW5nIGluIEMrKy4gQnkgdXNpbmcgb3VyIG93biBKUy1pbXBsZW1lbnRlZCBRdWljayBTb3J0IChiZWxvdyksIHdlIGdldFxuLy8gYSB+MzUwMG1zIG1lYW4gc3BlZWQtdXAgaW4gYGJlbmNoL2JlbmNoLmh0bWxgLlxuXG4vKipcbiAqIFN3YXAgdGhlIGVsZW1lbnRzIGluZGV4ZWQgYnkgYHhgIGFuZCBgeWAgaW4gdGhlIGFycmF5IGBhcnlgLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIFRoZSBhcnJheS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gKiAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBmaXJzdCBpdGVtLlxuICogQHBhcmFtIHtOdW1iZXJ9IHlcbiAqICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHNlY29uZCBpdGVtLlxuICovXG5mdW5jdGlvbiBzd2FwKGFyeSwgeCwgeSkge1xuICB2YXIgdGVtcCA9IGFyeVt4XTtcbiAgYXJ5W3hdID0gYXJ5W3ldO1xuICBhcnlbeV0gPSB0ZW1wO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSByYW5kb20gaW50ZWdlciB3aXRoaW4gdGhlIHJhbmdlIGBsb3cgLi4gaGlnaGAgaW5jbHVzaXZlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBsb3dcbiAqICAgICAgICBUaGUgbG93ZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2hcbiAqICAgICAgICBUaGUgdXBwZXIgYm91bmQgb24gdGhlIHJhbmdlLlxuICovXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKGxvdywgaGlnaCkge1xuICByZXR1cm4gTWF0aC5yb3VuZChsb3cgKyAoTWF0aC5yYW5kb20oKSAqIChoaWdoIC0gbG93KSkpO1xufVxuXG4vKipcbiAqIFRoZSBRdWljayBTb3J0IGFsZ29yaXRobS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnlcbiAqICAgICAgICBBbiBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29tcGFyYXRvclxuICogICAgICAgIEZ1bmN0aW9uIHRvIHVzZSB0byBjb21wYXJlIHR3byBpdGVtcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBwXG4gKiAgICAgICAgU3RhcnQgaW5kZXggb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gclxuICogICAgICAgIEVuZCBpbmRleCBvZiB0aGUgYXJyYXlcbiAqL1xuZnVuY3Rpb24gZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCByKSB7XG4gIC8vIElmIG91ciBsb3dlciBib3VuZCBpcyBsZXNzIHRoYW4gb3VyIHVwcGVyIGJvdW5kLCB3ZSAoMSkgcGFydGl0aW9uIHRoZVxuICAvLyBhcnJheSBpbnRvIHR3byBwaWVjZXMgYW5kICgyKSByZWN1cnNlIG9uIGVhY2ggaGFsZi4gSWYgaXQgaXMgbm90LCB0aGlzIGlzXG4gIC8vIHRoZSBlbXB0eSBhcnJheSBhbmQgb3VyIGJhc2UgY2FzZS5cblxuICBpZiAocCA8IHIpIHtcbiAgICAvLyAoMSkgUGFydGl0aW9uaW5nLlxuICAgIC8vXG4gICAgLy8gVGhlIHBhcnRpdGlvbmluZyBjaG9vc2VzIGEgcGl2b3QgYmV0d2VlbiBgcGAgYW5kIGByYCBhbmQgbW92ZXMgYWxsXG4gICAgLy8gZWxlbWVudHMgdGhhdCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdCB0byB0aGUgYmVmb3JlIGl0LCBhbmRcbiAgICAvLyBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgYXJlIGdyZWF0ZXIgdGhhbiBpdCBhZnRlciBpdC4gVGhlIGVmZmVjdCBpcyB0aGF0XG4gICAgLy8gb25jZSBwYXJ0aXRpb24gaXMgZG9uZSwgdGhlIHBpdm90IGlzIGluIHRoZSBleGFjdCBwbGFjZSBpdCB3aWxsIGJlIHdoZW5cbiAgICAvLyB0aGUgYXJyYXkgaXMgcHV0IGluIHNvcnRlZCBvcmRlciwgYW5kIGl0IHdpbGwgbm90IG5lZWQgdG8gYmUgbW92ZWRcbiAgICAvLyBhZ2Fpbi4gVGhpcyBydW5zIGluIE8obikgdGltZS5cblxuICAgIC8vIEFsd2F5cyBjaG9vc2UgYSByYW5kb20gcGl2b3Qgc28gdGhhdCBhbiBpbnB1dCBhcnJheSB3aGljaCBpcyByZXZlcnNlXG4gICAgLy8gc29ydGVkIGRvZXMgbm90IGNhdXNlIE8obl4yKSBydW5uaW5nIHRpbWUuXG4gICAgdmFyIHBpdm90SW5kZXggPSByYW5kb21JbnRJblJhbmdlKHAsIHIpO1xuICAgIHZhciBpID0gcCAtIDE7XG5cbiAgICBzd2FwKGFyeSwgcGl2b3RJbmRleCwgcik7XG4gICAgdmFyIHBpdm90ID0gYXJ5W3JdO1xuXG4gICAgLy8gSW1tZWRpYXRlbHkgYWZ0ZXIgYGpgIGlzIGluY3JlbWVudGVkIGluIHRoaXMgbG9vcCwgdGhlIGZvbGxvd2luZyBob2xkXG4gICAgLy8gdHJ1ZTpcbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbcCAuLiBpXWAgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwaXZvdC5cbiAgICAvL1xuICAgIC8vICAgKiBFdmVyeSBlbGVtZW50IGluIGBhcnlbaSsxIC4uIGotMV1gIGlzIGdyZWF0ZXIgdGhhbiB0aGUgcGl2b3QuXG4gICAgZm9yICh2YXIgaiA9IHA7IGogPCByOyBqKyspIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFyeVtqXSwgcGl2b3QpIDw9IDApIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgICBzd2FwKGFyeSwgaSwgaik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dhcChhcnksIGkgKyAxLCBqKTtcbiAgICB2YXIgcSA9IGkgKyAxO1xuXG4gICAgLy8gKDIpIFJlY3Vyc2Ugb24gZWFjaCBoYWxmLlxuXG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBwLCBxIC0gMSk7XG4gICAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCBxICsgMSwgcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBnaXZlbiBhcnJheSBpbi1wbGFjZSB3aXRoIHRoZSBnaXZlbiBjb21wYXJhdG9yIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFyeVxuICogICAgICAgIEFuIGFycmF5IHRvIHNvcnQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjb21wYXJhdG9yXG4gKiAgICAgICAgRnVuY3Rpb24gdG8gdXNlIHRvIGNvbXBhcmUgdHdvIGl0ZW1zLlxuICovXG5leHBvcnRzLnF1aWNrU29ydCA9IGZ1bmN0aW9uIChhcnksIGNvbXBhcmF0b3IpIHtcbiAgZG9RdWlja1NvcnQoYXJ5LCBjb21wYXJhdG9yLCAwLCBhcnkubGVuZ3RoIC0gMSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvcXVpY2stc29ydC5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKiAtKi0gTW9kZToganM7IGpzLWluZGVudC1sZXZlbDogMjsgLSotICovXG4vKlxuICogQ29weXJpZ2h0IDIwMTEgTW96aWxsYSBGb3VuZGF0aW9uIGFuZCBjb250cmlidXRvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBOZXcgQlNEIGxpY2Vuc2UuIFNlZSBMSUNFTlNFIG9yOlxuICogaHR0cDovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL0JTRC0zLUNsYXVzZVxuICovXG5cbnZhciBTb3VyY2VNYXBHZW5lcmF0b3IgPSByZXF1aXJlKCcuL3NvdXJjZS1tYXAtZ2VuZXJhdG9yJykuU291cmNlTWFwR2VuZXJhdG9yO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhIFdpbmRvd3Mtc3R5bGUgYFxcclxcbmAgbmV3bGluZSBvciBhIGBcXG5gIG5ld2xpbmUgdXNlZCBieSBhbGwgb3RoZXJcbi8vIG9wZXJhdGluZyBzeXN0ZW1zIHRoZXNlIGRheXMgKGNhcHR1cmluZyB0aGUgcmVzdWx0KS5cbnZhciBSRUdFWF9ORVdMSU5FID0gLyhcXHI/XFxuKS87XG5cbi8vIE5ld2xpbmUgY2hhcmFjdGVyIGNvZGUgZm9yIGNoYXJDb2RlQXQoKSBjb21wYXJpc29uc1xudmFyIE5FV0xJTkVfQ09ERSA9IDEwO1xuXG4vLyBQcml2YXRlIHN5bWJvbCBmb3IgaWRlbnRpZnlpbmcgYFNvdXJjZU5vZGVgcyB3aGVuIG11bHRpcGxlIHZlcnNpb25zIG9mXG4vLyB0aGUgc291cmNlLW1hcCBsaWJyYXJ5IGFyZSBsb2FkZWQuIFRoaXMgTVVTVCBOT1QgQ0hBTkdFIGFjcm9zc1xuLy8gdmVyc2lvbnMhXG52YXIgaXNTb3VyY2VOb2RlID0gXCIkJCRpc1NvdXJjZU5vZGUkJCRcIjtcblxuLyoqXG4gKiBTb3VyY2VOb2RlcyBwcm92aWRlIGEgd2F5IHRvIGFic3RyYWN0IG92ZXIgaW50ZXJwb2xhdGluZy9jb25jYXRlbmF0aW5nXG4gKiBzbmlwcGV0cyBvZiBnZW5lcmF0ZWQgSmF2YVNjcmlwdCBzb3VyY2UgY29kZSB3aGlsZSBtYWludGFpbmluZyB0aGUgbGluZSBhbmRcbiAqIGNvbHVtbiBpbmZvcm1hdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIG9yaWdpbmFsIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwYXJhbSBhTGluZSBUaGUgb3JpZ2luYWwgbGluZSBudW1iZXIuXG4gKiBAcGFyYW0gYUNvbHVtbiBUaGUgb3JpZ2luYWwgY29sdW1uIG51bWJlci5cbiAqIEBwYXJhbSBhU291cmNlIFRoZSBvcmlnaW5hbCBzb3VyY2UncyBmaWxlbmFtZS5cbiAqIEBwYXJhbSBhQ2h1bmtzIE9wdGlvbmFsLiBBbiBhcnJheSBvZiBzdHJpbmdzIHdoaWNoIGFyZSBzbmlwcGV0cyBvZlxuICogICAgICAgIGdlbmVyYXRlZCBKUywgb3Igb3RoZXIgU291cmNlTm9kZXMuXG4gKiBAcGFyYW0gYU5hbWUgVGhlIG9yaWdpbmFsIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIFNvdXJjZU5vZGUoYUxpbmUsIGFDb2x1bW4sIGFTb3VyY2UsIGFDaHVua3MsIGFOYW1lKSB7XG4gIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgdGhpcy5zb3VyY2VDb250ZW50cyA9IHt9O1xuICB0aGlzLmxpbmUgPSBhTGluZSA9PSBudWxsID8gbnVsbCA6IGFMaW5lO1xuICB0aGlzLmNvbHVtbiA9IGFDb2x1bW4gPT0gbnVsbCA/IG51bGwgOiBhQ29sdW1uO1xuICB0aGlzLnNvdXJjZSA9IGFTb3VyY2UgPT0gbnVsbCA/IG51bGwgOiBhU291cmNlO1xuICB0aGlzLm5hbWUgPSBhTmFtZSA9PSBudWxsID8gbnVsbCA6IGFOYW1lO1xuICB0aGlzW2lzU291cmNlTm9kZV0gPSB0cnVlO1xuICBpZiAoYUNodW5rcyAhPSBudWxsKSB0aGlzLmFkZChhQ2h1bmtzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgU291cmNlTm9kZSBmcm9tIGdlbmVyYXRlZCBjb2RlIGFuZCBhIFNvdXJjZU1hcENvbnN1bWVyLlxuICpcbiAqIEBwYXJhbSBhR2VuZXJhdGVkQ29kZSBUaGUgZ2VuZXJhdGVkIGNvZGVcbiAqIEBwYXJhbSBhU291cmNlTWFwQ29uc3VtZXIgVGhlIFNvdXJjZU1hcCBmb3IgdGhlIGdlbmVyYXRlZCBjb2RlXG4gKiBAcGFyYW0gYVJlbGF0aXZlUGF0aCBPcHRpb25hbC4gVGhlIHBhdGggdGhhdCByZWxhdGl2ZSBzb3VyY2VzIGluIHRoZVxuICogICAgICAgIFNvdXJjZU1hcENvbnN1bWVyIHNob3VsZCBiZSByZWxhdGl2ZSB0by5cbiAqL1xuU291cmNlTm9kZS5mcm9tU3RyaW5nV2l0aFNvdXJjZU1hcCA9XG4gIGZ1bmN0aW9uIFNvdXJjZU5vZGVfZnJvbVN0cmluZ1dpdGhTb3VyY2VNYXAoYUdlbmVyYXRlZENvZGUsIGFTb3VyY2VNYXBDb25zdW1lciwgYVJlbGF0aXZlUGF0aCkge1xuICAgIC8vIFRoZSBTb3VyY2VOb2RlIHdlIHdhbnQgdG8gZmlsbCB3aXRoIHRoZSBnZW5lcmF0ZWQgY29kZVxuICAgIC8vIGFuZCB0aGUgU291cmNlTWFwXG4gICAgdmFyIG5vZGUgPSBuZXcgU291cmNlTm9kZSgpO1xuXG4gICAgLy8gQWxsIGV2ZW4gaW5kaWNlcyBvZiB0aGlzIGFycmF5IGFyZSBvbmUgbGluZSBvZiB0aGUgZ2VuZXJhdGVkIGNvZGUsXG4gICAgLy8gd2hpbGUgYWxsIG9kZCBpbmRpY2VzIGFyZSB0aGUgbmV3bGluZXMgYmV0d2VlbiB0d28gYWRqYWNlbnQgbGluZXNcbiAgICAvLyAoc2luY2UgYFJFR0VYX05FV0xJTkVgIGNhcHR1cmVzIGl0cyBtYXRjaCkuXG4gICAgLy8gUHJvY2Vzc2VkIGZyYWdtZW50cyBhcmUgYWNjZXNzZWQgYnkgY2FsbGluZyBgc2hpZnROZXh0TGluZWAuXG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzID0gYUdlbmVyYXRlZENvZGUuc3BsaXQoUkVHRVhfTkVXTElORSk7XG4gICAgdmFyIHJlbWFpbmluZ0xpbmVzSW5kZXggPSAwO1xuICAgIHZhciBzaGlmdE5leHRMaW5lID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGluZUNvbnRlbnRzID0gZ2V0TmV4dExpbmUoKTtcbiAgICAgIC8vIFRoZSBsYXN0IGxpbmUgb2YgYSBmaWxlIG1pZ2h0IG5vdCBoYXZlIGEgbmV3bGluZS5cbiAgICAgIHZhciBuZXdMaW5lID0gZ2V0TmV4dExpbmUoKSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIGxpbmVDb250ZW50cyArIG5ld0xpbmU7XG5cbiAgICAgIGZ1bmN0aW9uIGdldE5leHRMaW5lKCkge1xuICAgICAgICByZXR1cm4gcmVtYWluaW5nTGluZXNJbmRleCA8IHJlbWFpbmluZ0xpbmVzLmxlbmd0aCA/XG4gICAgICAgICAgICByZW1haW5pbmdMaW5lc1tyZW1haW5pbmdMaW5lc0luZGV4KytdIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBXZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwb3NpdGlvbiBvZiBcInJlbWFpbmluZ0xpbmVzXCJcbiAgICB2YXIgbGFzdEdlbmVyYXRlZExpbmUgPSAxLCBsYXN0R2VuZXJhdGVkQ29sdW1uID0gMDtcblxuICAgIC8vIFRoZSBnZW5lcmF0ZSBTb3VyY2VOb2RlcyB3ZSBuZWVkIGEgY29kZSByYW5nZS5cbiAgICAvLyBUbyBleHRyYWN0IGl0IGN1cnJlbnQgYW5kIGxhc3QgbWFwcGluZyBpcyB1c2VkLlxuICAgIC8vIEhlcmUgd2Ugc3RvcmUgdGhlIGxhc3QgbWFwcGluZy5cbiAgICB2YXIgbGFzdE1hcHBpbmcgPSBudWxsO1xuXG4gICAgYVNvdXJjZU1hcENvbnN1bWVyLmVhY2hNYXBwaW5nKGZ1bmN0aW9uIChtYXBwaW5nKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UgYWRkIHRoZSBjb2RlIGZyb20gXCJsYXN0TWFwcGluZ1wiIHRvIFwibWFwcGluZ1wiOlxuICAgICAgICAvLyBGaXJzdCBjaGVjayBpZiB0aGVyZSBpcyBhIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgIGlmIChsYXN0R2VuZXJhdGVkTGluZSA8IG1hcHBpbmcuZ2VuZXJhdGVkTGluZSkge1xuICAgICAgICAgIC8vIEFzc29jaWF0ZSBmaXJzdCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBzaGlmdE5leHRMaW5lKCkpO1xuICAgICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICAgICAgbGFzdEdlbmVyYXRlZENvbHVtbiA9IDA7XG4gICAgICAgICAgLy8gVGhlIHJlbWFpbmluZyBjb2RlIGlzIGFkZGVkIHdpdGhvdXQgbWFwcGluZ1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5ldyBsaW5lIGluIGJldHdlZW4uXG4gICAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSBjb2RlIGJldHdlZW4gXCJsYXN0R2VuZXJhdGVkQ29sdW1uXCIgYW5kXG4gICAgICAgICAgLy8gXCJtYXBwaW5nLmdlbmVyYXRlZENvbHVtblwiIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgICAgdmFyIG5leHRMaW5lID0gcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gfHwgJyc7XG4gICAgICAgICAgdmFyIGNvZGUgPSBuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4gLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RHZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICAgIHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdID0gbmV4dExpbmUuc3Vic3RyKG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uKTtcbiAgICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICAgICAgYWRkTWFwcGluZ1dpdGhDb2RlKGxhc3RNYXBwaW5nLCBjb2RlKTtcbiAgICAgICAgICAvLyBObyBtb3JlIHJlbWFpbmluZyBjb2RlLCBjb250aW51ZVxuICAgICAgICAgIGxhc3RNYXBwaW5nID0gbWFwcGluZztcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlIGFkZCB0aGUgZ2VuZXJhdGVkIGNvZGUgdW50aWwgdGhlIGZpcnN0IG1hcHBpbmdcbiAgICAgIC8vIHRvIHRoZSBTb3VyY2VOb2RlIHdpdGhvdXQgYW55IG1hcHBpbmcuXG4gICAgICAvLyBFYWNoIGxpbmUgaXMgYWRkZWQgYXMgc2VwYXJhdGUgc3RyaW5nLlxuICAgICAgd2hpbGUgKGxhc3RHZW5lcmF0ZWRMaW5lIDwgbWFwcGluZy5nZW5lcmF0ZWRMaW5lKSB7XG4gICAgICAgIG5vZGUuYWRkKHNoaWZ0TmV4dExpbmUoKSk7XG4gICAgICAgIGxhc3RHZW5lcmF0ZWRMaW5lKys7XG4gICAgICB9XG4gICAgICBpZiAobGFzdEdlbmVyYXRlZENvbHVtbiA8IG1hcHBpbmcuZ2VuZXJhdGVkQ29sdW1uKSB7XG4gICAgICAgIHZhciBuZXh0TGluZSA9IHJlbWFpbmluZ0xpbmVzW3JlbWFpbmluZ0xpbmVzSW5kZXhdIHx8ICcnO1xuICAgICAgICBub2RlLmFkZChuZXh0TGluZS5zdWJzdHIoMCwgbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pKTtcbiAgICAgICAgcmVtYWluaW5nTGluZXNbcmVtYWluaW5nTGluZXNJbmRleF0gPSBuZXh0TGluZS5zdWJzdHIobWFwcGluZy5nZW5lcmF0ZWRDb2x1bW4pO1xuICAgICAgICBsYXN0R2VuZXJhdGVkQ29sdW1uID0gbWFwcGluZy5nZW5lcmF0ZWRDb2x1bW47XG4gICAgICB9XG4gICAgICBsYXN0TWFwcGluZyA9IG1hcHBpbmc7XG4gICAgfSwgdGhpcyk7XG4gICAgLy8gV2UgaGF2ZSBwcm9jZXNzZWQgYWxsIG1hcHBpbmdzLlxuICAgIGlmIChyZW1haW5pbmdMaW5lc0luZGV4IDwgcmVtYWluaW5nTGluZXMubGVuZ3RoKSB7XG4gICAgICBpZiAobGFzdE1hcHBpbmcpIHtcbiAgICAgICAgLy8gQXNzb2NpYXRlIHRoZSByZW1haW5pbmcgY29kZSBpbiB0aGUgY3VycmVudCBsaW5lIHdpdGggXCJsYXN0TWFwcGluZ1wiXG4gICAgICAgIGFkZE1hcHBpbmdXaXRoQ29kZShsYXN0TWFwcGluZywgc2hpZnROZXh0TGluZSgpKTtcbiAgICAgIH1cbiAgICAgIC8vIGFuZCBhZGQgdGhlIHJlbWFpbmluZyBsaW5lcyB3aXRob3V0IGFueSBtYXBwaW5nXG4gICAgICBub2RlLmFkZChyZW1haW5pbmdMaW5lcy5zcGxpY2UocmVtYWluaW5nTGluZXNJbmRleCkuam9pbihcIlwiKSk7XG4gICAgfVxuXG4gICAgLy8gQ29weSBzb3VyY2VzQ29udGVudCBpbnRvIFNvdXJjZU5vZGVcbiAgICBhU291cmNlTWFwQ29uc3VtZXIuc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChzb3VyY2VGaWxlKSB7XG4gICAgICB2YXIgY29udGVudCA9IGFTb3VyY2VNYXBDb25zdW1lci5zb3VyY2VDb250ZW50Rm9yKHNvdXJjZUZpbGUpO1xuICAgICAgaWYgKGNvbnRlbnQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoYVJlbGF0aXZlUGF0aCAhPSBudWxsKSB7XG4gICAgICAgICAgc291cmNlRmlsZSA9IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBzb3VyY2VGaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLnNldFNvdXJjZUNvbnRlbnQoc291cmNlRmlsZSwgY29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbm9kZTtcblxuICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdXaXRoQ29kZShtYXBwaW5nLCBjb2RlKSB7XG4gICAgICBpZiAobWFwcGluZyA9PT0gbnVsbCB8fCBtYXBwaW5nLnNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuYWRkKGNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFSZWxhdGl2ZVBhdGhcbiAgICAgICAgICA/IHV0aWwuam9pbihhUmVsYXRpdmVQYXRoLCBtYXBwaW5nLnNvdXJjZSlcbiAgICAgICAgICA6IG1hcHBpbmcuc291cmNlO1xuICAgICAgICBub2RlLmFkZChuZXcgU291cmNlTm9kZShtYXBwaW5nLm9yaWdpbmFsTGluZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFwcGluZy5vcmlnaW5hbENvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXBwaW5nLm5hbWUpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoaXMgc291cmNlIG5vZGUuXG4gKlxuICogQHBhcmFtIGFDaHVuayBBIHN0cmluZyBzbmlwcGV0IG9mIGdlbmVyYXRlZCBKUyBjb2RlLCBhbm90aGVyIGluc3RhbmNlIG9mXG4gKiAgICAgICAgU291cmNlTm9kZSwgb3IgYW4gYXJyYXkgd2hlcmUgZWFjaCBtZW1iZXIgaXMgb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gU291cmNlTm9kZV9hZGQoYUNodW5rKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFDaHVuaykpIHtcbiAgICBhQ2h1bmsuZm9yRWFjaChmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgIHRoaXMuYWRkKGNodW5rKTtcbiAgICB9LCB0aGlzKTtcbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGFDaHVuaykge1xuICAgICAgdGhpcy5jaGlsZHJlbi5wdXNoKGFDaHVuayk7XG4gICAgfVxuICB9XG4gIGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICBcIkV4cGVjdGVkIGEgU291cmNlTm9kZSwgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBTb3VyY2VOb2RlcyBhbmQgc3RyaW5ncy4gR290IFwiICsgYUNodW5rXG4gICAgKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkIGEgY2h1bmsgb2YgZ2VuZXJhdGVkIEpTIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhpcyBzb3VyY2Ugbm9kZS5cbiAqXG4gKiBAcGFyYW0gYUNodW5rIEEgc3RyaW5nIHNuaXBwZXQgb2YgZ2VuZXJhdGVkIEpTIGNvZGUsIGFub3RoZXIgaW5zdGFuY2Ugb2ZcbiAqICAgICAgICBTb3VyY2VOb2RlLCBvciBhbiBhcnJheSB3aGVyZSBlYWNoIG1lbWJlciBpcyBvbmUgb2YgdGhvc2UgdGhpbmdzLlxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gU291cmNlTm9kZV9wcmVwZW5kKGFDaHVuaykge1xuICBpZiAoQXJyYXkuaXNBcnJheShhQ2h1bmspKSB7XG4gICAgZm9yICh2YXIgaSA9IGFDaHVuay5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHRoaXMucHJlcGVuZChhQ2h1bmtbaV0pO1xuICAgIH1cbiAgfVxuICBlbHNlIGlmIChhQ2h1bmtbaXNTb3VyY2VOb2RlXSB8fCB0eXBlb2YgYUNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhpcy5jaGlsZHJlbi51bnNoaWZ0KGFDaHVuayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIFwiRXhwZWN0ZWQgYSBTb3VyY2VOb2RlLCBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIFNvdXJjZU5vZGVzIGFuZCBzdHJpbmdzLiBHb3QgXCIgKyBhQ2h1bmtcbiAgICApO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXYWxrIG92ZXIgdGhlIHRyZWUgb2YgSlMgc25pcHBldHMgaW4gdGhpcyBub2RlIGFuZCBpdHMgY2hpbGRyZW4uIFRoZVxuICogd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgb25jZSBmb3IgZWFjaCBzbmlwcGV0IG9mIEpTIGFuZCBpcyBwYXNzZWQgdGhhdFxuICogc25pcHBldCBhbmQgdGhlIGl0cyBvcmlnaW5hbCBhc3NvY2lhdGVkIHNvdXJjZSdzIGxpbmUvY29sdW1uIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfd2FsayhhRm4pIHtcbiAgdmFyIGNodW5rO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNodW5rID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICBpZiAoY2h1bmtbaXNTb3VyY2VOb2RlXSkge1xuICAgICAgY2h1bmsud2FsayhhRm4pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGlmIChjaHVuayAhPT0gJycpIHtcbiAgICAgICAgYUZuKGNodW5rLCB7IHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLmxpbmUsXG4gICAgICAgICAgICAgICAgICAgICBjb2x1bW46IHRoaXMuY29sdW1uLFxuICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBMaWtlIGBTdHJpbmcucHJvdG90eXBlLmpvaW5gIGV4Y2VwdCBmb3IgU291cmNlTm9kZXMuIEluc2VydHMgYGFTdHJgIGJldHdlZW5cbiAqIGVhY2ggb2YgYHRoaXMuY2hpbGRyZW5gLlxuICpcbiAqIEBwYXJhbSBhU2VwIFRoZSBzZXBhcmF0b3IuXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLmpvaW4gPSBmdW5jdGlvbiBTb3VyY2VOb2RlX2pvaW4oYVNlcCkge1xuICB2YXIgbmV3Q2hpbGRyZW47XG4gIHZhciBpO1xuICB2YXIgbGVuID0gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gIGlmIChsZW4gPiAwKSB7XG4gICAgbmV3Q2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuLTE7IGkrKykge1xuICAgICAgbmV3Q2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkcmVuW2ldKTtcbiAgICAgIG5ld0NoaWxkcmVuLnB1c2goYVNlcCk7XG4gICAgfVxuICAgIG5ld0NoaWxkcmVuLnB1c2godGhpcy5jaGlsZHJlbltpXSk7XG4gICAgdGhpcy5jaGlsZHJlbiA9IG5ld0NoaWxkcmVuO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYWxsIFN0cmluZy5wcm90b3R5cGUucmVwbGFjZSBvbiB0aGUgdmVyeSByaWdodC1tb3N0IHNvdXJjZSBzbmlwcGV0LiBVc2VmdWxcbiAqIGZvciB0cmltbWluZyB3aGl0ZXNwYWNlIGZyb20gdGhlIGVuZCBvZiBhIHNvdXJjZSBub2RlLCBldGMuXG4gKlxuICogQHBhcmFtIGFQYXR0ZXJuIFRoZSBwYXR0ZXJuIHRvIHJlcGxhY2UuXG4gKiBAcGFyYW0gYVJlcGxhY2VtZW50IFRoZSB0aGluZyB0byByZXBsYWNlIHRoZSBwYXR0ZXJuIHdpdGguXG4gKi9cblNvdXJjZU5vZGUucHJvdG90eXBlLnJlcGxhY2VSaWdodCA9IGZ1bmN0aW9uIFNvdXJjZU5vZGVfcmVwbGFjZVJpZ2h0KGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpIHtcbiAgdmFyIGxhc3RDaGlsZCA9IHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgaWYgKGxhc3RDaGlsZFtpc1NvdXJjZU5vZGVdKSB7XG4gICAgbGFzdENoaWxkLnJlcGxhY2VSaWdodChhUGF0dGVybiwgYVJlcGxhY2VtZW50KTtcbiAgfVxuICBlbHNlIGlmICh0eXBlb2YgbGFzdENoaWxkID09PSAnc3RyaW5nJykge1xuICAgIHRoaXMuY2hpbGRyZW5bdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxXSA9IGxhc3RDaGlsZC5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHRoaXMuY2hpbGRyZW4ucHVzaCgnJy5yZXBsYWNlKGFQYXR0ZXJuLCBhUmVwbGFjZW1lbnQpKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBzb3VyY2UgY29udGVudCBmb3IgYSBzb3VyY2UgZmlsZS4gVGhpcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBTb3VyY2VNYXBHZW5lcmF0b3JcbiAqIGluIHRoZSBzb3VyY2VzQ29udGVudCBmaWVsZC5cbiAqXG4gKiBAcGFyYW0gYVNvdXJjZUZpbGUgVGhlIGZpbGVuYW1lIG9mIHRoZSBzb3VyY2UgZmlsZVxuICogQHBhcmFtIGFTb3VyY2VDb250ZW50IFRoZSBjb250ZW50IG9mIHRoZSBzb3VyY2UgZmlsZVxuICovXG5Tb3VyY2VOb2RlLnByb3RvdHlwZS5zZXRTb3VyY2VDb250ZW50ID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV9zZXRTb3VyY2VDb250ZW50KGFTb3VyY2VGaWxlLCBhU291cmNlQ29udGVudCkge1xuICAgIHRoaXMuc291cmNlQ29udGVudHNbdXRpbC50b1NldFN0cmluZyhhU291cmNlRmlsZSldID0gYVNvdXJjZUNvbnRlbnQ7XG4gIH07XG5cbi8qKlxuICogV2FsayBvdmVyIHRoZSB0cmVlIG9mIFNvdXJjZU5vZGVzLiBUaGUgd2Fsa2luZyBmdW5jdGlvbiBpcyBjYWxsZWQgZm9yIGVhY2hcbiAqIHNvdXJjZSBmaWxlIGNvbnRlbnQgYW5kIGlzIHBhc3NlZCB0aGUgZmlsZW5hbWUgYW5kIHNvdXJjZSBjb250ZW50LlxuICpcbiAqIEBwYXJhbSBhRm4gVGhlIHRyYXZlcnNhbCBmdW5jdGlvbi5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUud2Fsa1NvdXJjZUNvbnRlbnRzID1cbiAgZnVuY3Rpb24gU291cmNlTm9kZV93YWxrU291cmNlQ29udGVudHMoYUZuKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldW2lzU291cmNlTm9kZV0pIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbltpXS53YWxrU291cmNlQ29udGVudHMoYUZuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc291cmNlcyA9IE9iamVjdC5rZXlzKHRoaXMuc291cmNlQ29udGVudHMpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhRm4odXRpbC5mcm9tU2V0U3RyaW5nKHNvdXJjZXNbaV0pLCB0aGlzLnNvdXJjZUNvbnRlbnRzW3NvdXJjZXNbaV1dKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBzb3VyY2Ugbm9kZS4gV2Fsa3Mgb3ZlciB0aGUgdHJlZVxuICogYW5kIGNvbmNhdGVuYXRlcyBhbGwgdGhlIHZhcmlvdXMgc25pcHBldHMgdG9nZXRoZXIgdG8gb25lIHN0cmluZy5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiBTb3VyY2VOb2RlX3RvU3RyaW5nKCkge1xuICB2YXIgc3RyID0gXCJcIjtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHN0ciArPSBjaHVuaztcbiAgfSk7XG4gIHJldHVybiBzdHI7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHNvdXJjZSBub2RlIGFsb25nIHdpdGggYSBzb3VyY2VcbiAqIG1hcC5cbiAqL1xuU291cmNlTm9kZS5wcm90b3R5cGUudG9TdHJpbmdXaXRoU291cmNlTWFwID0gZnVuY3Rpb24gU291cmNlTm9kZV90b1N0cmluZ1dpdGhTb3VyY2VNYXAoYUFyZ3MpIHtcbiAgdmFyIGdlbmVyYXRlZCA9IHtcbiAgICBjb2RlOiBcIlwiLFxuICAgIGxpbmU6IDEsXG4gICAgY29sdW1uOiAwXG4gIH07XG4gIHZhciBtYXAgPSBuZXcgU291cmNlTWFwR2VuZXJhdG9yKGFBcmdzKTtcbiAgdmFyIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgdmFyIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxMaW5lID0gbnVsbDtcbiAgdmFyIGxhc3RPcmlnaW5hbENvbHVtbiA9IG51bGw7XG4gIHZhciBsYXN0T3JpZ2luYWxOYW1lID0gbnVsbDtcbiAgdGhpcy53YWxrKGZ1bmN0aW9uIChjaHVuaywgb3JpZ2luYWwpIHtcbiAgICBnZW5lcmF0ZWQuY29kZSArPSBjaHVuaztcbiAgICBpZiAob3JpZ2luYWwuc291cmNlICE9PSBudWxsXG4gICAgICAgICYmIG9yaWdpbmFsLmxpbmUgIT09IG51bGxcbiAgICAgICAgJiYgb3JpZ2luYWwuY29sdW1uICE9PSBudWxsKSB7XG4gICAgICBpZihsYXN0T3JpZ2luYWxTb3VyY2UgIT09IG9yaWdpbmFsLnNvdXJjZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsTGluZSAhPT0gb3JpZ2luYWwubGluZVxuICAgICAgICAgfHwgbGFzdE9yaWdpbmFsQ29sdW1uICE9PSBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgIHx8IGxhc3RPcmlnaW5hbE5hbWUgIT09IG9yaWdpbmFsLm5hbWUpIHtcbiAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgIHNvdXJjZTogb3JpZ2luYWwuc291cmNlLFxuICAgICAgICAgIG9yaWdpbmFsOiB7XG4gICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgY29sdW1uOiBvcmlnaW5hbC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgbGluZTogZ2VuZXJhdGVkLmxpbmUsXG4gICAgICAgICAgICBjb2x1bW46IGdlbmVyYXRlZC5jb2x1bW5cbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hbWU6IG9yaWdpbmFsLm5hbWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBvcmlnaW5hbC5zb3VyY2U7XG4gICAgICBsYXN0T3JpZ2luYWxMaW5lID0gb3JpZ2luYWwubGluZTtcbiAgICAgIGxhc3RPcmlnaW5hbENvbHVtbiA9IG9yaWdpbmFsLmNvbHVtbjtcbiAgICAgIGxhc3RPcmlnaW5hbE5hbWUgPSBvcmlnaW5hbC5uYW1lO1xuICAgICAgc291cmNlTWFwcGluZ0FjdGl2ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICBtYXAuYWRkTWFwcGluZyh7XG4gICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgIGxpbmU6IGdlbmVyYXRlZC5saW5lLFxuICAgICAgICAgIGNvbHVtbjogZ2VuZXJhdGVkLmNvbHVtblxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxhc3RPcmlnaW5hbFNvdXJjZSA9IG51bGw7XG4gICAgICBzb3VyY2VNYXBwaW5nQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIGZvciAodmFyIGlkeCA9IDAsIGxlbmd0aCA9IGNodW5rLmxlbmd0aDsgaWR4IDwgbGVuZ3RoOyBpZHgrKykge1xuICAgICAgaWYgKGNodW5rLmNoYXJDb2RlQXQoaWR4KSA9PT0gTkVXTElORV9DT0RFKSB7XG4gICAgICAgIGdlbmVyYXRlZC5saW5lKys7XG4gICAgICAgIGdlbmVyYXRlZC5jb2x1bW4gPSAwO1xuICAgICAgICAvLyBNYXBwaW5ncyBlbmQgYXQgZW9sXG4gICAgICAgIGlmIChpZHggKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICBsYXN0T3JpZ2luYWxTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHNvdXJjZU1hcHBpbmdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VNYXBwaW5nQWN0aXZlKSB7XG4gICAgICAgICAgbWFwLmFkZE1hcHBpbmcoe1xuICAgICAgICAgICAgc291cmNlOiBvcmlnaW5hbC5zb3VyY2UsXG4gICAgICAgICAgICBvcmlnaW5hbDoge1xuICAgICAgICAgICAgICBsaW5lOiBvcmlnaW5hbC5saW5lLFxuICAgICAgICAgICAgICBjb2x1bW46IG9yaWdpbmFsLmNvbHVtblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdlbmVyYXRlZDoge1xuICAgICAgICAgICAgICBsaW5lOiBnZW5lcmF0ZWQubGluZSxcbiAgICAgICAgICAgICAgY29sdW1uOiBnZW5lcmF0ZWQuY29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmFtZTogb3JpZ2luYWwubmFtZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW5lcmF0ZWQuY29sdW1uKys7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgdGhpcy53YWxrU291cmNlQ29udGVudHMoZnVuY3Rpb24gKHNvdXJjZUZpbGUsIHNvdXJjZUNvbnRlbnQpIHtcbiAgICBtYXAuc2V0U291cmNlQ29udGVudChzb3VyY2VGaWxlLCBzb3VyY2VDb250ZW50KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgY29kZTogZ2VuZXJhdGVkLmNvZGUsIG1hcDogbWFwIH07XG59O1xuXG5leHBvcnRzLlNvdXJjZU5vZGUgPSBTb3VyY2VOb2RlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9saWIvc291cmNlLW5vZGUuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=</span></pre>
</body>
</html>