<html>
<head>
<title>source-map.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cfd2d5;}
.s1 { color: #cc7832; font-weight: bold;}
.s2 { color: #cc7832;}
.s3 { color: #8ea765;}
.s4 { color: #8a8a8a;}
.s5 { color: #808080;}
.s6 { color: #6897bb;}
.s7 { color: #8a8a8a; font-style: italic;}
.s8 { color: #8a8a8a; font-weight: bold; font-style: italic;}
</style>
</head>
<body bgcolor="#1c1c1c">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
source-map.js</font>
</center></td></tr></table>
<pre><span class="s0">(</span><span class="s1">function </span><span class="s0">webpackUniversalModuleDefinition(root</span><span class="s2">, </span><span class="s0">factory) {</span>
	<span class="s1">if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s3">'object' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">module === </span><span class="s3">'object'</span><span class="s0">)</span>
		<span class="s0">module.exports = factory()</span><span class="s2">;</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">define === </span><span class="s3">'function' </span><span class="s0">&amp;&amp; define.amd)</span>
		<span class="s0">define([]</span><span class="s2">, </span><span class="s0">factory)</span><span class="s2">;</span>
	<span class="s1">else if</span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">exports === </span><span class="s3">'object'</span><span class="s0">)</span>
		<span class="s0">exports[</span><span class="s3">&quot;sourceMap&quot;</span><span class="s0">] = factory()</span><span class="s2">;</span>
	<span class="s1">else</span>
		<span class="s0">root[</span><span class="s3">&quot;sourceMap&quot;</span><span class="s0">] = factory()</span><span class="s2">;</span>
<span class="s0">})(</span><span class="s1">this</span><span class="s2">, </span><span class="s1">function</span><span class="s0">() {</span>
<span class="s1">return </span><span class="s4">/******/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(modules) { </span><span class="s5">// webpackBootstrap</span>
<span class="s4">/******/ 	</span><span class="s5">// The module cache</span>
<span class="s4">/******/ 	</span><span class="s1">var </span><span class="s0">installedModules = {}</span><span class="s2">;</span>

<span class="s4">/******/ 	</span><span class="s5">// The require function</span>
<span class="s4">/******/ 	</span><span class="s1">function </span><span class="s0">__webpack_require__(moduleId) {</span>

<span class="s4">/******/ 		</span><span class="s5">// Check if module is in cache</span>
<span class="s4">/******/ 		</span><span class="s1">if</span><span class="s0">(installedModules[moduleId])</span>
<span class="s4">/******/ 			</span><span class="s1">return </span><span class="s0">installedModules[moduleId].exports</span><span class="s2">;</span>

<span class="s4">/******/ 		</span><span class="s5">// Create a new module (and put it into the cache)</span>
<span class="s4">/******/ 		</span><span class="s1">var </span><span class="s0">module = installedModules[moduleId] = {</span>
<span class="s4">/******/ 			</span><span class="s0">exports: {}</span><span class="s2">,</span>
<span class="s4">/******/ 			</span><span class="s0">id: moduleId</span><span class="s2">,</span>
<span class="s4">/******/ 			</span><span class="s0">loaded: </span><span class="s1">false</span>
<span class="s4">/******/ 		</span><span class="s0">}</span><span class="s2">;</span>

<span class="s4">/******/ 		</span><span class="s5">// Execute the module function</span>
<span class="s4">/******/ 		</span><span class="s0">modules[moduleId].call(module.exports</span><span class="s2">, </span><span class="s0">module</span><span class="s2">, </span><span class="s0">module.exports</span><span class="s2">, </span><span class="s0">__webpack_require__)</span><span class="s2">;</span>

<span class="s4">/******/ 		</span><span class="s5">// Flag the module as loaded</span>
<span class="s4">/******/ 		</span><span class="s0">module.loaded = </span><span class="s1">true</span><span class="s2">;</span>

<span class="s4">/******/ 		</span><span class="s5">// Return the exports of the module</span>
<span class="s4">/******/ 		</span><span class="s1">return </span><span class="s0">module.exports</span><span class="s2">;</span>
<span class="s4">/******/ 	</span><span class="s0">}</span>


<span class="s4">/******/ 	</span><span class="s5">// expose the modules object (__webpack_modules__)</span>
<span class="s4">/******/ 	</span><span class="s0">__webpack_require__.m = modules</span><span class="s2">;</span>

<span class="s4">/******/ 	</span><span class="s5">// expose the module cache</span>
<span class="s4">/******/ 	</span><span class="s0">__webpack_require__.c = installedModules</span><span class="s2">;</span>

<span class="s4">/******/ 	</span><span class="s5">// __webpack_public_path__</span>
<span class="s4">/******/ 	</span><span class="s0">__webpack_require__.p = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>

<span class="s4">/******/ 	</span><span class="s5">// Load entry module and return exports</span>
<span class="s4">/******/ 	</span><span class="s1">return </span><span class="s0">__webpack_require__(</span><span class="s6">0</span><span class="s0">)</span><span class="s2">;</span>
<span class="s4">/******/ </span><span class="s0">})</span>
<span class="s4">/************************************************************************/</span>
<span class="s4">/******/ </span><span class="s0">([</span>
<span class="s4">/* 0 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* 
     * Copyright 2009-2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE.txt or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>
	<span class="s0">exports.SourceMapGenerator = __webpack_require__(</span><span class="s6">1</span><span class="s0">).SourceMapGenerator</span><span class="s2">;</span>
	<span class="s0">exports.SourceMapConsumer = __webpack_require__(</span><span class="s6">7</span><span class="s0">).SourceMapConsumer</span><span class="s2">;</span>
	<span class="s0">exports.SourceNode = __webpack_require__(</span><span class="s6">10</span><span class="s0">).SourceNode</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 1 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s1">var </span><span class="s0">base64VLQ = __webpack_require__(</span><span class="s6">2</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">ArraySet = __webpack_require__(</span><span class="s6">5</span><span class="s0">).ArraySet</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">MappingList = __webpack_require__(</span><span class="s6">6</span><span class="s0">).MappingList</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* An instance of the SourceMapGenerator represents a source map which is</span>
	 <span class="s7">* being built incrementally. You may pass an object with the following</span>
	 <span class="s7">* properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - file: The filename of the generated source.</span>
	 <span class="s7">*   - sourceRoot: A root for all relative URLs in this source map.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">SourceMapGenerator(aArgs) {</span>
	  <span class="s1">if </span><span class="s0">(!aArgs) {</span>
	    <span class="s0">aArgs = {}</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">this</span><span class="s0">._file = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'file'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sourceRoot = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'sourceRoot'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._skipValidation = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'skipValidation'</span><span class="s2">, </span><span class="s1">false</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sources = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._names = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._mappings = </span><span class="s1">new </span><span class="s0">MappingList()</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sourcesContents = </span><span class="s1">null</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s0">SourceMapGenerator.prototype._version = </span><span class="s6">3</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Creates a new SourceMapGenerator based on a SourceMapConsumer</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceMapConsumer The SourceMap.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.fromSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {</span>
	    <span class="s1">var </span><span class="s0">sourceRoot = aSourceMapConsumer.sourceRoot</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">generator = </span><span class="s1">new </span><span class="s0">SourceMapGenerator({</span>
	      <span class="s0">file: aSourceMapConsumer.file</span><span class="s2">,</span>
	      <span class="s0">sourceRoot: sourceRoot</span>
	    <span class="s0">})</span><span class="s2">;</span>
	    <span class="s0">aSourceMapConsumer.eachMapping(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">var </span><span class="s0">newMapping = {</span>
	        <span class="s0">generated: {</span>
	          <span class="s0">line: mapping.generatedLine</span><span class="s2">,</span>
	          <span class="s0">column: mapping.generatedColumn</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span><span class="s2">;</span>

	      <span class="s1">if </span><span class="s0">(mapping.source != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">newMapping.source = mapping.source</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">newMapping.source = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">newMapping.source)</span><span class="s2">;</span>
	        <span class="s0">}</span>

	        <span class="s0">newMapping.original = {</span>
	          <span class="s0">line: mapping.originalLine</span><span class="s2">,</span>
	          <span class="s0">column: mapping.originalColumn</span>
	        <span class="s0">}</span><span class="s2">;</span>

	        <span class="s1">if </span><span class="s0">(mapping.name != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">newMapping.name = mapping.name</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>

	      <span class="s0">generator.addMapping(newMapping)</span><span class="s2">;</span>
	    <span class="s0">})</span><span class="s2">;</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">sourceRelative = sourceFile</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(sourceRoot !== </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">sourceRelative = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	      <span class="s0">}</span>

	      <span class="s1">if </span><span class="s0">(!generator._sources.has(sourceRelative)) {</span>
	        <span class="s0">generator._sources.add(sourceRelative)</span><span class="s2">;</span>
	      <span class="s0">}</span>

	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">generator.setSourceContent(sourceFile</span><span class="s2">, </span><span class="s0">content)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">})</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">generator</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Add a single mapping from original source line and column to the generated</span>
	 <span class="s7">* source's line and column for this source map being created. The mapping</span>
	 <span class="s7">* object should have the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - generated: An object with the generated line and column positions.</span>
	 <span class="s7">*   - original: An object with the original line and column positions.</span>
	 <span class="s7">*   - source: The original source file (relative to the sourceRoot).</span>
	 <span class="s7">*   - name: An optional original token name for this mapping.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.addMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_addMapping(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">generated = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'generated'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">original = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'original'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">source = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'source'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">name = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'name'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>

	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._skipValidation) {</span>
	      <span class="s1">this</span><span class="s0">._validateMapping(generated</span><span class="s2">, </span><span class="s0">original</span><span class="s2">, </span><span class="s0">source</span><span class="s2">, </span><span class="s0">name)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(source != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">source = String(source)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sources.has(source)) {</span>
	        <span class="s1">this</span><span class="s0">._sources.add(source)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(name != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">name = String(name)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._names.has(name)) {</span>
	        <span class="s1">this</span><span class="s0">._names.add(name)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s1">this</span><span class="s0">._mappings.add({</span>
	      <span class="s0">generatedLine: generated.line</span><span class="s2">,</span>
	      <span class="s0">generatedColumn: generated.column</span><span class="s2">,</span>
	      <span class="s0">originalLine: original != </span><span class="s1">null </span><span class="s0">&amp;&amp; original.line</span><span class="s2">,</span>
	      <span class="s0">originalColumn: original != </span><span class="s1">null </span><span class="s0">&amp;&amp; original.column</span><span class="s2">,</span>
	      <span class="s0">source: source</span><span class="s2">,</span>
	      <span class="s0">name: name</span>
	    <span class="s0">})</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Set the source content for a source file.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.setSourceContent =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_setSourceContent(aSourceFile</span><span class="s2">, </span><span class="s0">aSourceContent) {</span>
	    <span class="s1">var </span><span class="s0">source = aSourceFile</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">source = util.relative(</span><span class="s1">this</span><span class="s0">._sourceRoot</span><span class="s2">, </span><span class="s0">source)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(aSourceContent != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s5">// Add the source content to the _sourcesContents map.</span>
	      <span class="s5">// Create a new _sourcesContents map if the property is null.</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	        <span class="s1">this</span><span class="s0">._sourcesContents = Object.create(</span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">this</span><span class="s0">._sourcesContents[util.toSetString(source)] = aSourceContent</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	      <span class="s5">// Remove the source file from the _sourcesContents map.</span>
	      <span class="s5">// If the _sourcesContents map is empty, set the property to null.</span>
	      <span class="s1">delete this</span><span class="s0">._sourcesContents[util.toSetString(source)]</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(Object.keys(</span><span class="s1">this</span><span class="s0">._sourcesContents).length === </span><span class="s6">0</span><span class="s0">) {</span>
	        <span class="s1">this</span><span class="s0">._sourcesContents = </span><span class="s1">null</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Applies the mappings of a sub-source-map for a specific source file to the</span>
	 <span class="s7">* source map being generated. Each mapping to the supplied source file is</span>
	 <span class="s7">* rewritten using the supplied source map. Note: The resolution for the</span>
	 <span class="s7">* resulting mappings is the minimium of this map and the supplied map.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceMapConsumer The source map to be applied.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceFile Optional. The filename of the source file.</span>
	 <span class="s7">*        If omitted, SourceMapConsumer's file property will be used.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceMapPath Optional. The dirname of the path to the source map</span>
	 <span class="s7">*        to be applied. If relative, it is relative to the SourceMapConsumer.</span>
	 <span class="s7">*        This parameter is needed when the two source maps aren't in the same</span>
	 <span class="s7">*        directory, and the source map to be applied contains relative source</span>
	 <span class="s7">*        paths. If so, those relative source paths need to be rewritten</span>
	 <span class="s7">*        relative to the SourceMapGenerator.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.applySourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_applySourceMap(aSourceMapConsumer</span><span class="s2">, </span><span class="s0">aSourceFile</span><span class="s2">, </span><span class="s0">aSourceMapPath) {</span>
	    <span class="s1">var </span><span class="s0">sourceFile = aSourceFile</span><span class="s2">;</span>
	    <span class="s5">// If aSourceFile is omitted, we will use the file property of the SourceMap</span>
	    <span class="s1">if </span><span class="s0">(aSourceFile == </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(aSourceMapConsumer.file == </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">throw new </span><span class="s0">Error(</span>
	          <span class="s3">'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' </span><span class="s0">+</span>
	          <span class="s3">'or the source map</span><span class="s2">\'</span><span class="s3">s &quot;file&quot; property. Both were omitted.'</span>
	        <span class="s0">)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s0">sourceFile = aSourceMapConsumer.file</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">var </span><span class="s0">sourceRoot = </span><span class="s1">this</span><span class="s0">._sourceRoot</span><span class="s2">;</span>
	    <span class="s5">// Make &quot;sourceFile&quot; relative if an absolute Url is passed.</span>
	    <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">sourceFile = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s5">// Applying the SourceMap can add and remove items from the sources and</span>
	    <span class="s5">// the names array.</span>
	    <span class="s1">var </span><span class="s0">newSources = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">newNames = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>

	    <span class="s5">// Find mappings for the &quot;sourceFile&quot;</span>
	    <span class="s1">this</span><span class="s0">._mappings.unsortedForEach(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">if </span><span class="s0">(mapping.source === sourceFile &amp;&amp; mapping.originalLine != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s5">// Check if it can be mapped by the source map, then update the mapping.</span>
	        <span class="s1">var </span><span class="s0">original = aSourceMapConsumer.originalPositionFor({</span>
	          <span class="s0">line: mapping.originalLine</span><span class="s2">,</span>
	          <span class="s0">column: mapping.originalColumn</span>
	        <span class="s0">})</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(original.source != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s5">// Copy mapping</span>
	          <span class="s0">mapping.source = original.source</span><span class="s2">;</span>
	          <span class="s1">if </span><span class="s0">(aSourceMapPath != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.source = util.join(aSourceMapPath</span><span class="s2">, </span><span class="s0">mapping.source)</span>
	          <span class="s0">}</span>
	          <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.source = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">mapping.source)</span><span class="s2">;</span>
	          <span class="s0">}</span>
	          <span class="s0">mapping.originalLine = original.line</span><span class="s2">;</span>
	          <span class="s0">mapping.originalColumn = original.column</span><span class="s2">;</span>
	          <span class="s1">if </span><span class="s0">(original.name != </span><span class="s1">null</span><span class="s0">) {</span>
	            <span class="s0">mapping.name = original.name</span><span class="s2">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>

	      <span class="s1">var </span><span class="s0">source = mapping.source</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(source != </span><span class="s1">null </span><span class="s0">&amp;&amp; !newSources.has(source)) {</span>
	        <span class="s0">newSources.add(source)</span><span class="s2">;</span>
	      <span class="s0">}</span>

	      <span class="s1">var </span><span class="s0">name = mapping.name</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(name != </span><span class="s1">null </span><span class="s0">&amp;&amp; !newNames.has(name)) {</span>
	        <span class="s0">newNames.add(name)</span><span class="s2">;</span>
	      <span class="s0">}</span>

	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._sources = newSources</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._names = newNames</span><span class="s2">;</span>

	    <span class="s5">// Copy sourcesContents of applied map.</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(aSourceMapPath != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.join(aSourceMapPath</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s1">if </span><span class="s0">(sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s1">this</span><span class="s0">.setSourceContent(sourceFile</span><span class="s2">, </span><span class="s0">content)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* A mapping can have one of the three levels of data:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   1. Just the generated position.</span>
	 <span class="s7">*   2. The Generated position, original position, and original source.</span>
	 <span class="s7">*   3. Generated and original position, original source, as well as a name</span>
	 <span class="s7">*      token.</span>
	 <span class="s7">*</span>
	 <span class="s7">* To maintain consistency, we validate that any new mapping being added falls</span>
	 <span class="s7">* in to one of these categories.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype._validateMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_validateMapping(aGenerated</span><span class="s2">, </span><span class="s0">aOriginal</span><span class="s2">, </span><span class="s0">aSource</span><span class="s2">,</span>
	                                              <span class="s0">aName) {</span>
	    <span class="s5">// When aOriginal is truthy but has empty values for .line and .column,</span>
	    <span class="s5">// it is most likely a programmer error. In this case we throw a very</span>
	    <span class="s5">// specific error message to try to guide them the right way.</span>
	    <span class="s5">// For example: https://github.com/Polymer/polymer-bundler/pull/519</span>
	    <span class="s1">if </span><span class="s0">(aOriginal &amp;&amp; </span><span class="s1">typeof </span><span class="s0">aOriginal.line !== </span><span class="s3">'number' </span><span class="s0">&amp;&amp; </span><span class="s1">typeof </span><span class="s0">aOriginal.column !== </span><span class="s3">'number'</span><span class="s0">) {</span>
	        <span class="s1">throw new </span><span class="s0">Error(</span>
	            <span class="s3">'original.line and original.column are not numbers -- you probably meant to omit ' </span><span class="s0">+</span>
	            <span class="s3">'the original mapping entirely and only map the generated position. If so, pass ' </span><span class="s0">+</span>
	            <span class="s3">'null for the original mapping instead of an object with empty or null values.'</span>
	        <span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">if </span><span class="s0">(aGenerated &amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s0">aGenerated &amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s0">aGenerated</span>
	        <span class="s0">&amp;&amp; aGenerated.line &gt; </span><span class="s6">0 </span><span class="s0">&amp;&amp; aGenerated.column &gt;= </span><span class="s6">0</span>
	        <span class="s0">&amp;&amp; !aOriginal &amp;&amp; !aSource &amp;&amp; !aName) {</span>
	      <span class="s5">// Case 1.</span>
	      <span class="s1">return</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else if </span><span class="s0">(aGenerated &amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s0">aGenerated &amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s0">aGenerated</span>
	             <span class="s0">&amp;&amp; aOriginal &amp;&amp; </span><span class="s3">'line' </span><span class="s1">in </span><span class="s0">aOriginal &amp;&amp; </span><span class="s3">'column' </span><span class="s1">in </span><span class="s0">aOriginal</span>
	             <span class="s0">&amp;&amp; aGenerated.line &gt; </span><span class="s6">0 </span><span class="s0">&amp;&amp; aGenerated.column &gt;= </span><span class="s6">0</span>
	             <span class="s0">&amp;&amp; aOriginal.line &gt; </span><span class="s6">0 </span><span class="s0">&amp;&amp; aOriginal.column &gt;= </span><span class="s6">0</span>
	             <span class="s0">&amp;&amp; aSource) {</span>
	      <span class="s5">// Cases 2 and 3.</span>
	      <span class="s1">return</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Invalid mapping: ' </span><span class="s0">+ JSON.stringify({</span>
	        <span class="s0">generated: aGenerated</span><span class="s2">,</span>
	        <span class="s0">source: aSource</span><span class="s2">,</span>
	        <span class="s0">original: aOriginal</span><span class="s2">,</span>
	        <span class="s0">name: aName</span>
	      <span class="s0">}))</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Serialize the accumulated mappings in to the stream of base 64 VLQs</span>
	 <span class="s7">* specified by the source map format.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype._serializeMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_serializeMappings() {</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedLine = </span><span class="s6">1</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalColumn = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalLine = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousName = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousSource = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">result = </span><span class="s3">''</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">next</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">mapping</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">nameIdx</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">sourceIdx</span><span class="s2">;</span>

	    <span class="s1">var </span><span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._mappings.toArray()</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = mappings.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s0">mapping = mappings[i]</span><span class="s2">;</span>
	      <span class="s0">next = </span><span class="s3">''</span>

	      <span class="s1">if </span><span class="s0">(mapping.generatedLine !== previousGeneratedLine) {</span>
	        <span class="s0">previousGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	        <span class="s1">while </span><span class="s0">(mapping.generatedLine !== previousGeneratedLine) {</span>
	          <span class="s0">next += </span><span class="s3">';'</span><span class="s2">;</span>
	          <span class="s0">previousGeneratedLine++</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	      <span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">if </span><span class="s0">(i &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	          <span class="s1">if </span><span class="s0">(!util.compareByGeneratedPositionsInflated(mapping</span><span class="s2">, </span><span class="s0">mappings[i - </span><span class="s6">1</span><span class="s0">])) {</span>
	            <span class="s1">continue</span><span class="s2">;</span>
	          <span class="s0">}</span>
	          <span class="s0">next += </span><span class="s3">','</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>

	      <span class="s0">next += base64VLQ.encode(mapping.generatedColumn</span>
	                                 <span class="s0">- previousGeneratedColumn)</span><span class="s2">;</span>
	      <span class="s0">previousGeneratedColumn = mapping.generatedColumn</span><span class="s2">;</span>

	      <span class="s1">if </span><span class="s0">(mapping.source != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">sourceIdx = </span><span class="s1">this</span><span class="s0">._sources.indexOf(mapping.source)</span><span class="s2">;</span>
	        <span class="s0">next += base64VLQ.encode(sourceIdx - previousSource)</span><span class="s2">;</span>
	        <span class="s0">previousSource = sourceIdx</span><span class="s2">;</span>

	        <span class="s5">// lines are stored 0-based in SourceMap spec version 3</span>
	        <span class="s0">next += base64VLQ.encode(mapping.originalLine - </span><span class="s6">1</span>
	                                   <span class="s0">- previousOriginalLine)</span><span class="s2">;</span>
	        <span class="s0">previousOriginalLine = mapping.originalLine - </span><span class="s6">1</span><span class="s2">;</span>

	        <span class="s0">next += base64VLQ.encode(mapping.originalColumn</span>
	                                   <span class="s0">- previousOriginalColumn)</span><span class="s2">;</span>
	        <span class="s0">previousOriginalColumn = mapping.originalColumn</span><span class="s2">;</span>

	        <span class="s1">if </span><span class="s0">(mapping.name != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">nameIdx = </span><span class="s1">this</span><span class="s0">._names.indexOf(mapping.name)</span><span class="s2">;</span>
	          <span class="s0">next += base64VLQ.encode(nameIdx - previousName)</span><span class="s2">;</span>
	          <span class="s0">previousName = nameIdx</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>

	      <span class="s0">result += next</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s0">result</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s0">SourceMapGenerator.prototype._generateSourcesContent =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_generateSourcesContent(aSources</span><span class="s2">, </span><span class="s0">aSourceRoot) {</span>
	    <span class="s1">return </span><span class="s0">aSources.map(</span><span class="s1">function </span><span class="s0">(source) {</span>
	      <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	        <span class="s1">return null</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">if </span><span class="s0">(aSourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s0">source = util.relative(aSourceRoot</span><span class="s2">, </span><span class="s0">source)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">var </span><span class="s0">key = util.toSetString(source)</span><span class="s2">;</span>
	      <span class="s1">return </span><span class="s0">Object.prototype.hasOwnProperty.call(</span><span class="s1">this</span><span class="s0">._sourcesContents</span><span class="s2">, </span><span class="s0">key)</span>
	        <span class="s0">? </span><span class="s1">this</span><span class="s0">._sourcesContents[key]</span>
	        <span class="s0">: </span><span class="s1">null</span><span class="s2">;</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Externalize the source map.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.toJSON =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_toJSON() {</span>
	    <span class="s1">var </span><span class="s0">map = {</span>
	      <span class="s0">version: </span><span class="s1">this</span><span class="s0">._version</span><span class="s2">,</span>
	      <span class="s0">sources: </span><span class="s1">this</span><span class="s0">._sources.toArray()</span><span class="s2">,</span>
	      <span class="s0">names: </span><span class="s1">this</span><span class="s0">._names.toArray()</span><span class="s2">,</span>
	      <span class="s0">mappings: </span><span class="s1">this</span><span class="s0">._serializeMappings()</span>
	    <span class="s0">}</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._file != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">map.file = </span><span class="s1">this</span><span class="s0">._file</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">map.sourceRoot = </span><span class="s1">this</span><span class="s0">._sourceRoot</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sourcesContents) {</span>
	      <span class="s0">map.sourcesContent = </span><span class="s1">this</span><span class="s0">._generateSourcesContent(map.sources</span><span class="s2">, </span><span class="s0">map.sourceRoot)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s0">map</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Render the source map being generated to a string.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapGenerator.prototype.toString =</span>
	  <span class="s1">function </span><span class="s0">SourceMapGenerator_toString() {</span>
	    <span class="s1">return </span><span class="s0">JSON.stringify(</span><span class="s1">this</span><span class="s0">.toJSON())</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s0">exports.SourceMapGenerator = SourceMapGenerator</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 2 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     * 
     * Based on the Base 64 VLQ implementation in Closure Compiler: 
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java 
     * 
     * Copyright 2011 The Closure Compiler Authors. All rights reserved. 
     * Redistribution and use in source and binary forms, with or without 
     * modification, are permitted provided that the following conditions are 
     * met: 
     * 
     *  * Redistributions of source code must retain the above copyright 
     *    notice, this list of conditions and the following disclaimer. 
     *  * Redistributions in binary form must reproduce the above 
     *    copyright notice, this list of conditions and the following 
     *    disclaimer in the documentation and/or other materials provided 
     *    with the distribution. 
     *  * Neither the name of Google Inc. nor the names of its 
     *    contributors may be used to endorse or promote products derived 
     *    from this software without specific prior written permission. 
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
     * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
     */</span>

	<span class="s1">var </span><span class="s0">base64 = __webpack_require__(</span><span class="s6">3</span><span class="s0">)</span><span class="s2">;</span>

	<span class="s5">// A single base 64 digit can contain 6 bits of data. For the base 64 variable</span>
	<span class="s5">// length quantities we use in the source map spec, the first bit is the sign,</span>
	<span class="s5">// the next four bits are the actual value, and the 6th bit is the</span>
	<span class="s5">// continuation bit. The continuation bit tells us whether there are more</span>
	<span class="s5">// digits in this value following this digit.</span>
	<span class="s5">//</span>
	<span class="s5">//   Continuation</span>
	<span class="s5">//   |    Sign</span>
	<span class="s5">//   |    |</span>
	<span class="s5">//   V    V</span>
	<span class="s5">//   101011</span>

	<span class="s1">var </span><span class="s0">VLQ_BASE_SHIFT = </span><span class="s6">5</span><span class="s2">;</span>

	<span class="s5">// binary: 100000</span>
	<span class="s1">var </span><span class="s0">VLQ_BASE = </span><span class="s6">1 </span><span class="s0">&lt;&lt; VLQ_BASE_SHIFT</span><span class="s2">;</span>

	<span class="s5">// binary: 011111</span>
	<span class="s1">var </span><span class="s0">VLQ_BASE_MASK = VLQ_BASE - </span><span class="s6">1</span><span class="s2">;</span>

	<span class="s5">// binary: 100000</span>
	<span class="s1">var </span><span class="s0">VLQ_CONTINUATION_BIT = VLQ_BASE</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Converts from a two-complement value to a value where the sign bit is</span>
	 <span class="s7">* placed in the least significant bit.  For example, as decimals:</span>
	 <span class="s7">*   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)</span>
	 <span class="s7">*   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">toVLQSigned(aValue) {</span>
	  <span class="s1">return </span><span class="s0">aValue &lt; </span><span class="s6">0</span>
	    <span class="s0">? ((-aValue) &lt;&lt; </span><span class="s6">1</span><span class="s0">) + </span><span class="s6">1</span>
	    <span class="s0">: (aValue &lt;&lt; </span><span class="s6">1</span><span class="s0">) + </span><span class="s6">0</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Converts to a two-complement value from a value where the sign bit is</span>
	 <span class="s7">* placed in the least significant bit.  For example, as decimals:</span>
	 <span class="s7">*   2 (10 binary) becomes 1, 3 (11 binary) becomes -1</span>
	 <span class="s7">*   4 (100 binary) becomes 2, 5 (101 binary) becomes -2</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">fromVLQSigned(aValue) {</span>
	  <span class="s1">var </span><span class="s0">isNegative = (aValue &amp; </span><span class="s6">1</span><span class="s0">) === </span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">shifted = aValue &gt;&gt; </span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s1">return </span><span class="s0">isNegative</span>
	    <span class="s0">? -shifted</span>
	    <span class="s0">: shifted</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the base 64 VLQ encoded value.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.encode = </span><span class="s1">function </span><span class="s0">base64VLQ_encode(aValue) {</span>
	  <span class="s1">var </span><span class="s0">encoded = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">digit</span><span class="s2">;</span>

	  <span class="s1">var </span><span class="s0">vlq = toVLQSigned(aValue)</span><span class="s2">;</span>

	  <span class="s1">do </span><span class="s0">{</span>
	    <span class="s0">digit = vlq &amp; VLQ_BASE_MASK</span><span class="s2">;</span>
	    <span class="s0">vlq &gt;&gt;&gt;= VLQ_BASE_SHIFT</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(vlq &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s5">// There are still more digits in this value, so we must make sure the</span>
	      <span class="s5">// continuation bit is marked.</span>
	      <span class="s0">digit |= VLQ_CONTINUATION_BIT</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">encoded += base64.encode(digit)</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">while </span><span class="s0">(vlq &gt; </span><span class="s6">0</span><span class="s0">)</span><span class="s2">;</span>

	  <span class="s1">return </span><span class="s0">encoded</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Decodes the next base 64 VLQ value from the given string and returns the</span>
	 <span class="s7">* value and the rest of the string via the out parameter.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.decode = </span><span class="s1">function </span><span class="s0">base64VLQ_decode(aStr</span><span class="s2">, </span><span class="s0">aIndex</span><span class="s2">, </span><span class="s0">aOutParam) {</span>
	  <span class="s1">var </span><span class="s0">strLen = aStr.length</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">result = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">shift = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">continuation</span><span class="s2">, </span><span class="s0">digit</span><span class="s2">;</span>

	  <span class="s1">do </span><span class="s0">{</span>
	    <span class="s1">if </span><span class="s0">(aIndex &gt;= strLen) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Expected more digits in base 64 VLQ value.&quot;</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s0">digit = base64.decode(aStr.charCodeAt(aIndex++))</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(digit === -</span><span class="s6">1</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Invalid base64 digit: &quot; </span><span class="s0">+ aStr.charAt(aIndex - </span><span class="s6">1</span><span class="s0">))</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s0">continuation = !!(digit &amp; VLQ_CONTINUATION_BIT)</span><span class="s2">;</span>
	    <span class="s0">digit &amp;= VLQ_BASE_MASK</span><span class="s2">;</span>
	    <span class="s0">result = result + (digit &lt;&lt; shift)</span><span class="s2">;</span>
	    <span class="s0">shift += VLQ_BASE_SHIFT</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">while </span><span class="s0">(continuation)</span><span class="s2">;</span>

	  <span class="s0">aOutParam.value = fromVLQSigned(result)</span><span class="s2">;</span>
	  <span class="s0">aOutParam.rest = aIndex</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 3 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s1">var </span><span class="s0">intToCharMap = </span><span class="s3">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span><span class="s0">.split(</span><span class="s3">''</span><span class="s0">)</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Encode an integer in the range of 0 to 63 to a single base 64 digit.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.encode = </span><span class="s1">function </span><span class="s0">(number) {</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s6">0 </span><span class="s0">&lt;= number &amp;&amp; number &lt; intToCharMap.length) {</span>
	    <span class="s1">return </span><span class="s0">intToCharMap[number]</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">&quot;Must be between 0 and 63: &quot; </span><span class="s0">+ number)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Decode a single base 64 character code digit to an integer. Returns -1 on</span>
	 <span class="s7">* failure.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.decode = </span><span class="s1">function </span><span class="s0">(charCode) {</span>
	  <span class="s1">var </span><span class="s0">bigA = </span><span class="s6">65</span><span class="s2">;     </span><span class="s5">// 'A'</span>
	  <span class="s1">var </span><span class="s0">bigZ = </span><span class="s6">90</span><span class="s2">;     </span><span class="s5">// 'Z'</span>

	  <span class="s1">var </span><span class="s0">littleA = </span><span class="s6">97</span><span class="s2">;  </span><span class="s5">// 'a'</span>
	  <span class="s1">var </span><span class="s0">littleZ = </span><span class="s6">122</span><span class="s2">; </span><span class="s5">// 'z'</span>

	  <span class="s1">var </span><span class="s0">zero = </span><span class="s6">48</span><span class="s2">;     </span><span class="s5">// '0'</span>
	  <span class="s1">var </span><span class="s0">nine = </span><span class="s6">57</span><span class="s2">;     </span><span class="s5">// '9'</span>

	  <span class="s1">var </span><span class="s0">plus = </span><span class="s6">43</span><span class="s2">;     </span><span class="s5">// '+'</span>
	  <span class="s1">var </span><span class="s0">slash = </span><span class="s6">47</span><span class="s2">;    </span><span class="s5">// '/'</span>

	  <span class="s1">var </span><span class="s0">littleOffset = </span><span class="s6">26</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">numberOffset = </span><span class="s6">52</span><span class="s2">;</span>

	  <span class="s5">// 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ</span>
	  <span class="s1">if </span><span class="s0">(bigA &lt;= charCode &amp;&amp; charCode &lt;= bigZ) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - bigA)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// 26 - 51: abcdefghijklmnopqrstuvwxyz</span>
	  <span class="s1">if </span><span class="s0">(littleA &lt;= charCode &amp;&amp; charCode &lt;= littleZ) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - littleA + littleOffset)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// 52 - 61: 0123456789</span>
	  <span class="s1">if </span><span class="s0">(zero &lt;= charCode &amp;&amp; charCode &lt;= nine) {</span>
	    <span class="s1">return </span><span class="s0">(charCode - zero + numberOffset)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// 62: +</span>
	  <span class="s1">if </span><span class="s0">(charCode == plus) {</span>
	    <span class="s1">return </span><span class="s6">62</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// 63: /</span>
	  <span class="s1">if </span><span class="s0">(charCode == slash) {</span>
	    <span class="s1">return </span><span class="s6">63</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// Invalid base64 digit.</span>
	  <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 4 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s7">/**</span>
	 <span class="s7">* This is a helper function for getting values from parameter/options</span>
	 <span class="s7">* objects.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">args The object we are extracting values from</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">name The name of the property we are getting.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">defaultValue An optional value to return if the property is missing</span>
	 <span class="s7">* from the object. If this is not specified and the property is missing, an</span>
	 <span class="s7">* error will be thrown.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">getArg(aArgs</span><span class="s2">, </span><span class="s0">aName</span><span class="s2">, </span><span class="s0">aDefaultValue) {</span>
	  <span class="s1">if </span><span class="s0">(aName </span><span class="s1">in </span><span class="s0">aArgs) {</span>
	    <span class="s1">return </span><span class="s0">aArgs[aName]</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">else if </span><span class="s0">(arguments.length === </span><span class="s6">3</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">aDefaultValue</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'&quot;' </span><span class="s0">+ aName + </span><span class="s3">'&quot; is a required argument.'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>
	<span class="s0">exports.getArg = getArg</span><span class="s2">;</span>

	<span class="s1">var </span><span class="s0">urlRegexp = </span><span class="s6">/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">dataUrlRegexp = </span><span class="s6">/^data:.+\,.+$/</span><span class="s2">;</span>

	<span class="s1">function </span><span class="s0">urlParse(aUrl) {</span>
	  <span class="s1">var </span><span class="s0">match = aUrl.match(urlRegexp)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(!match) {</span>
	    <span class="s1">return null</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">{</span>
	    <span class="s0">scheme: match[</span><span class="s6">1</span><span class="s0">]</span><span class="s2">,</span>
	    <span class="s0">auth: match[</span><span class="s6">2</span><span class="s0">]</span><span class="s2">,</span>
	    <span class="s0">host: match[</span><span class="s6">3</span><span class="s0">]</span><span class="s2">,</span>
	    <span class="s0">port: match[</span><span class="s6">4</span><span class="s0">]</span><span class="s2">,</span>
	    <span class="s0">path: match[</span><span class="s6">5</span><span class="s0">]</span>
	  <span class="s0">}</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.urlParse = urlParse</span><span class="s2">;</span>

	<span class="s1">function </span><span class="s0">urlGenerate(aParsedUrl) {</span>
	  <span class="s1">var </span><span class="s0">url = </span><span class="s3">''</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.scheme) {</span>
	    <span class="s0">url += aParsedUrl.scheme + </span><span class="s3">':'</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s0">url += </span><span class="s3">'//'</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.auth) {</span>
	    <span class="s0">url += aParsedUrl.auth + </span><span class="s3">'@'</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.host) {</span>
	    <span class="s0">url += aParsedUrl.host</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.port) {</span>
	    <span class="s0">url += </span><span class="s3">&quot;:&quot; </span><span class="s0">+ aParsedUrl.port</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aParsedUrl.path) {</span>
	    <span class="s0">url += aParsedUrl.path</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">url</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.urlGenerate = urlGenerate</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Normalizes a path, or the path portion of a URL:</span>
	 <span class="s7">*</span>
	 <span class="s7">* - Replaces consecutive slashes with one slash.</span>
	 <span class="s7">* - Removes unnecessary '.' parts.</span>
	 <span class="s7">* - Removes unnecessary '&lt;dir&gt;/..' parts.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Based on code in the Node.js 'path' core module.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aPath The path or url to normalize.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">normalize(aPath) {</span>
	  <span class="s1">var </span><span class="s0">path = aPath</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">url = urlParse(aPath)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(url) {</span>
	    <span class="s1">if </span><span class="s0">(!url.path) {</span>
	      <span class="s1">return </span><span class="s0">aPath</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">path = url.path</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">var </span><span class="s0">isAbsolute = exports.isAbsolute(path)</span><span class="s2">;</span>

	  <span class="s1">var </span><span class="s0">parts = path.split(</span><span class="s6">/\/+/</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">part</span><span class="s2">, </span><span class="s0">up = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">i = parts.length - </span><span class="s6">1</span><span class="s2">; </span><span class="s0">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i--) {</span>
	    <span class="s0">part = parts[i]</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(part === </span><span class="s3">'.'</span><span class="s0">) {</span>
	      <span class="s0">parts.splice(i</span><span class="s2">, </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(part === </span><span class="s3">'..'</span><span class="s0">) {</span>
	      <span class="s0">up++</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(up &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">if </span><span class="s0">(part === </span><span class="s3">''</span><span class="s0">) {</span>
	        <span class="s5">// The first part is blank if the path is absolute. Trying to go</span>
	        <span class="s5">// above the root is a no-op. Therefore we can remove all '..' parts</span>
	        <span class="s5">// directly after the root.</span>
	        <span class="s0">parts.splice(i + </span><span class="s6">1</span><span class="s2">, </span><span class="s0">up)</span><span class="s2">;</span>
	        <span class="s0">up = </span><span class="s6">0</span><span class="s2">;</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">parts.splice(i</span><span class="s2">, </span><span class="s6">2</span><span class="s0">)</span><span class="s2">;</span>
	        <span class="s0">up--</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s0">path = parts.join(</span><span class="s3">'/'</span><span class="s0">)</span><span class="s2">;</span>

	  <span class="s1">if </span><span class="s0">(path === </span><span class="s3">''</span><span class="s0">) {</span>
	    <span class="s0">path = isAbsolute ? </span><span class="s3">'/' </span><span class="s0">: </span><span class="s3">'.'</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(url) {</span>
	    <span class="s0">url.path = path</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(url)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">path</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.normalize = normalize</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Joins two paths/URLs.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aRoot The root path or URL.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aPath The path or URL to be joined with the root.</span>
	 <span class="s7">*</span>
	 <span class="s7">* - If aPath is a URL or a data URI, aPath is returned, unless aPath is a</span>
	 <span class="s7">*   scheme-relative URL: Then the scheme of aRoot, if any, is prepended</span>
	 <span class="s7">*   first.</span>
	 <span class="s7">* - Otherwise aPath is a path. If aRoot is a URL, then its path portion</span>
	 <span class="s7">*   is updated with the result and aRoot is returned. Otherwise the result</span>
	 <span class="s7">*   is returned.</span>
	 <span class="s7">*   - If aPath is absolute, the result is aPath.</span>
	 <span class="s7">*   - Otherwise the two paths are joined with a slash.</span>
	 <span class="s7">* - Joining for example 'http://' and 'www.example.com' is also supported.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">join(aRoot</span><span class="s2">, </span><span class="s0">aPath) {</span>
	  <span class="s1">if </span><span class="s0">(aRoot === </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aRoot = </span><span class="s3">&quot;.&quot;</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(aPath === </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aPath = </span><span class="s3">&quot;.&quot;</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">var </span><span class="s0">aPathUrl = urlParse(aPath)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">aRootUrl = urlParse(aRoot)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	    <span class="s0">aRoot = aRootUrl.path || </span><span class="s3">'/'</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// `join(foo, '//www.example.org')`</span>
	  <span class="s1">if </span><span class="s0">(aPathUrl &amp;&amp; !aPathUrl.scheme) {</span>
	    <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	      <span class="s0">aPathUrl.scheme = aRootUrl.scheme</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aPathUrl)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(aPathUrl || aPath.match(dataUrlRegexp)) {</span>
	    <span class="s1">return </span><span class="s0">aPath</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// `join('http://', 'www.example.com')`</span>
	  <span class="s1">if </span><span class="s0">(aRootUrl &amp;&amp; !aRootUrl.host &amp;&amp; !aRootUrl.path) {</span>
	    <span class="s0">aRootUrl.host = aPath</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aRootUrl)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s0">joined = aPath.charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s3">'/'</span>
	    <span class="s0">? aPath</span>
	    <span class="s0">: normalize(aRoot.replace(</span><span class="s6">/\/+$/</span><span class="s2">, </span><span class="s3">''</span><span class="s0">) + </span><span class="s3">'/' </span><span class="s0">+ aPath)</span><span class="s2">;</span>

	  <span class="s1">if </span><span class="s0">(aRootUrl) {</span>
	    <span class="s0">aRootUrl.path = joined</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">urlGenerate(aRootUrl)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">joined</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.join = join</span><span class="s2">;</span>

	<span class="s0">exports.isAbsolute = </span><span class="s1">function </span><span class="s0">(aPath) {</span>
	  <span class="s1">return </span><span class="s0">aPath.charAt(</span><span class="s6">0</span><span class="s0">) === </span><span class="s3">'/' </span><span class="s0">|| urlRegexp.test(aPath)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Make a path relative to a URL or another path.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aRoot The root path or URL.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aPath The path or URL to be made relative to aRoot.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">relative(aRoot</span><span class="s2">, </span><span class="s0">aPath) {</span>
	  <span class="s1">if </span><span class="s0">(aRoot === </span><span class="s3">&quot;&quot;</span><span class="s0">) {</span>
	    <span class="s0">aRoot = </span><span class="s3">&quot;.&quot;</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">aRoot = aRoot.replace(</span><span class="s6">/\/$/</span><span class="s2">, </span><span class="s3">''</span><span class="s0">)</span><span class="s2">;</span>

	  <span class="s5">// It is possible for the path to be above the root. In this case, simply</span>
	  <span class="s5">// checking whether the root is a prefix of the path won't work. Instead, we</span>
	  <span class="s5">// need to remove components from the root one by one, until either we find</span>
	  <span class="s5">// a prefix that fits, or we run out of components to remove.</span>
	  <span class="s1">var </span><span class="s0">level = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">while </span><span class="s0">(aPath.indexOf(aRoot + </span><span class="s3">'/'</span><span class="s0">) !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">var </span><span class="s0">index = aRoot.lastIndexOf(</span><span class="s3">&quot;/&quot;</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">aPath</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s5">// If the only part of the root that is left is the scheme (i.e. http://,</span>
	    <span class="s5">// file:///, etc.), one or more slashes (/), or simply nothing at all, we</span>
	    <span class="s5">// have exhausted all components, so the path is not relative to the root.</span>
	    <span class="s0">aRoot = aRoot.slice(</span><span class="s6">0</span><span class="s2">, </span><span class="s0">index)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(aRoot.match(</span><span class="s6">/^([^\/]+:\/)?\/*$/</span><span class="s0">)) {</span>
	      <span class="s1">return </span><span class="s0">aPath</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s0">++level</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// Make sure we add a &quot;../&quot; for each component we removed from the root.</span>
	  <span class="s1">return </span><span class="s0">Array(level + </span><span class="s6">1</span><span class="s0">).join(</span><span class="s3">&quot;../&quot;</span><span class="s0">) + aPath.substr(aRoot.length + </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.relative = relative</span><span class="s2">;</span>

	<span class="s1">var </span><span class="s0">supportsNullProto = (</span><span class="s1">function </span><span class="s0">() {</span>
	  <span class="s1">var </span><span class="s0">obj = Object.create(</span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">return </span><span class="s0">!(</span><span class="s3">'__proto__' </span><span class="s1">in </span><span class="s0">obj)</span><span class="s2">;</span>
	<span class="s0">}())</span><span class="s2">;</span>

	<span class="s1">function </span><span class="s0">identity (s) {</span>
	  <span class="s1">return </span><span class="s0">s</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Because behavior goes wacky when you set `__proto__` on objects, we</span>
	 <span class="s7">* have to prefix all the strings in our set with an arbitrary character.</span>
	 <span class="s7">*</span>
	 <span class="s7">* See https://github.com/mozilla/source-map/pull/31 and</span>
	 <span class="s7">* https://github.com/mozilla/source-map/issues/30</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aStr</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">toSetString(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(isProtoString(aStr)) {</span>
	    <span class="s1">return </span><span class="s3">'$' </span><span class="s0">+ aStr</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">aStr</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.toSetString = supportsNullProto ? identity : toSetString</span><span class="s2">;</span>

	<span class="s1">function </span><span class="s0">fromSetString(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(isProtoString(aStr)) {</span>
	    <span class="s1">return </span><span class="s0">aStr.slice(</span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">aStr</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.fromSetString = supportsNullProto ? identity : fromSetString</span><span class="s2">;</span>

	<span class="s1">function </span><span class="s0">isProtoString(s) {</span>
	  <span class="s1">if </span><span class="s0">(!s) {</span>
	    <span class="s1">return false</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s0">length = s.length</span><span class="s2">;</span>

	  <span class="s1">if </span><span class="s0">(length &lt; </span><span class="s6">9 </span><span class="s4">/* &quot;__proto__&quot;.length */</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(s.charCodeAt(length - </span><span class="s6">1</span><span class="s0">) !== </span><span class="s6">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">2</span><span class="s0">) !== </span><span class="s6">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">3</span><span class="s0">) !== </span><span class="s6">111 </span><span class="s4">/* 'o' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">4</span><span class="s0">) !== </span><span class="s6">116 </span><span class="s4">/* 't' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">5</span><span class="s0">) !== </span><span class="s6">111 </span><span class="s4">/* 'o' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">6</span><span class="s0">) !== </span><span class="s6">114 </span><span class="s4">/* 'r' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">7</span><span class="s0">) !== </span><span class="s6">112 </span><span class="s4">/* 'p' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">8</span><span class="s0">) !== </span><span class="s6">95  </span><span class="s4">/* '_' */ </span><span class="s0">||</span>
	      <span class="s0">s.charCodeAt(length - </span><span class="s6">9</span><span class="s0">) !== </span><span class="s6">95  </span><span class="s4">/* '_' */</span><span class="s0">) {</span>
	    <span class="s1">return false</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = length - </span><span class="s6">10</span><span class="s2">; </span><span class="s0">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i--) {</span>
	    <span class="s1">if </span><span class="s0">(s.charCodeAt(i) !== </span><span class="s6">36 </span><span class="s4">/* '$' */</span><span class="s0">) {</span>
	      <span class="s1">return false</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">return true</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Comparator between two mappings where the original positions are compared.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span>
	 <span class="s7">* mappings with the same original source/line/column, but different generated</span>
	 <span class="s7">* line and column the same. Useful when searching for a mapping with a</span>
	 <span class="s7">* stubbed out mapping.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">compareByOriginalPositions(mappingA</span><span class="s2">, </span><span class="s0">mappingB</span><span class="s2">, </span><span class="s0">onlyCompareOriginal) {</span>
	  <span class="s1">var </span><span class="s0">cmp = strcmp(mappingA.source</span><span class="s2">, </span><span class="s0">mappingB.source)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0 </span><span class="s0">|| onlyCompareOriginal) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">strcmp(mappingA.name</span><span class="s2">, </span><span class="s0">mappingB.name)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByOriginalPositions = compareByOriginalPositions</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Comparator between two mappings with deflated source and name indices where</span>
	 <span class="s7">* the generated positions are compared.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Optionally pass in `true` as `onlyCompareGenerated` to consider two</span>
	 <span class="s7">* mappings with the same generated line and column, but different</span>
	 <span class="s7">* source/name/original line and column the same. Useful when searching for a</span>
	 <span class="s7">* mapping with a stubbed out mapping.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">compareByGeneratedPositionsDeflated(mappingA</span><span class="s2">, </span><span class="s0">mappingB</span><span class="s2">, </span><span class="s0">onlyCompareGenerated) {</span>
	  <span class="s1">var </span><span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0 </span><span class="s0">|| onlyCompareGenerated) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = strcmp(mappingA.source</span><span class="s2">, </span><span class="s0">mappingB.source)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">strcmp(mappingA.name</span><span class="s2">, </span><span class="s0">mappingB.name)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated</span><span class="s2">;</span>

	<span class="s1">function </span><span class="s0">strcmp(aStr1</span><span class="s2">, </span><span class="s0">aStr2) {</span>
	  <span class="s1">if </span><span class="s0">(aStr1 === aStr2) {</span>
	    <span class="s1">return </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(aStr1 === </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s6">1</span><span class="s2">; </span><span class="s5">// aStr2 !== null</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(aStr2 === </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">; </span><span class="s5">// aStr1 !== null</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(aStr1 &gt; aStr2) {</span>
	    <span class="s1">return </span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Comparator between two mappings with inflated source and name strings where</span>
	 <span class="s7">* the generated positions are compared.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">compareByGeneratedPositionsInflated(mappingA</span><span class="s2">, </span><span class="s0">mappingB) {</span>
	  <span class="s1">var </span><span class="s0">cmp = mappingA.generatedLine - mappingB.generatedLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.generatedColumn - mappingB.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = strcmp(mappingA.source</span><span class="s2">, </span><span class="s0">mappingB.source)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.originalLine - mappingB.originalLine</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">cmp = mappingA.originalColumn - mappingB.originalColumn</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp !== </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">strcmp(mappingA.name</span><span class="s2">, </span><span class="s0">mappingB.name)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Strip any JSON XSSI avoidance prefix from the string (as documented</span>
	 <span class="s7">* in the source maps specification), and then parse the string as</span>
	 <span class="s7">* JSON.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">parseSourceMapInput(str) {</span>
	  <span class="s1">return </span><span class="s0">JSON.parse(str.replace(</span><span class="s6">/^\)]}'[^\n]*\n/</span><span class="s2">, </span><span class="s3">''</span><span class="s0">))</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.parseSourceMapInput = parseSourceMapInput</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Compute the URL of a source given the the source root, the source's</span>
	 <span class="s7">* URL, and the source map's URL.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">computeSourceURL(sourceRoot</span><span class="s2">, </span><span class="s0">sourceURL</span><span class="s2">, </span><span class="s0">sourceMapURL) {</span>
	  <span class="s0">sourceURL = sourceURL || </span><span class="s3">''</span><span class="s2">;</span>

	  <span class="s1">if </span><span class="s0">(sourceRoot) {</span>
	    <span class="s5">// This follows what Chrome does.</span>
	    <span class="s1">if </span><span class="s0">(sourceRoot[sourceRoot.length - </span><span class="s6">1</span><span class="s0">] !== </span><span class="s3">'/' </span><span class="s0">&amp;&amp; sourceURL[</span><span class="s6">0</span><span class="s0">] !== </span><span class="s3">'/'</span><span class="s0">) {</span>
	      <span class="s0">sourceRoot += </span><span class="s3">'/'</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s5">// The spec says:</span>
	    <span class="s5">//   Line 4: An optional source root, useful for relocating source</span>
	    <span class="s5">//   files on a server or removing repeated values in the</span>
	    <span class="s5">//   sources entry.  This value is prepended to the individual</span>
	    <span class="s5">//   entries in the source field.</span>
	    <span class="s0">sourceURL = sourceRoot + sourceURL</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// Historically, SourceMapConsumer did not take the sourceMapURL as</span>
	  <span class="s5">// a parameter.  This mode is still somewhat supported, which is why</span>
	  <span class="s5">// this code block is conditional.  However, it's preferable to pass</span>
	  <span class="s5">// the source map URL to SourceMapConsumer, so that this function</span>
	  <span class="s5">// can implement the source URL resolution algorithm as outlined in</span>
	  <span class="s5">// the spec.  This block is basically the equivalent of:</span>
	  <span class="s5">//    new URL(sourceURL, sourceMapURL).toString()</span>
	  <span class="s5">// ... except it avoids using URL, which wasn't available in the</span>
	  <span class="s5">// older releases of node still supported by this library.</span>
	  <span class="s5">//</span>
	  <span class="s5">// The spec says:</span>
	  <span class="s5">//   If the sources are not absolute URLs after prepending of the</span>
	  <span class="s5">//   sourceRoot, the sources are resolved relative to the</span>
	  <span class="s5">//   SourceMap (like resolving script src in a html document).</span>
	  <span class="s1">if </span><span class="s0">(sourceMapURL) {</span>
	    <span class="s1">var </span><span class="s0">parsed = urlParse(sourceMapURL)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(!parsed) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;sourceMapURL could not be parsed&quot;</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(parsed.path) {</span>
	      <span class="s5">// Strip the last path component, but keep the &quot;/&quot;.</span>
	      <span class="s1">var </span><span class="s0">index = parsed.path.lastIndexOf(</span><span class="s3">'/'</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	        <span class="s0">parsed.path = parsed.path.substring(</span><span class="s6">0</span><span class="s2">, </span><span class="s0">index + </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s0">sourceURL = join(urlGenerate(parsed)</span><span class="s2">, </span><span class="s0">sourceURL)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">normalize(sourceURL)</span><span class="s2">;</span>
	<span class="s0">}</span>
	<span class="s0">exports.computeSourceURL = computeSourceURL</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 5 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">has = Object.prototype.hasOwnProperty</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">hasNativeMap = </span><span class="s1">typeof </span><span class="s0">Map !== </span><span class="s3">&quot;undefined&quot;</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* A data structure which is a combination of an array and a set. Adding a new</span>
	 <span class="s7">* member is O(1), testing for membership is O(1), and finding the index of an</span>
	 <span class="s7">* element is O(1). Removing elements from the set is not supported. Only</span>
	 <span class="s7">* strings are supported for membership.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">ArraySet() {</span>
	  <span class="s1">this</span><span class="s0">._array = []</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._set = hasNativeMap ? </span><span class="s1">new </span><span class="s0">Map() : Object.create(</span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Static method for creating ArraySet instances from an existing array.</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.fromArray = </span><span class="s1">function </span><span class="s0">ArraySet_fromArray(aArray</span><span class="s2">, </span><span class="s0">aAllowDuplicates) {</span>
	  <span class="s1">var </span><span class="s0">set = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = aArray.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	    <span class="s0">set.add(aArray[i]</span><span class="s2">, </span><span class="s0">aAllowDuplicates)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return </span><span class="s0">set</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Return how many unique items are in this ArraySet. If duplicates have been</span>
	 <span class="s7">* added, than those do not count towards the size.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@returns </span><span class="s7">Number</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.size = </span><span class="s1">function </span><span class="s0">ArraySet_size() {</span>
	  <span class="s1">return </span><span class="s0">hasNativeMap ? </span><span class="s1">this</span><span class="s0">._set.size : Object.getOwnPropertyNames(</span><span class="s1">this</span><span class="s0">._set).length</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Add the given string to this set.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aStr</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.add = </span><span class="s1">function </span><span class="s0">ArraySet_add(aStr</span><span class="s2">, </span><span class="s0">aAllowDuplicates) {</span>
	  <span class="s1">var </span><span class="s0">sStr = hasNativeMap ? aStr : util.toSetString(aStr)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">isDuplicate = hasNativeMap ? </span><span class="s1">this</span><span class="s0">.has(aStr) : has.call(</span><span class="s1">this</span><span class="s0">._set</span><span class="s2">, </span><span class="s0">sStr)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">idx = </span><span class="s1">this</span><span class="s0">._array.length</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(!isDuplicate || aAllowDuplicates) {</span>
	    <span class="s1">this</span><span class="s0">._array.push(aStr)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">if </span><span class="s0">(!isDuplicate) {</span>
	    <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	      <span class="s1">this</span><span class="s0">._set.set(aStr</span><span class="s2">, </span><span class="s0">idx)</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">this</span><span class="s0">._set[sStr] = idx</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Is the given string a member of this set?</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aStr</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.has = </span><span class="s1">function </span><span class="s0">ArraySet_has(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	    <span class="s1">return this</span><span class="s0">._set.has(aStr)</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">var </span><span class="s0">sStr = util.toSetString(aStr)</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">has.call(</span><span class="s1">this</span><span class="s0">._set</span><span class="s2">, </span><span class="s0">sStr)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* What is the index of the given string in the array?</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aStr</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.indexOf = </span><span class="s1">function </span><span class="s0">ArraySet_indexOf(aStr) {</span>
	  <span class="s1">if </span><span class="s0">(hasNativeMap) {</span>
	    <span class="s1">var </span><span class="s0">idx = </span><span class="s1">this</span><span class="s0">._set.get(aStr)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(idx &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	        <span class="s1">return </span><span class="s0">idx</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">var </span><span class="s0">sStr = util.toSetString(aStr)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(has.call(</span><span class="s1">this</span><span class="s0">._set</span><span class="s2">, </span><span class="s0">sStr)) {</span>
	      <span class="s1">return this</span><span class="s0">._set[sStr]</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'&quot;' </span><span class="s0">+ aStr + </span><span class="s3">'&quot; is not in the set.'</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* What is the element at the given index?</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">Number aIdx</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.at = </span><span class="s1">function </span><span class="s0">ArraySet_at(aIdx) {</span>
	  <span class="s1">if </span><span class="s0">(aIdx &gt;= </span><span class="s6">0 </span><span class="s0">&amp;&amp; aIdx &lt; </span><span class="s1">this</span><span class="s0">._array.length) {</span>
	    <span class="s1">return this</span><span class="s0">._array[aIdx]</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'No element indexed by ' </span><span class="s0">+ aIdx)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the array representation of this set (which has the proper indices</span>
	 <span class="s7">* indicated by indexOf). Note that this is a copy of the internal array used</span>
	 <span class="s7">* for storing the members so that no one can mess with internal state.</span>
	 <span class="s7">*/</span>
	<span class="s0">ArraySet.prototype.toArray = </span><span class="s1">function </span><span class="s0">ArraySet_toArray() {</span>
	  <span class="s1">return this</span><span class="s0">._array.slice()</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s0">exports.ArraySet = ArraySet</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 6 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2014 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Determine whether mappingB is after mappingA with respect to generated</span>
	 <span class="s7">* position.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">generatedPositionAfter(mappingA</span><span class="s2">, </span><span class="s0">mappingB) {</span>
	  <span class="s5">// Optimized for most common case</span>
	  <span class="s1">var </span><span class="s0">lineA = mappingA.generatedLine</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lineB = mappingB.generatedLine</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">columnA = mappingA.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">columnB = mappingB.generatedColumn</span><span class="s2">;</span>
	  <span class="s1">return </span><span class="s0">lineB &gt; lineA || lineB == lineA &amp;&amp; columnB &gt;= columnA ||</span>
	         <span class="s0">util.compareByGeneratedPositionsInflated(mappingA</span><span class="s2">, </span><span class="s0">mappingB) &lt;= </span><span class="s6">0</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* A data structure to provide a sorted view of accumulated mappings in a</span>
	 <span class="s7">* performance conscious manner. It trades a neglibable overhead in general</span>
	 <span class="s7">* case for a large speedup in case of mappings being added in order.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">MappingList() {</span>
	  <span class="s1">this</span><span class="s0">._array = []</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">true</span><span class="s2">;</span>
	  <span class="s5">// Serves as infimum</span>
	  <span class="s1">this</span><span class="s0">._last = {generatedLine: -</span><span class="s6">1</span><span class="s2">, </span><span class="s0">generatedColumn: </span><span class="s6">0</span><span class="s0">}</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Iterate through internal items. This method takes the same arguments that</span>
	 <span class="s7">* `Array.prototype.forEach` takes.</span>
	 <span class="s7">*</span>
	 <span class="s7">* NOTE: The order of the mappings is NOT guaranteed.</span>
	 <span class="s7">*/</span>
	<span class="s0">MappingList.prototype.unsortedForEach =</span>
	  <span class="s1">function </span><span class="s0">MappingList_forEach(aCallback</span><span class="s2">, </span><span class="s0">aThisArg) {</span>
	    <span class="s1">this</span><span class="s0">._array.forEach(aCallback</span><span class="s2">, </span><span class="s0">aThisArg)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Add the given source mapping.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">Object aMapping</span>
	 <span class="s7">*/</span>
	<span class="s0">MappingList.prototype.add = </span><span class="s1">function </span><span class="s0">MappingList_add(aMapping) {</span>
	  <span class="s1">if </span><span class="s0">(generatedPositionAfter(</span><span class="s1">this</span><span class="s0">._last</span><span class="s2">, </span><span class="s0">aMapping)) {</span>
	    <span class="s1">this</span><span class="s0">._last = aMapping</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._array.push(aMapping)</span><span class="s2">;</span>
	  <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">false</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._array.push(aMapping)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the flat, sorted array of mappings. The mappings are sorted by</span>
	 <span class="s7">* generated position.</span>
	 <span class="s7">*</span>
	 <span class="s7">* WARNING: This method returns internal data without copying, for</span>
	 <span class="s7">* performance. The return value must NOT be mutated, and should be treated as</span>
	 <span class="s7">* an immutable borrow. If you want to take ownership, you must make your own</span>
	 <span class="s7">* copy.</span>
	 <span class="s7">*/</span>
	<span class="s0">MappingList.prototype.toArray = </span><span class="s1">function </span><span class="s0">MappingList_toArray() {</span>
	  <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">._sorted) {</span>
	    <span class="s1">this</span><span class="s0">._array.sort(util.compareByGeneratedPositionsInflated)</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">._sorted = </span><span class="s1">true</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s0">._array</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s0">exports.MappingList = MappingList</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 7 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">binarySearch = __webpack_require__(</span><span class="s6">8</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">ArraySet = __webpack_require__(</span><span class="s6">5</span><span class="s0">).ArraySet</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">base64VLQ = __webpack_require__(</span><span class="s6">2</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">quickSort = __webpack_require__(</span><span class="s6">9</span><span class="s0">).quickSort</span><span class="s2">;</span>

	<span class="s1">function </span><span class="s0">SourceMapConsumer(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">sourceMap.sections != </span><span class="s1">null</span>
	    <span class="s0">? </span><span class="s1">new </span><span class="s0">IndexedSourceMapConsumer(sourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span>
	    <span class="s0">: </span><span class="s1">new </span><span class="s0">BasicSourceMapConsumer(sourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s0">SourceMapConsumer.fromSourceMap = </span><span class="s1">function</span><span class="s0">(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	  <span class="s1">return </span><span class="s0">BasicSourceMapConsumer.fromSourceMap(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapConsumer.prototype._version = </span><span class="s6">3</span><span class="s2">;</span>

	<span class="s5">// `__generatedMappings` and `__originalMappings` are arrays that hold the</span>
	<span class="s5">// parsed mapping coordinates from the source map's &quot;mappings&quot; attribute. They</span>
	<span class="s5">// are lazily instantiated, accessed via the `_generatedMappings` and</span>
	<span class="s5">// `_originalMappings` getters respectively, and we only parse the mappings</span>
	<span class="s5">// and create these arrays once queried for a source location. We jump through</span>
	<span class="s5">// these hoops because there can be many thousands of mappings, and parsing</span>
	<span class="s5">// them is expensive, so we only want to do it if we must.</span>
	<span class="s5">//</span>
	<span class="s5">// Each object in the arrays is of the form:</span>
	<span class="s5">//</span>
	<span class="s5">//     {</span>
	<span class="s5">//       generatedLine: The line number in the generated code,</span>
	<span class="s5">//       generatedColumn: The column number in the generated code,</span>
	<span class="s5">//       source: The path to the original source file that generated this</span>
	<span class="s5">//               chunk of code,</span>
	<span class="s5">//       originalLine: The line number in the original source that</span>
	<span class="s5">//                     corresponds to this chunk of generated code,</span>
	<span class="s5">//       originalColumn: The column number in the original source that</span>
	<span class="s5">//                       corresponds to this chunk of generated code,</span>
	<span class="s5">//       name: The name of the original symbol which generated this chunk of</span>
	<span class="s5">//             code.</span>
	<span class="s5">//     }</span>
	<span class="s5">//</span>
	<span class="s5">// All properties except for `generatedLine` and `generatedColumn` can be</span>
	<span class="s5">// `null`.</span>
	<span class="s5">//</span>
	<span class="s5">// `_generatedMappings` is ordered by the generated positions.</span>
	<span class="s5">//</span>
	<span class="s5">// `_originalMappings` is ordered by the original positions.</span>

	<span class="s0">SourceMapConsumer.prototype.__generatedMappings = </span><span class="s1">null</span><span class="s2">;</span>
	<span class="s0">Object.defineProperty(SourceMapConsumer.prototype</span><span class="s2">, </span><span class="s3">'_generatedMappings'</span><span class="s2">, </span><span class="s0">{</span>
	  <span class="s0">configurable: </span><span class="s1">true</span><span class="s2">,</span>
	  <span class="s0">enumerable: </span><span class="s1">true</span><span class="s2">,</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.__generatedMappings) {</span>
	      <span class="s1">this</span><span class="s0">._parseMappings(</span><span class="s1">this</span><span class="s0">._mappings</span><span class="s2">, </span><span class="s1">this</span><span class="s0">.sourceRoot)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">return this</span><span class="s0">.__generatedMappings</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">})</span><span class="s2">;</span>

	<span class="s0">SourceMapConsumer.prototype.__originalMappings = </span><span class="s1">null</span><span class="s2">;</span>
	<span class="s0">Object.defineProperty(SourceMapConsumer.prototype</span><span class="s2">, </span><span class="s3">'_originalMappings'</span><span class="s2">, </span><span class="s0">{</span>
	  <span class="s0">configurable: </span><span class="s1">true</span><span class="s2">,</span>
	  <span class="s0">enumerable: </span><span class="s1">true</span><span class="s2">,</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.__originalMappings) {</span>
	      <span class="s1">this</span><span class="s0">._parseMappings(</span><span class="s1">this</span><span class="s0">._mappings</span><span class="s2">, </span><span class="s1">this</span><span class="s0">.sourceRoot)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">return this</span><span class="s0">.__originalMappings</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">})</span><span class="s2">;</span>

	<span class="s0">SourceMapConsumer.prototype._charIsMappingSeparator =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_charIsMappingSeparator(aStr</span><span class="s2">, </span><span class="s0">index) {</span>
	    <span class="s1">var </span><span class="s0">c = aStr.charAt(index)</span><span class="s2">;</span>
	    <span class="s1">return </span><span class="s0">c === </span><span class="s3">&quot;;&quot; </span><span class="s0">|| c === </span><span class="s3">&quot;,&quot;</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s7">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s7">* `this.__originalMappings` properties).</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_parseMappings(aStr</span><span class="s2">, </span><span class="s0">aSourceRoot) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Subclasses must implement _parseMappings&quot;</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s0">SourceMapConsumer.GENERATED_ORDER = </span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">SourceMapConsumer.ORIGINAL_ORDER = </span><span class="s6">2</span><span class="s2">;</span>

	<span class="s0">SourceMapConsumer.GREATEST_LOWER_BOUND = </span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">SourceMapConsumer.LEAST_UPPER_BOUND = </span><span class="s6">2</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Iterate over each mapping between an original source/line/column and a</span>
	 <span class="s7">* generated line/column in this source map.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">Function aCallback</span>
	 <span class="s7">*        The function that is called with each mapping.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">Object aContext</span>
	 <span class="s7">*        Optional. If specified, this object will be the value of `this` every</span>
	 <span class="s7">*        time that `aCallback` is called.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aOrder</span>
	 <span class="s7">*        Either `SourceMapConsumer.GENERATED_ORDER` or</span>
	 <span class="s7">*        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to</span>
	 <span class="s7">*        iterate over the mappings sorted by the generated file's line/column</span>
	 <span class="s7">*        order or the original's source/line/column order, respectively. Defaults to</span>
	 <span class="s7">*        `SourceMapConsumer.GENERATED_ORDER`.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapConsumer.prototype.eachMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_eachMapping(aCallback</span><span class="s2">, </span><span class="s0">aContext</span><span class="s2">, </span><span class="s0">aOrder) {</span>
	    <span class="s1">var </span><span class="s0">context = aContext || </span><span class="s1">null</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">order = aOrder || SourceMapConsumer.GENERATED_ORDER</span><span class="s2">;</span>

	    <span class="s1">var </span><span class="s0">mappings</span><span class="s2">;</span>
	    <span class="s1">switch </span><span class="s0">(order) {</span>
	    <span class="s1">case </span><span class="s0">SourceMapConsumer.GENERATED_ORDER:</span>
	      <span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._generatedMappings</span><span class="s2">;</span>
	      <span class="s1">break</span><span class="s2">;</span>
	    <span class="s1">case </span><span class="s0">SourceMapConsumer.ORIGINAL_ORDER:</span>
	      <span class="s0">mappings = </span><span class="s1">this</span><span class="s0">._originalMappings</span><span class="s2">;</span>
	      <span class="s1">break</span><span class="s2">;</span>
	    <span class="s1">default</span><span class="s0">:</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">&quot;Unknown order of iteration.&quot;</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s0">sourceRoot = </span><span class="s1">this</span><span class="s0">.sourceRoot</span><span class="s2">;</span>
	    <span class="s0">mappings.map(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">var </span><span class="s0">source = mapping.source === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">._sources.at(mapping.source)</span><span class="s2">;</span>
	      <span class="s0">source = util.computeSourceURL(sourceRoot</span><span class="s2">, </span><span class="s0">source</span><span class="s2">, </span><span class="s1">this</span><span class="s0">._sourceMapURL)</span><span class="s2">;</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">source: source</span><span class="s2">,</span>
	        <span class="s0">generatedLine: mapping.generatedLine</span><span class="s2">,</span>
	        <span class="s0">generatedColumn: mapping.generatedColumn</span><span class="s2">,</span>
	        <span class="s0">originalLine: mapping.originalLine</span><span class="s2">,</span>
	        <span class="s0">originalColumn: mapping.originalColumn</span><span class="s2">,</span>
	        <span class="s0">name: mapping.name === </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: </span><span class="s1">this</span><span class="s0">._names.at(mapping.name)</span>
	      <span class="s0">}</span><span class="s2">;</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">).forEach(aCallback</span><span class="s2">, </span><span class="s0">context)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns all generated line and column information for the original source,</span>
	 <span class="s7">* line, and column provided. If no column is provided, returns all mappings</span>
	 <span class="s7">* corresponding to a either the line we are searching for or the next</span>
	 <span class="s7">* closest line that has any mappings. Otherwise, returns all mappings</span>
	 <span class="s7">* corresponding to the given line and either the column we are searching for</span>
	 <span class="s7">* or the next closest column that has any offsets.</span>
	 <span class="s7">*</span>
	 <span class="s7">* The only argument is an object with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The filename of the original source.</span>
	 <span class="s7">*   - line: The line number in the original source.  The line number is 1-based.</span>
	 <span class="s7">*   - column: Optional. the column number in the original source.</span>
	 <span class="s7">*    The column number is 0-based.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an array of objects is returned, each with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s7">*    line number is 1-based.</span>
	 <span class="s7">*   - column: The column number in the generated source, or null.</span>
	 <span class="s7">*    The column number is 0-based.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceMapConsumer.prototype.allGeneratedPositionsFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_allGeneratedPositionsFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">line = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">;</span>

	    <span class="s5">// When there is no exact match, BasicSourceMapConsumer.prototype._findMapping</span>
	    <span class="s5">// returns the index of the closest mapping less than the needle. By</span>
	    <span class="s5">// setting needle.originalColumn to 0, we thus find the last mapping for</span>
	    <span class="s5">// the given line, provided such a mapping exists.</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">source: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'source'</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">originalLine: line</span><span class="s2">,</span>
	      <span class="s0">originalColumn: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'column'</span><span class="s2">, </span><span class="s6">0</span><span class="s0">)</span>
	    <span class="s0">}</span><span class="s2">;</span>

	    <span class="s0">needle.source = </span><span class="s1">this</span><span class="s0">._findSourceIndex(needle.source)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(needle.source &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">[]</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s0">mappings = []</span><span class="s2">;</span>

	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(needle</span><span class="s2">,</span>
	                                  <span class="s1">this</span><span class="s0">._originalMappings</span><span class="s2">,</span>
	                                  <span class="s3">&quot;originalLine&quot;</span><span class="s2">,</span>
	                                  <span class="s3">&quot;originalColumn&quot;</span><span class="s2">,</span>
	                                  <span class="s0">util.compareByOriginalPositions</span><span class="s2">,</span>
	                                  <span class="s0">binarySearch.LEAST_UPPER_BOUND)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[index]</span><span class="s2">;</span>

	      <span class="s1">if </span><span class="s0">(aArgs.column === undefined) {</span>
	        <span class="s1">var </span><span class="s0">originalLine = mapping.originalLine</span><span class="s2">;</span>

	        <span class="s5">// Iterate until either we run out of mappings, or we run into</span>
	        <span class="s5">// a mapping for a different line than the one we found. Since</span>
	        <span class="s5">// mappings are sorted, this is guaranteed to find all mappings for</span>
	        <span class="s5">// the line we found.</span>
	        <span class="s1">while </span><span class="s0">(mapping &amp;&amp; mapping.originalLine === originalLine) {</span>
	          <span class="s0">mappings.push({</span>
	            <span class="s0">line: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedLine'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	            <span class="s0">column: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	            <span class="s0">lastColumn: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span>
	          <span class="s0">})</span><span class="s2">;</span>

	          <span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[++index]</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">var </span><span class="s0">originalColumn = mapping.originalColumn</span><span class="s2">;</span>

	        <span class="s5">// Iterate until either we run out of mappings, or we run into</span>
	        <span class="s5">// a mapping for a different line than the one we were searching for.</span>
	        <span class="s5">// Since mappings are sorted, this is guaranteed to find all mappings for</span>
	        <span class="s5">// the line we are searching for.</span>
	        <span class="s1">while </span><span class="s0">(mapping &amp;&amp;</span>
	               <span class="s0">mapping.originalLine === line &amp;&amp;</span>
	               <span class="s0">mapping.originalColumn == originalColumn) {</span>
	          <span class="s0">mappings.push({</span>
	            <span class="s0">line: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedLine'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	            <span class="s0">column: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	            <span class="s0">lastColumn: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span>
	          <span class="s0">})</span><span class="s2">;</span>

	          <span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[++index]</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s0">mappings</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s0">exports.SourceMapConsumer = SourceMapConsumer</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* A BasicSourceMapConsumer instance represents a parsed source map which we can</span>
	 <span class="s7">* query for information about the original file positions by giving it a file</span>
	 <span class="s7">* position in the generated source.</span>
	 <span class="s7">*</span>
	 <span class="s7">* The first parameter is the raw source map (either as a JSON string, or</span>
	 <span class="s7">* already parsed to an object). According to the spec, source maps have the</span>
	 <span class="s7">* following attributes:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - version: Which version of the source map spec this map is following.</span>
	 <span class="s7">*   - sources: An array of URLs to the original source files.</span>
	 <span class="s7">*   - names: An array of identifiers which can be referrenced by individual mappings.</span>
	 <span class="s7">*   - sourceRoot: Optional. The URL root from which all sources are relative.</span>
	 <span class="s7">*   - sourcesContent: Optional. An array of contents of the original source files.</span>
	 <span class="s7">*   - mappings: A string of base64 VLQs which contain the actual mappings.</span>
	 <span class="s7">*   - file: Optional. The generated file this source map is associated with.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Here is an example source map, taken from the source map spec[0]:</span>
	 <span class="s7">*</span>
	 <span class="s7">*     {</span>
	 <span class="s7">*       version : 3,</span>
	 <span class="s7">*       file: &quot;out.js&quot;,</span>
	 <span class="s7">*       sourceRoot : &quot;&quot;,</span>
	 <span class="s7">*       sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span>
	 <span class="s7">*       names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span>
	 <span class="s7">*       mappings: &quot;AA,AB;;ABCDE;&quot;</span>
	 <span class="s7">*     }</span>
	 <span class="s7">*</span>
	 <span class="s7">* The second parameter, if given, is a string whose value is the URL</span>
	 <span class="s7">* at which the source map was found.  This URL is used to compute the</span>
	 <span class="s7">* sources array.</span>
	 <span class="s7">*</span>
	 <span class="s7">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">BasicSourceMapConsumer(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s0">version = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'version'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sources = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'sources'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s5">// Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which</span>
	  <span class="s5">// requires the array) to play nice here.</span>
	  <span class="s1">var </span><span class="s0">names = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'names'</span><span class="s2">, </span><span class="s0">[])</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sourceRoot = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'sourceRoot'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sourcesContent = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'sourcesContent'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">mappings = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'mappings'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">file = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'file'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>

	  <span class="s5">// Once again, Sass deviates from the spec and supplies the version as a</span>
	  <span class="s5">// string rather than a number, so we use loose equality checking here.</span>
	  <span class="s1">if </span><span class="s0">(version != </span><span class="s1">this</span><span class="s0">._version) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Unsupported version: ' </span><span class="s0">+ version)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(sourceRoot) {</span>
	    <span class="s0">sourceRoot = util.normalize(sourceRoot)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s0">sources = sources</span>
	    <span class="s0">.map(String)</span>
	    <span class="s5">// Some source maps produce relative source paths like &quot;./foo.js&quot; instead of</span>
	    <span class="s5">// &quot;foo.js&quot;.  Normalize these first so that future comparisons will succeed.</span>
	    <span class="s5">// See bugzil.la/1090768.</span>
	    <span class="s0">.map(util.normalize)</span>
	    <span class="s5">// Always ensure that absolute sources are internally stored relative to</span>
	    <span class="s5">// the source root, if the source root is absolute. Not doing this would</span>
	    <span class="s5">// be particularly problematic when the source root is a prefix of the</span>
	    <span class="s5">// source (valid, but why??). See github issue #199 and bugzil.la/1188982.</span>
	    <span class="s0">.map(</span><span class="s1">function </span><span class="s0">(source) {</span>
	      <span class="s1">return </span><span class="s0">sourceRoot &amp;&amp; util.isAbsolute(sourceRoot) &amp;&amp; util.isAbsolute(source)</span>
	        <span class="s0">? util.relative(sourceRoot</span><span class="s2">, </span><span class="s0">source)</span>
	        <span class="s0">: source</span><span class="s2">;</span>
	    <span class="s0">})</span><span class="s2">;</span>

	  <span class="s5">// Pass `true` below to allow duplicate names and sources. While source maps</span>
	  <span class="s5">// are intended to be compressed and deduplicated, the TypeScript compiler</span>
	  <span class="s5">// sometimes generates source maps with duplicates in them. See Github issue</span>
	  <span class="s5">// #72 and bugzil.la/889492.</span>
	  <span class="s1">this</span><span class="s0">._names = ArraySet.fromArray(names.map(String)</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sources = ArraySet.fromArray(sources</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>

	  <span class="s1">this</span><span class="s0">._absoluteSources = </span><span class="s1">this</span><span class="s0">._sources.toArray().map(</span><span class="s1">function </span><span class="s0">(s) {</span>
	    <span class="s1">return </span><span class="s0">util.computeSourceURL(sourceRoot</span><span class="s2">, </span><span class="s0">s</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span><span class="s2">;</span>
	  <span class="s0">})</span><span class="s2">;</span>

	  <span class="s1">this</span><span class="s0">.sourceRoot = sourceRoot</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.sourcesContent = sourcesContent</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._mappings = mappings</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sourceMapURL = aSourceMapURL</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.file = file</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s0">BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype)</span><span class="s2">;</span>
	<span class="s0">BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Utility function to find the index of a source.  Returns -1 if not</span>
	 <span class="s7">* found.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype._findSourceIndex = </span><span class="s1">function</span><span class="s0">(aSource) {</span>
	  <span class="s1">var </span><span class="s0">relativeSource = aSource</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	    <span class="s0">relativeSource = util.relative(</span><span class="s1">this</span><span class="s0">.sourceRoot</span><span class="s2">, </span><span class="s0">relativeSource)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._sources.has(relativeSource)) {</span>
	    <span class="s1">return this</span><span class="s0">._sources.indexOf(relativeSource)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// Maybe aSource is an absolute URL as returned by |sources|.  In</span>
	  <span class="s5">// this case we can't simply undo the transform.</span>
	  <span class="s1">var </span><span class="s0">i</span><span class="s2">;</span>
	  <span class="s1">for </span><span class="s0">(i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._absoluteSources.length</span><span class="s2">; </span><span class="s0">++i) {</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._absoluteSources[i] == aSource) {</span>
	      <span class="s1">return </span><span class="s0">i</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Create a BasicSourceMapConsumer from a SourceMapGenerator.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">SourceMapGenerator aSourceMap</span>
	 <span class="s7">*        The source map that will be consumed.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">String aSourceMapURL</span>
	 <span class="s7">*        The URL at which the source map can be found (optional)</span>
	 <span class="s7">* </span><span class="s8">@returns </span><span class="s7">BasicSourceMapConsumer</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.fromSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_fromSourceMap(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	    <span class="s1">var </span><span class="s0">smc = Object.create(BasicSourceMapConsumer.prototype)</span><span class="s2">;</span>

	    <span class="s1">var </span><span class="s0">names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray()</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray()</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">smc.sourceRoot = aSourceMap._sourceRoot</span><span class="s2">;</span>
	    <span class="s0">smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray()</span><span class="s2">,</span>
	                                                            <span class="s0">smc.sourceRoot)</span><span class="s2">;</span>
	    <span class="s0">smc.file = aSourceMap._file</span><span class="s2">;</span>
	    <span class="s0">smc._sourceMapURL = aSourceMapURL</span><span class="s2">;</span>
	    <span class="s0">smc._absoluteSources = smc._sources.toArray().map(</span><span class="s1">function </span><span class="s0">(s) {</span>
	      <span class="s1">return </span><span class="s0">util.computeSourceURL(smc.sourceRoot</span><span class="s2">, </span><span class="s0">s</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span><span class="s2">;</span>
	    <span class="s0">})</span><span class="s2">;</span>

	    <span class="s5">// Because we are modifying the entries (by converting string sources and</span>
	    <span class="s5">// names to indices into the sources and names ArraySets), we have to make</span>
	    <span class="s5">// a copy of the entry or else bad things happen. Shared mutable state</span>
	    <span class="s5">// strikes again! See github issue #191.</span>

	    <span class="s1">var </span><span class="s0">generatedMappings = aSourceMap._mappings.toArray().slice()</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">destGeneratedMappings = smc.__generatedMappings = []</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">destOriginalMappings = smc.__originalMappings = []</span><span class="s2">;</span>

	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">length = generatedMappings.length</span><span class="s2">; </span><span class="s0">i &lt; length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">var </span><span class="s0">srcMapping = generatedMappings[i]</span><span class="s2">;</span>
	      <span class="s1">var </span><span class="s0">destMapping = </span><span class="s1">new </span><span class="s0">Mapping</span><span class="s2">;</span>
	      <span class="s0">destMapping.generatedLine = srcMapping.generatedLine</span><span class="s2">;</span>
	      <span class="s0">destMapping.generatedColumn = srcMapping.generatedColumn</span><span class="s2">;</span>

	      <span class="s1">if </span><span class="s0">(srcMapping.source) {</span>
	        <span class="s0">destMapping.source = sources.indexOf(srcMapping.source)</span><span class="s2">;</span>
	        <span class="s0">destMapping.originalLine = srcMapping.originalLine</span><span class="s2">;</span>
	        <span class="s0">destMapping.originalColumn = srcMapping.originalColumn</span><span class="s2">;</span>

	        <span class="s1">if </span><span class="s0">(srcMapping.name) {</span>
	          <span class="s0">destMapping.name = names.indexOf(srcMapping.name)</span><span class="s2">;</span>
	        <span class="s0">}</span>

	        <span class="s0">destOriginalMappings.push(destMapping)</span><span class="s2">;</span>
	      <span class="s0">}</span>

	      <span class="s0">destGeneratedMappings.push(destMapping)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s0">quickSort(smc.__originalMappings</span><span class="s2">, </span><span class="s0">util.compareByOriginalPositions)</span><span class="s2">;</span>

	    <span class="s1">return </span><span class="s0">smc</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype._version = </span><span class="s6">3</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* The list of original sources.</span>
	 <span class="s7">*/</span>
	<span class="s0">Object.defineProperty(BasicSourceMapConsumer.prototype</span><span class="s2">, </span><span class="s3">'sources'</span><span class="s2">, </span><span class="s0">{</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">return this</span><span class="s0">._absoluteSources.slice()</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">})</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Provide the JIT with a nice shape / hidden class.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">Mapping() {</span>
	  <span class="s1">this</span><span class="s0">.generatedLine = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.generatedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.source = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.originalLine = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.originalColumn = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.name = </span><span class="s1">null</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s7">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s7">* `this.__originalMappings` properties).</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_parseMappings(aStr</span><span class="s2">, </span><span class="s0">aSourceRoot) {</span>
	    <span class="s1">var </span><span class="s0">generatedLine = </span><span class="s6">1</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalLine = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousOriginalColumn = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousSource = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">previousName = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">length = aStr.length</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">index = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">cachedSegments = {}</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">temp = {}</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">originalMappings = []</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">generatedMappings = []</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">mapping</span><span class="s2">, </span><span class="s0">str</span><span class="s2">, </span><span class="s0">segment</span><span class="s2">, </span><span class="s0">end</span><span class="s2">, </span><span class="s0">value</span><span class="s2">;</span>

	    <span class="s1">while </span><span class="s0">(index &lt; length) {</span>
	      <span class="s1">if </span><span class="s0">(aStr.charAt(index) === </span><span class="s3">';'</span><span class="s0">) {</span>
	        <span class="s0">generatedLine++</span><span class="s2">;</span>
	        <span class="s0">index++</span><span class="s2">;</span>
	        <span class="s0">previousGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">else if </span><span class="s0">(aStr.charAt(index) === </span><span class="s3">','</span><span class="s0">) {</span>
	        <span class="s0">index++</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">mapping = </span><span class="s1">new </span><span class="s0">Mapping()</span><span class="s2">;</span>
	        <span class="s0">mapping.generatedLine = generatedLine</span><span class="s2">;</span>

	        <span class="s5">// Because each offset is encoded relative to the previous one,</span>
	        <span class="s5">// many segments often have the same encoding. We can exploit this</span>
	        <span class="s5">// fact by caching the parsed variable length fields of each segment,</span>
	        <span class="s5">// allowing us to avoid a second parse if we encounter the same</span>
	        <span class="s5">// segment again.</span>
	        <span class="s1">for </span><span class="s0">(end = index</span><span class="s2">; </span><span class="s0">end &lt; length</span><span class="s2">; </span><span class="s0">end++) {</span>
	          <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">._charIsMappingSeparator(aStr</span><span class="s2">, </span><span class="s0">end)) {</span>
	            <span class="s1">break</span><span class="s2">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>
	        <span class="s0">str = aStr.slice(index</span><span class="s2">, </span><span class="s0">end)</span><span class="s2">;</span>

	        <span class="s0">segment = cachedSegments[str]</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(segment) {</span>
	          <span class="s0">index += str.length</span><span class="s2">;</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s0">segment = []</span><span class="s2">;</span>
	          <span class="s1">while </span><span class="s0">(index &lt; end) {</span>
	            <span class="s0">base64VLQ.decode(aStr</span><span class="s2">, </span><span class="s0">index</span><span class="s2">, </span><span class="s0">temp)</span><span class="s2">;</span>
	            <span class="s0">value = temp.value</span><span class="s2">;</span>
	            <span class="s0">index = temp.rest</span><span class="s2">;</span>
	            <span class="s0">segment.push(value)</span><span class="s2">;</span>
	          <span class="s0">}</span>

	          <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s6">2</span><span class="s0">) {</span>
	            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Found a source, but no line and column'</span><span class="s0">)</span><span class="s2">;</span>
	          <span class="s0">}</span>

	          <span class="s1">if </span><span class="s0">(segment.length === </span><span class="s6">3</span><span class="s0">) {</span>
	            <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Found a source and line, but no column'</span><span class="s0">)</span><span class="s2">;</span>
	          <span class="s0">}</span>

	          <span class="s0">cachedSegments[str] = segment</span><span class="s2">;</span>
	        <span class="s0">}</span>

	        <span class="s5">// Generated column.</span>
	        <span class="s0">mapping.generatedColumn = previousGeneratedColumn + segment[</span><span class="s6">0</span><span class="s0">]</span><span class="s2">;</span>
	        <span class="s0">previousGeneratedColumn = mapping.generatedColumn</span><span class="s2">;</span>

	        <span class="s1">if </span><span class="s0">(segment.length &gt; </span><span class="s6">1</span><span class="s0">) {</span>
	          <span class="s5">// Original source.</span>
	          <span class="s0">mapping.source = previousSource + segment[</span><span class="s6">1</span><span class="s0">]</span><span class="s2">;</span>
	          <span class="s0">previousSource += segment[</span><span class="s6">1</span><span class="s0">]</span><span class="s2">;</span>

	          <span class="s5">// Original line.</span>
	          <span class="s0">mapping.originalLine = previousOriginalLine + segment[</span><span class="s6">2</span><span class="s0">]</span><span class="s2">;</span>
	          <span class="s0">previousOriginalLine = mapping.originalLine</span><span class="s2">;</span>
	          <span class="s5">// Lines are stored 0-based</span>
	          <span class="s0">mapping.originalLine += </span><span class="s6">1</span><span class="s2">;</span>

	          <span class="s5">// Original column.</span>
	          <span class="s0">mapping.originalColumn = previousOriginalColumn + segment[</span><span class="s6">3</span><span class="s0">]</span><span class="s2">;</span>
	          <span class="s0">previousOriginalColumn = mapping.originalColumn</span><span class="s2">;</span>

	          <span class="s1">if </span><span class="s0">(segment.length &gt; </span><span class="s6">4</span><span class="s0">) {</span>
	            <span class="s5">// Original name.</span>
	            <span class="s0">mapping.name = previousName + segment[</span><span class="s6">4</span><span class="s0">]</span><span class="s2">;</span>
	            <span class="s0">previousName += segment[</span><span class="s6">4</span><span class="s0">]</span><span class="s2">;</span>
	          <span class="s0">}</span>
	        <span class="s0">}</span>

	        <span class="s0">generatedMappings.push(mapping)</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">mapping.originalLine === </span><span class="s3">'number'</span><span class="s0">) {</span>
	          <span class="s0">originalMappings.push(mapping)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s0">quickSort(generatedMappings</span><span class="s2">, </span><span class="s0">util.compareByGeneratedPositionsDeflated)</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">.__generatedMappings = generatedMappings</span><span class="s2">;</span>

	    <span class="s0">quickSort(originalMappings</span><span class="s2">, </span><span class="s0">util.compareByOriginalPositions)</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">.__originalMappings = originalMappings</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Find the mapping that best matches the hypothetical &quot;needle&quot; mapping that</span>
	 <span class="s7">* we are searching for in the given &quot;haystack&quot; of mappings.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype._findMapping =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_findMapping(aNeedle</span><span class="s2">, </span><span class="s0">aMappings</span><span class="s2">, </span><span class="s0">aLineName</span><span class="s2">,</span>
	                                         <span class="s0">aColumnName</span><span class="s2">, </span><span class="s0">aComparator</span><span class="s2">, </span><span class="s0">aBias) {</span>
	    <span class="s5">// To return the position we are searching for, we must first find the</span>
	    <span class="s5">// mapping for the given position and then return the opposite position it</span>
	    <span class="s5">// points to. Because the mappings are sorted, we can use binary search to</span>
	    <span class="s5">// find the best mapping.</span>

	    <span class="s1">if </span><span class="s0">(aNeedle[aLineName] &lt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">'Line must be greater than or equal to 1, got '</span>
	                          <span class="s0">+ aNeedle[aLineName])</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(aNeedle[aColumnName] &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">throw new </span><span class="s0">TypeError(</span><span class="s3">'Column must be greater than or equal to 0, got '</span>
	                          <span class="s0">+ aNeedle[aColumnName])</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s0">binarySearch.search(aNeedle</span><span class="s2">, </span><span class="s0">aMappings</span><span class="s2">, </span><span class="s0">aComparator</span><span class="s2">, </span><span class="s0">aBias)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Compute the last column for each generated mapping. The last column is</span>
	 <span class="s7">* inclusive.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.computeColumnSpans =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_computeColumnSpans() {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">index = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">index &lt; </span><span class="s1">this</span><span class="s0">._generatedMappings.length</span><span class="s2">; </span><span class="s0">++index) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index]</span><span class="s2">;</span>

	      <span class="s5">// Mappings do not contain a field for the last generated columnt. We</span>
	      <span class="s5">// can come up with an optimistic estimate, however, by assuming that</span>
	      <span class="s5">// mappings are contiguous (i.e. given two consecutive mappings, the</span>
	      <span class="s5">// first mapping ends where the second one starts).</span>
	      <span class="s1">if </span><span class="s0">(index + </span><span class="s6">1 </span><span class="s0">&lt; </span><span class="s1">this</span><span class="s0">._generatedMappings.length) {</span>
	        <span class="s1">var </span><span class="s0">nextMapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index + </span><span class="s6">1</span><span class="s0">]</span><span class="s2">;</span>

	        <span class="s1">if </span><span class="s0">(mapping.generatedLine === nextMapping.generatedLine) {</span>
	          <span class="s0">mapping.lastGeneratedColumn = nextMapping.generatedColumn - </span><span class="s6">1</span><span class="s2">;</span>
	          <span class="s1">continue</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>

	      <span class="s5">// The last mapping for each line spans the entire line.</span>
	      <span class="s0">mapping.lastGeneratedColumn = Infinity</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the original source, line, and column information for the generated</span>
	 <span class="s7">* source's line and column positions provided. The only argument is an object</span>
	 <span class="s7">* with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source.  The line number</span>
	 <span class="s7">*     is 1-based.</span>
	 <span class="s7">*   - column: The column number in the generated source.  The column</span>
	 <span class="s7">*     number is 0-based.</span>
	 <span class="s7">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span>
	 <span class="s7">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s7">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s7">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s7">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an object is returned with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The original source file, or null.</span>
	 <span class="s7">*   - line: The line number in the original source, or null.  The</span>
	 <span class="s7">*     line number is 1-based.</span>
	 <span class="s7">*   - column: The column number in the original source, or null.  The</span>
	 <span class="s7">*     column number is 0-based.</span>
	 <span class="s7">*   - name: The original identifier, or null.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.originalPositionFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_originalPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">generatedLine: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">generatedColumn: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">}</span><span class="s2">;</span>

	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(</span>
	      <span class="s0">needle</span><span class="s2">,</span>
	      <span class="s1">this</span><span class="s0">._generatedMappings</span><span class="s2">,</span>
	      <span class="s3">&quot;generatedLine&quot;</span><span class="s2">,</span>
	      <span class="s3">&quot;generatedColumn&quot;</span><span class="s2">,</span>
	      <span class="s0">util.compareByGeneratedPositionsDeflated</span><span class="s2">,</span>
	      <span class="s0">util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'bias'</span><span class="s2">, </span><span class="s0">SourceMapConsumer.GREATEST_LOWER_BOUND)</span>
	    <span class="s0">)</span><span class="s2">;</span>

	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._generatedMappings[index]</span><span class="s2">;</span>

	      <span class="s1">if </span><span class="s0">(mapping.generatedLine === needle.generatedLine) {</span>
	        <span class="s1">var </span><span class="s0">source = util.getArg(mapping</span><span class="s2">, </span><span class="s3">'source'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(source !== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">source = </span><span class="s1">this</span><span class="s0">._sources.at(source)</span><span class="s2">;</span>
	          <span class="s0">source = util.computeSourceURL(</span><span class="s1">this</span><span class="s0">.sourceRoot</span><span class="s2">, </span><span class="s0">source</span><span class="s2">, </span><span class="s1">this</span><span class="s0">._sourceMapURL)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s1">var </span><span class="s0">name = util.getArg(mapping</span><span class="s2">, </span><span class="s3">'name'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(name !== </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">name = </span><span class="s1">this</span><span class="s0">._names.at(name)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s0">source: source</span><span class="s2">,</span>
	          <span class="s0">line: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'originalLine'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">column: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'originalColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">name: name</span>
	        <span class="s0">}</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">source: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">column: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">name: </span><span class="s1">null</span>
	    <span class="s0">}</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Return true if we have the source content for every source in the source</span>
	 <span class="s7">* map, false otherwise.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.hasContentsOfAllSources =</span>
	  <span class="s1">function </span><span class="s0">BasicSourceMapConsumer_hasContentsOfAllSources() {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.sourcesContent) {</span>
	      <span class="s1">return false</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">return this</span><span class="s0">.sourcesContent.length &gt;= </span><span class="s1">this</span><span class="s0">._sources.size() &amp;&amp;</span>
	      <span class="s0">!</span><span class="s1">this</span><span class="s0">.sourcesContent.some(</span><span class="s1">function </span><span class="s0">(sc) { </span><span class="s1">return </span><span class="s0">sc == </span><span class="s1">null</span><span class="s2">; </span><span class="s0">})</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the original source content. The only argument is the url of the</span>
	 <span class="s7">* original source file. Returns null if no original source content is</span>
	 <span class="s7">* available.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.sourceContentFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_sourceContentFor(aSource</span><span class="s2">, </span><span class="s0">nullOnMissing) {</span>
	    <span class="s1">if </span><span class="s0">(!</span><span class="s1">this</span><span class="s0">.sourcesContent) {</span>
	      <span class="s1">return null</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findSourceIndex(aSource)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">return this</span><span class="s0">.sourcesContent[index]</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s0">relativeSource = aSource</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s0">relativeSource = util.relative(</span><span class="s1">this</span><span class="s0">.sourceRoot</span><span class="s2">, </span><span class="s0">relativeSource)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s0">url</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.sourceRoot != </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; (url = util.urlParse(</span><span class="s1">this</span><span class="s0">.sourceRoot))) {</span>
	      <span class="s5">// XXX: file:// URIs and absolute paths lead to unexpected behavior for</span>
	      <span class="s5">// many users. We can help them out when they expect file:// URIs to</span>
	      <span class="s5">// behave like it would if they were running a local HTTP server. See</span>
	      <span class="s5">// https://bugzilla.mozilla.org/show_bug.cgi?id=885597.</span>
	      <span class="s1">var </span><span class="s0">fileUriAbsPath = relativeSource.replace(</span><span class="s6">/^file:\/\//</span><span class="s2">, </span><span class="s3">&quot;&quot;</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(url.scheme == </span><span class="s3">&quot;file&quot;</span>
	          <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">._sources.has(fileUriAbsPath)) {</span>
	        <span class="s1">return this</span><span class="s0">.sourcesContent[</span><span class="s1">this</span><span class="s0">._sources.indexOf(fileUriAbsPath)]</span>
	      <span class="s0">}</span>

	      <span class="s1">if </span><span class="s0">((!url.path || url.path == </span><span class="s3">&quot;/&quot;</span><span class="s0">)</span>
	          <span class="s0">&amp;&amp; </span><span class="s1">this</span><span class="s0">._sources.has(</span><span class="s3">&quot;/&quot; </span><span class="s0">+ relativeSource)) {</span>
	        <span class="s1">return this</span><span class="s0">.sourcesContent[</span><span class="s1">this</span><span class="s0">._sources.indexOf(</span><span class="s3">&quot;/&quot; </span><span class="s0">+ relativeSource)]</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s5">// This function is used recursively from</span>
	    <span class="s5">// IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we</span>
	    <span class="s5">// don't want to throw if we can't find the source - we just want to</span>
	    <span class="s5">// return null, so we provide a flag to exit gracefully.</span>
	    <span class="s1">if </span><span class="s0">(nullOnMissing) {</span>
	      <span class="s1">return null</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'&quot;' </span><span class="s0">+ relativeSource + </span><span class="s3">'&quot; is not in the SourceMap.'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the generated line and column information for the original source,</span>
	 <span class="s7">* line, and column positions provided. The only argument is an object with</span>
	 <span class="s7">* the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The filename of the original source.</span>
	 <span class="s7">*   - line: The line number in the original source.  The line number</span>
	 <span class="s7">*     is 1-based.</span>
	 <span class="s7">*   - column: The column number in the original source.  The column</span>
	 <span class="s7">*     number is 0-based.</span>
	 <span class="s7">*   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or</span>
	 <span class="s7">*     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s7">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s7">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s7">*     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an object is returned with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s7">*     line number is 1-based.</span>
	 <span class="s7">*   - column: The column number in the generated source, or null.</span>
	 <span class="s7">*     The column number is 0-based.</span>
	 <span class="s7">*/</span>
	<span class="s0">BasicSourceMapConsumer.prototype.generatedPositionFor =</span>
	  <span class="s1">function </span><span class="s0">SourceMapConsumer_generatedPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">source = util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'source'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">source = </span><span class="s1">this</span><span class="s0">._findSourceIndex(source)</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(source &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">column: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">lastColumn: </span><span class="s1">null</span>
	      <span class="s0">}</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">source: source</span><span class="s2">,</span>
	      <span class="s0">originalLine: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">originalColumn: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">}</span><span class="s2">;</span>

	    <span class="s1">var </span><span class="s0">index = </span><span class="s1">this</span><span class="s0">._findMapping(</span>
	      <span class="s0">needle</span><span class="s2">,</span>
	      <span class="s1">this</span><span class="s0">._originalMappings</span><span class="s2">,</span>
	      <span class="s3">&quot;originalLine&quot;</span><span class="s2">,</span>
	      <span class="s3">&quot;originalColumn&quot;</span><span class="s2">,</span>
	      <span class="s0">util.compareByOriginalPositions</span><span class="s2">,</span>
	      <span class="s0">util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'bias'</span><span class="s2">, </span><span class="s0">SourceMapConsumer.GREATEST_LOWER_BOUND)</span>
	    <span class="s0">)</span><span class="s2">;</span>

	    <span class="s1">if </span><span class="s0">(index &gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">var </span><span class="s0">mapping = </span><span class="s1">this</span><span class="s0">._originalMappings[index]</span><span class="s2">;</span>

	      <span class="s1">if </span><span class="s0">(mapping.source === needle.source) {</span>
	        <span class="s1">return </span><span class="s0">{</span>
	          <span class="s0">line: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedLine'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">column: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'generatedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">lastColumn: util.getArg(mapping</span><span class="s2">, </span><span class="s3">'lastGeneratedColumn'</span><span class="s2">, </span><span class="s1">null</span><span class="s0">)</span>
	        <span class="s0">}</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">column: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">lastColumn: </span><span class="s1">null</span>
	    <span class="s0">}</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s0">exports.BasicSourceMapConsumer = BasicSourceMapConsumer</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* An IndexedSourceMapConsumer instance represents a parsed source map which</span>
	 <span class="s7">* we can query for information. It differs from BasicSourceMapConsumer in</span>
	 <span class="s7">* that it takes &quot;indexed&quot; source maps (i.e. ones with a &quot;sections&quot; field) as</span>
	 <span class="s7">* input.</span>
	 <span class="s7">*</span>
	 <span class="s7">* The first parameter is a raw source map (either as a JSON string, or already</span>
	 <span class="s7">* parsed to an object). According to the spec for indexed source maps, they</span>
	 <span class="s7">* have the following attributes:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - version: Which version of the source map spec this map is following.</span>
	 <span class="s7">*   - file: Optional. The generated file this source map is associated with.</span>
	 <span class="s7">*   - sections: A list of section definitions.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Each value under the &quot;sections&quot; field has two fields:</span>
	 <span class="s7">*   - offset: The offset into the original specified at which this section</span>
	 <span class="s7">*       begins to apply, defined as an object with a &quot;line&quot; and &quot;column&quot;</span>
	 <span class="s7">*       field.</span>
	 <span class="s7">*   - map: A source map definition. This source map could also be indexed,</span>
	 <span class="s7">*       but doesn't have to be.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Instead of the &quot;map&quot; field, it's also possible to have a &quot;url&quot; field</span>
	 <span class="s7">* specifying a URL to retrieve a source map from, but that's currently</span>
	 <span class="s7">* unsupported.</span>
	 <span class="s7">*</span>
	 <span class="s7">* Here's an example source map, taken from the source map spec[0], but</span>
	 <span class="s7">* modified to omit a section which uses the &quot;url&quot; field.</span>
	 <span class="s7">*</span>
	 <span class="s7">*  {</span>
	 <span class="s7">*    version : 3,</span>
	 <span class="s7">*    file: &quot;app.js&quot;,</span>
	 <span class="s7">*    sections: [{</span>
	 <span class="s7">*      offset: {line:100, column:10},</span>
	 <span class="s7">*      map: {</span>
	 <span class="s7">*        version : 3,</span>
	 <span class="s7">*        file: &quot;section.js&quot;,</span>
	 <span class="s7">*        sources: [&quot;foo.js&quot;, &quot;bar.js&quot;],</span>
	 <span class="s7">*        names: [&quot;src&quot;, &quot;maps&quot;, &quot;are&quot;, &quot;fun&quot;],</span>
	 <span class="s7">*        mappings: &quot;AAAA,E;;ABCDE;&quot;</span>
	 <span class="s7">*      }</span>
	 <span class="s7">*    }],</span>
	 <span class="s7">*  }</span>
	 <span class="s7">*</span>
	 <span class="s7">* The second parameter, if given, is a string whose value is the URL</span>
	 <span class="s7">* at which the source map was found.  This URL is used to compute the</span>
	 <span class="s7">* sources array.</span>
	 <span class="s7">*</span>
	 <span class="s7">* [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">IndexedSourceMapConsumer(aSourceMap</span><span class="s2">, </span><span class="s0">aSourceMapURL) {</span>
	  <span class="s1">var </span><span class="s0">sourceMap = aSourceMap</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">aSourceMap === </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s0">sourceMap = util.parseSourceMapInput(aSourceMap)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s0">version = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'version'</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sections = util.getArg(sourceMap</span><span class="s2">, </span><span class="s3">'sections'</span><span class="s0">)</span><span class="s2">;</span>

	  <span class="s1">if </span><span class="s0">(version != </span><span class="s1">this</span><span class="s0">._version) {</span>
	    <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Unsupported version: ' </span><span class="s0">+ version)</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">this</span><span class="s0">._sources = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._names = </span><span class="s1">new </span><span class="s0">ArraySet()</span><span class="s2">;</span>

	  <span class="s1">var </span><span class="s0">lastOffset = {</span>
	    <span class="s0">line: -</span><span class="s6">1</span><span class="s2">,</span>
	    <span class="s0">column: </span><span class="s6">0</span>
	  <span class="s0">}</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">._sections = sections.map(</span><span class="s1">function </span><span class="s0">(s) {</span>
	    <span class="s1">if </span><span class="s0">(s.url) {</span>
	      <span class="s5">// The url field will require support for asynchronicity.</span>
	      <span class="s5">// See https://github.com/mozilla/source-map/issues/16</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Support for url field in sections not implemented.'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">var </span><span class="s0">offset = util.getArg(s</span><span class="s2">, </span><span class="s3">'offset'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">offsetLine = util.getArg(offset</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">offsetColumn = util.getArg(offset</span><span class="s2">, </span><span class="s3">'column'</span><span class="s0">)</span><span class="s2">;</span>

	    <span class="s1">if </span><span class="s0">(offsetLine &lt; lastOffset.line ||</span>
	        <span class="s0">(offsetLine === lastOffset.line &amp;&amp; offsetColumn &lt; lastOffset.column)) {</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'Section offsets must be ordered and non-overlapping.'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">lastOffset = offset</span><span class="s2">;</span>

	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">generatedOffset: {</span>
	        <span class="s5">// The offset fields are 0-based, but we use 1-based indices when</span>
	        <span class="s5">// encoding/decoding from VLQ.</span>
	        <span class="s0">generatedLine: offsetLine + </span><span class="s6">1</span><span class="s2">,</span>
	        <span class="s0">generatedColumn: offsetColumn + </span><span class="s6">1</span>
	      <span class="s0">}</span><span class="s2">,</span>
	      <span class="s0">consumer: </span><span class="s1">new </span><span class="s0">SourceMapConsumer(util.getArg(s</span><span class="s2">, </span><span class="s3">'map'</span><span class="s0">)</span><span class="s2">, </span><span class="s0">aSourceMapURL)</span>
	    <span class="s0">}</span>
	  <span class="s0">})</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s0">IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype)</span><span class="s2">;</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* The version of the source mapping spec that we are consuming.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype._version = </span><span class="s6">3</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* The list of original sources.</span>
	 <span class="s7">*/</span>
	<span class="s0">Object.defineProperty(IndexedSourceMapConsumer.prototype</span><span class="s2">, </span><span class="s3">'sources'</span><span class="s2">, </span><span class="s0">{</span>
	  <span class="s0">get: </span><span class="s1">function </span><span class="s0">() {</span>
	    <span class="s1">var </span><span class="s0">sources = []</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._sections.length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">j &lt; </span><span class="s1">this</span><span class="s0">._sections[i].consumer.sources.length</span><span class="s2">; </span><span class="s0">j++) {</span>
	        <span class="s0">sources.push(</span><span class="s1">this</span><span class="s0">._sections[i].consumer.sources[j])</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s1">return </span><span class="s0">sources</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">})</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the original source, line, and column information for the generated</span>
	 <span class="s7">* source's line and column positions provided. The only argument is an object</span>
	 <span class="s7">* with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source.  The line number</span>
	 <span class="s7">*     is 1-based.</span>
	 <span class="s7">*   - column: The column number in the generated source.  The column</span>
	 <span class="s7">*     number is 0-based.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an object is returned with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The original source file, or null.</span>
	 <span class="s7">*   - line: The line number in the original source, or null.  The</span>
	 <span class="s7">*     line number is 1-based.</span>
	 <span class="s7">*   - column: The column number in the original source, or null.  The</span>
	 <span class="s7">*     column number is 0-based.</span>
	 <span class="s7">*   - name: The original identifier, or null.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.originalPositionFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_originalPositionFor(aArgs) {</span>
	    <span class="s1">var </span><span class="s0">needle = {</span>
	      <span class="s0">generatedLine: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'line'</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">generatedColumn: util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'column'</span><span class="s0">)</span>
	    <span class="s0">}</span><span class="s2">;</span>

	    <span class="s5">// Find the section containing the generated position we're trying to map</span>
	    <span class="s5">// to an original position.</span>
	    <span class="s1">var </span><span class="s0">sectionIndex = binarySearch.search(needle</span><span class="s2">, </span><span class="s1">this</span><span class="s0">._sections</span><span class="s2">,</span>
	      <span class="s1">function</span><span class="s0">(needle</span><span class="s2">, </span><span class="s0">section) {</span>
	        <span class="s1">var </span><span class="s0">cmp = needle.generatedLine - section.generatedOffset.generatedLine</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(cmp) {</span>
	          <span class="s1">return </span><span class="s0">cmp</span><span class="s2">;</span>
	        <span class="s0">}</span>

	        <span class="s1">return </span><span class="s0">(needle.generatedColumn -</span>
	                <span class="s0">section.generatedOffset.generatedColumn)</span><span class="s2">;</span>
	      <span class="s0">})</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[sectionIndex]</span><span class="s2">;</span>

	    <span class="s1">if </span><span class="s0">(!section) {</span>
	      <span class="s1">return </span><span class="s0">{</span>
	        <span class="s0">source: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">column: </span><span class="s1">null</span><span class="s2">,</span>
	        <span class="s0">name: </span><span class="s1">null</span>
	      <span class="s0">}</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s0">section.consumer.originalPositionFor({</span>
	      <span class="s0">line: needle.generatedLine -</span>
	        <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">column: needle.generatedColumn -</span>
	        <span class="s0">(section.generatedOffset.generatedLine === needle.generatedLine</span>
	         <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s6">1</span>
	         <span class="s0">: </span><span class="s6">0</span><span class="s0">)</span><span class="s2">,</span>
	      <span class="s0">bias: aArgs.bias</span>
	    <span class="s0">})</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Return true if we have the source content for every source in the source</span>
	 <span class="s7">* map, false otherwise.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_hasContentsOfAllSources() {</span>
	    <span class="s1">return this</span><span class="s0">._sections.every(</span><span class="s1">function </span><span class="s0">(s) {</span>
	      <span class="s1">return </span><span class="s0">s.consumer.hasContentsOfAllSources()</span><span class="s2">;</span>
	    <span class="s0">})</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the original source content. The only argument is the url of the</span>
	 <span class="s7">* original source file. Returns null if no original source content is</span>
	 <span class="s7">* available.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.sourceContentFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_sourceContentFor(aSource</span><span class="s2">, </span><span class="s0">nullOnMissing) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._sections.length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i]</span><span class="s2">;</span>

	      <span class="s1">var </span><span class="s0">content = section.consumer.sourceContentFor(aSource</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(content) {</span>
	        <span class="s1">return </span><span class="s0">content</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	    <span class="s1">if </span><span class="s0">(nullOnMissing) {</span>
	      <span class="s1">return null</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">throw new </span><span class="s0">Error(</span><span class="s3">'&quot;' </span><span class="s0">+ aSource + </span><span class="s3">'&quot; is not in the SourceMap.'</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the generated line and column information for the original source,</span>
	 <span class="s7">* line, and column positions provided. The only argument is an object with</span>
	 <span class="s7">* the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - source: The filename of the original source.</span>
	 <span class="s7">*   - line: The line number in the original source.  The line number</span>
	 <span class="s7">*     is 1-based.</span>
	 <span class="s7">*   - column: The column number in the original source.  The column</span>
	 <span class="s7">*     number is 0-based.</span>
	 <span class="s7">*</span>
	 <span class="s7">* and an object is returned with the following properties:</span>
	 <span class="s7">*</span>
	 <span class="s7">*   - line: The line number in the generated source, or null.  The</span>
	 <span class="s7">*     line number is 1-based. </span>
	 <span class="s7">*   - column: The column number in the generated source, or null.</span>
	 <span class="s7">*     The column number is 0-based.</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype.generatedPositionFor =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_generatedPositionFor(aArgs) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._sections.length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i]</span><span class="s2">;</span>

	      <span class="s5">// Only consider this section if the requested source is in the list of</span>
	      <span class="s5">// sources of the consumer.</span>
	      <span class="s1">if </span><span class="s0">(section.consumer._findSourceIndex(util.getArg(aArgs</span><span class="s2">, </span><span class="s3">'source'</span><span class="s0">)) === -</span><span class="s6">1</span><span class="s0">) {</span>
	        <span class="s1">continue</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">var </span><span class="s0">generatedPosition = section.consumer.generatedPositionFor(aArgs)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(generatedPosition) {</span>
	        <span class="s1">var </span><span class="s0">ret = {</span>
	          <span class="s0">line: generatedPosition.line +</span>
	            <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">column: generatedPosition.column +</span>
	            <span class="s0">(section.generatedOffset.generatedLine === generatedPosition.line</span>
	             <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s6">1</span>
	             <span class="s0">: </span><span class="s6">0</span><span class="s0">)</span>
	        <span class="s0">}</span><span class="s2">;</span>
	        <span class="s1">return </span><span class="s0">ret</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s1">return </span><span class="s0">{</span>
	      <span class="s0">line: </span><span class="s1">null</span><span class="s2">,</span>
	      <span class="s0">column: </span><span class="s1">null</span>
	    <span class="s0">}</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Parse the mappings in a string in to a data structure which we can easily</span>
	 <span class="s7">* query (the ordered arrays in the `this.__generatedMappings` and</span>
	 <span class="s7">* `this.__originalMappings` properties).</span>
	 <span class="s7">*/</span>
	<span class="s0">IndexedSourceMapConsumer.prototype._parseMappings =</span>
	  <span class="s1">function </span><span class="s0">IndexedSourceMapConsumer_parseMappings(aStr</span><span class="s2">, </span><span class="s0">aSourceRoot) {</span>
	    <span class="s1">this</span><span class="s0">.__generatedMappings = []</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">.__originalMappings = []</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; </span><span class="s1">this</span><span class="s0">._sections.length</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">var </span><span class="s0">section = </span><span class="s1">this</span><span class="s0">._sections[i]</span><span class="s2">;</span>
	      <span class="s1">var </span><span class="s0">sectionMappings = section.consumer._generatedMappings</span><span class="s2">;</span>
	      <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">j &lt; sectionMappings.length</span><span class="s2">; </span><span class="s0">j++) {</span>
	        <span class="s1">var </span><span class="s0">mapping = sectionMappings[j]</span><span class="s2">;</span>

	        <span class="s1">var </span><span class="s0">source = section.consumer._sources.at(mapping.source)</span><span class="s2">;</span>
	        <span class="s0">source = util.computeSourceURL(section.consumer.sourceRoot</span><span class="s2">, </span><span class="s0">source</span><span class="s2">, </span><span class="s1">this</span><span class="s0">._sourceMapURL)</span><span class="s2">;</span>
	        <span class="s1">this</span><span class="s0">._sources.add(source)</span><span class="s2">;</span>
	        <span class="s0">source = </span><span class="s1">this</span><span class="s0">._sources.indexOf(source)</span><span class="s2">;</span>

	        <span class="s1">var </span><span class="s0">name = </span><span class="s1">null</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(mapping.name) {</span>
	          <span class="s0">name = section.consumer._names.at(mapping.name)</span><span class="s2">;</span>
	          <span class="s1">this</span><span class="s0">._names.add(name)</span><span class="s2">;</span>
	          <span class="s0">name = </span><span class="s1">this</span><span class="s0">._names.indexOf(name)</span><span class="s2">;</span>
	        <span class="s0">}</span>

	        <span class="s5">// The mappings coming from the consumer for the section have</span>
	        <span class="s5">// generated positions relative to the start of the section, so we</span>
	        <span class="s5">// need to offset them to be relative to the start of the concatenated</span>
	        <span class="s5">// generated file.</span>
	        <span class="s1">var </span><span class="s0">adjustedMapping = {</span>
	          <span class="s0">source: source</span><span class="s2">,</span>
	          <span class="s0">generatedLine: mapping.generatedLine +</span>
	            <span class="s0">(section.generatedOffset.generatedLine - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">generatedColumn: mapping.generatedColumn +</span>
	            <span class="s0">(section.generatedOffset.generatedLine === mapping.generatedLine</span>
	            <span class="s0">? section.generatedOffset.generatedColumn - </span><span class="s6">1</span>
	            <span class="s0">: </span><span class="s6">0</span><span class="s0">)</span><span class="s2">,</span>
	          <span class="s0">originalLine: mapping.originalLine</span><span class="s2">,</span>
	          <span class="s0">originalColumn: mapping.originalColumn</span><span class="s2">,</span>
	          <span class="s0">name: name</span>
	        <span class="s0">}</span><span class="s2">;</span>

	        <span class="s1">this</span><span class="s0">.__generatedMappings.push(adjustedMapping)</span><span class="s2">;</span>
	        <span class="s1">if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">adjustedMapping.originalLine === </span><span class="s3">'number'</span><span class="s0">) {</span>
	          <span class="s1">this</span><span class="s0">.__originalMappings.push(adjustedMapping)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s0">quickSort(</span><span class="s1">this</span><span class="s0">.__generatedMappings</span><span class="s2">, </span><span class="s0">util.compareByGeneratedPositionsDeflated)</span><span class="s2">;</span>
	    <span class="s0">quickSort(</span><span class="s1">this</span><span class="s0">.__originalMappings</span><span class="s2">, </span><span class="s0">util.compareByOriginalPositions)</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s0">exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 8 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s0">exports.GREATEST_LOWER_BOUND = </span><span class="s6">1</span><span class="s2">;</span>
	<span class="s0">exports.LEAST_UPPER_BOUND = </span><span class="s6">2</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Recursive implementation of binary search.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aLow Indices here and lower do not contain the needle.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aHigh Indices here and higher do not contain the needle.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aNeedle The element being searched for.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aHaystack The non-empty array being searched.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aCompare Function which takes two elements and returns -1, 0, or 1.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span>
	 <span class="s7">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s7">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s7">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">recursiveSearch(aLow</span><span class="s2">, </span><span class="s0">aHigh</span><span class="s2">, </span><span class="s0">aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">, </span><span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias) {</span>
	  <span class="s5">// This function terminates when one of the following is true:</span>
	  <span class="s5">//</span>
	  <span class="s5">//   1. We find the exact element we are looking for.</span>
	  <span class="s5">//</span>
	  <span class="s5">//   2. We did not find the exact element, but we can return the index of</span>
	  <span class="s5">//      the next-closest element.</span>
	  <span class="s5">//</span>
	  <span class="s5">//   3. We did not find the exact element, and there is no next-closest</span>
	  <span class="s5">//      element than the one we are searching for, so we return -1.</span>
	  <span class="s1">var </span><span class="s0">mid = Math.floor((aHigh - aLow) / </span><span class="s6">2</span><span class="s0">) + aLow</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">cmp = aCompare(aNeedle</span><span class="s2">, </span><span class="s0">aHaystack[mid]</span><span class="s2">, </span><span class="s1">true</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(cmp === </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s5">// Found the element we are looking for.</span>
	    <span class="s1">return </span><span class="s0">mid</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(cmp &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s5">// Our needle is greater than aHaystack[mid].</span>
	    <span class="s1">if </span><span class="s0">(aHigh - mid &gt; </span><span class="s6">1</span><span class="s0">) {</span>
	      <span class="s5">// The element is in the upper half.</span>
	      <span class="s1">return </span><span class="s0">recursiveSearch(mid</span><span class="s2">, </span><span class="s0">aHigh</span><span class="s2">, </span><span class="s0">aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">, </span><span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s5">// The exact needle element was not found in this haystack. Determine if</span>
	    <span class="s5">// we are in termination case (3) or (2) and return the appropriate thing.</span>
	    <span class="s1">if </span><span class="s0">(aBias == exports.LEAST_UPPER_BOUND) {</span>
	      <span class="s1">return </span><span class="s0">aHigh &lt; aHaystack.length ? aHigh : -</span><span class="s6">1</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">return </span><span class="s0">mid</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s5">// Our needle is less than aHaystack[mid].</span>
	    <span class="s1">if </span><span class="s0">(mid - aLow &gt; </span><span class="s6">1</span><span class="s0">) {</span>
	      <span class="s5">// The element is in the lower half.</span>
	      <span class="s1">return </span><span class="s0">recursiveSearch(aLow</span><span class="s2">, </span><span class="s0">mid</span><span class="s2">, </span><span class="s0">aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">, </span><span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias)</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s5">// we are in termination case (3) or (2) and return the appropriate thing.</span>
	    <span class="s1">if </span><span class="s0">(aBias == exports.LEAST_UPPER_BOUND) {</span>
	      <span class="s1">return </span><span class="s0">mid</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">return </span><span class="s0">aLow &lt; </span><span class="s6">0 </span><span class="s0">? -</span><span class="s6">1 </span><span class="s0">: aLow</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* This is an implementation of binary search which will always try and return</span>
	 <span class="s7">* the index of the closest element if there is no exact hit. This is because</span>
	 <span class="s7">* mappings between original and generated line/col pairs are single points,</span>
	 <span class="s7">* and there is an implicit region between each of them, so a miss just means</span>
	 <span class="s7">* that you aren't on the very start of a region.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aNeedle The element you are looking for.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aHaystack The array that is being searched.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aCompare A function which takes the needle and an element in the</span>
	 <span class="s7">*     array and returns -1, 0, or 1 depending on whether the needle is less</span>
	 <span class="s7">*     than, equal to, or greater than the element, respectively.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or</span>
	 <span class="s7">*     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the</span>
	 <span class="s7">*     closest element that is smaller than or greater than the one we are</span>
	 <span class="s7">*     searching for, respectively, if the exact element cannot be found.</span>
	 <span class="s7">*     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.search = </span><span class="s1">function </span><span class="s0">search(aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">, </span><span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias) {</span>
	  <span class="s1">if </span><span class="s0">(aHaystack.length === </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">var </span><span class="s0">index = recursiveSearch(-</span><span class="s6">1</span><span class="s2">, </span><span class="s0">aHaystack.length</span><span class="s2">, </span><span class="s0">aNeedle</span><span class="s2">, </span><span class="s0">aHaystack</span><span class="s2">,</span>
	                              <span class="s0">aCompare</span><span class="s2">, </span><span class="s0">aBias || exports.GREATEST_LOWER_BOUND)</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(index &lt; </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">return </span><span class="s0">-</span><span class="s6">1</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s5">// We have found either the exact element, or the next-closest element than</span>
	  <span class="s5">// the one we are searching for. However, there may be more than one such</span>
	  <span class="s5">// element. Make sure we always return the smallest of these.</span>
	  <span class="s1">while </span><span class="s0">(index - </span><span class="s6">1 </span><span class="s0">&gt;= </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(aCompare(aHaystack[index]</span><span class="s2">, </span><span class="s0">aHaystack[index - </span><span class="s6">1</span><span class="s0">]</span><span class="s2">, </span><span class="s1">true</span><span class="s0">) !== </span><span class="s6">0</span><span class="s0">) {</span>
	      <span class="s1">break</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">--index</span><span class="s2">;</span>
	  <span class="s0">}</span>

	  <span class="s1">return </span><span class="s0">index</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 9 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s5">// It turns out that some (most?) JavaScript engines don't self-host</span>
	<span class="s5">// `Array.prototype.sort`. This makes sense because C++ will likely remain</span>
	<span class="s5">// faster than JS when doing raw CPU-intensive sorting. However, when using a</span>
	<span class="s5">// custom comparator function, calling back and forth between the VM's C++ and</span>
	<span class="s5">// JIT'd JS is rather slow *and* loses JIT type information, resulting in</span>
	<span class="s5">// worse generated code for the comparator function than would be optimal. In</span>
	<span class="s5">// fact, when sorting with a comparator, these costs outweigh the benefits of</span>
	<span class="s5">// sorting in C++. By using our own JS-implemented Quick Sort (below), we get</span>
	<span class="s5">// a ~3500ms mean speed-up in `bench/bench.html`.</span>

	<span class="s7">/**</span>
	 <span class="s7">* Swap the elements indexed by `x` and `y` in the array `ary`.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Array} ary</span>
	 <span class="s7">*        The array.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} x</span>
	 <span class="s7">*        The index of the first item.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} y</span>
	 <span class="s7">*        The index of the second item.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">swap(ary</span><span class="s2">, </span><span class="s0">x</span><span class="s2">, </span><span class="s0">y) {</span>
	  <span class="s1">var </span><span class="s0">temp = ary[x]</span><span class="s2">;</span>
	  <span class="s0">ary[x] = ary[y]</span><span class="s2">;</span>
	  <span class="s0">ary[y] = temp</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns a random integer within the range `low .. high` inclusive.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} low</span>
	 <span class="s7">*        The lower bound on the range.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} high</span>
	 <span class="s7">*        The upper bound on the range.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">randomIntInRange(low</span><span class="s2">, </span><span class="s0">high) {</span>
	  <span class="s1">return </span><span class="s0">Math.round(low + (Math.random() * (high - low)))</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* The Quick Sort algorithm.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Array} ary</span>
	 <span class="s7">*        An array to sort.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{function} comparator</span>
	 <span class="s7">*        Function to use to compare two items.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} p</span>
	 <span class="s7">*        Start index of the array</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Number} r</span>
	 <span class="s7">*        End index of the array</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">doQuickSort(ary</span><span class="s2">, </span><span class="s0">comparator</span><span class="s2">, </span><span class="s0">p</span><span class="s2">, </span><span class="s0">r) {</span>
	  <span class="s5">// If our lower bound is less than our upper bound, we (1) partition the</span>
	  <span class="s5">// array into two pieces and (2) recurse on each half. If it is not, this is</span>
	  <span class="s5">// the empty array and our base case.</span>

	  <span class="s1">if </span><span class="s0">(p &lt; r) {</span>
	    <span class="s5">// (1) Partitioning.</span>
	    <span class="s5">//</span>
	    <span class="s5">// The partitioning chooses a pivot between `p` and `r` and moves all</span>
	    <span class="s5">// elements that are less than or equal to the pivot to the before it, and</span>
	    <span class="s5">// all the elements that are greater than it after it. The effect is that</span>
	    <span class="s5">// once partition is done, the pivot is in the exact place it will be when</span>
	    <span class="s5">// the array is put in sorted order, and it will not need to be moved</span>
	    <span class="s5">// again. This runs in O(n) time.</span>

	    <span class="s5">// Always choose a random pivot so that an input array which is reverse</span>
	    <span class="s5">// sorted does not cause O(n^2) running time.</span>
	    <span class="s1">var </span><span class="s0">pivotIndex = randomIntInRange(p</span><span class="s2">, </span><span class="s0">r)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">i = p - </span><span class="s6">1</span><span class="s2">;</span>

	    <span class="s0">swap(ary</span><span class="s2">, </span><span class="s0">pivotIndex</span><span class="s2">, </span><span class="s0">r)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">pivot = ary[r]</span><span class="s2">;</span>

	    <span class="s5">// Immediately after `j` is incremented in this loop, the following hold</span>
	    <span class="s5">// true:</span>
	    <span class="s5">//</span>
	    <span class="s5">//   * Every element in `ary[p .. i]` is less than or equal to the pivot.</span>
	    <span class="s5">//</span>
	    <span class="s5">//   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">j = p</span><span class="s2">; </span><span class="s0">j &lt; r</span><span class="s2">; </span><span class="s0">j++) {</span>
	      <span class="s1">if </span><span class="s0">(comparator(ary[j]</span><span class="s2">, </span><span class="s0">pivot) &lt;= </span><span class="s6">0</span><span class="s0">) {</span>
	        <span class="s0">i += </span><span class="s6">1</span><span class="s2">;</span>
	        <span class="s0">swap(ary</span><span class="s2">, </span><span class="s0">i</span><span class="s2">, </span><span class="s0">j)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s0">swap(ary</span><span class="s2">, </span><span class="s0">i + </span><span class="s6">1</span><span class="s2">, </span><span class="s0">j)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">q = i + </span><span class="s6">1</span><span class="s2">;</span>

	    <span class="s5">// (2) Recurse on each half.</span>

	    <span class="s0">doQuickSort(ary</span><span class="s2">, </span><span class="s0">comparator</span><span class="s2">, </span><span class="s0">p</span><span class="s2">, </span><span class="s0">q - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s0">doQuickSort(ary</span><span class="s2">, </span><span class="s0">comparator</span><span class="s2">, </span><span class="s0">q + </span><span class="s6">1</span><span class="s2">, </span><span class="s0">r)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Sort the given array in-place with the given comparator function.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{Array} ary</span>
	 <span class="s7">*        An array to sort.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">{function} comparator</span>
	 <span class="s7">*        Function to use to compare two items.</span>
	 <span class="s7">*/</span>
	<span class="s0">exports.quickSort = </span><span class="s1">function </span><span class="s0">(ary</span><span class="s2">, </span><span class="s0">comparator) {</span>
	  <span class="s0">doQuickSort(ary</span><span class="s2">, </span><span class="s0">comparator</span><span class="s2">, </span><span class="s6">0</span><span class="s2">, </span><span class="s0">ary.length - </span><span class="s6">1</span><span class="s0">)</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span><span class="s2">,</span>
<span class="s4">/* 10 */</span>
<span class="s4">/***/ </span><span class="s0">(</span><span class="s1">function</span><span class="s0">(module</span><span class="s2">, </span><span class="s0">exports</span><span class="s2">, </span><span class="s0">__webpack_require__) {</span>

	<span class="s4">/* -*- Mode: js; js-indent-level: 2; -*- */</span>
	<span class="s4">/* 
     * Copyright 2011 Mozilla Foundation and contributors 
     * Licensed under the New BSD license. See LICENSE or: 
     * http://opensource.org/licenses/BSD-3-Clause 
     */</span>

	<span class="s1">var </span><span class="s0">SourceMapGenerator = __webpack_require__(</span><span class="s6">1</span><span class="s0">).SourceMapGenerator</span><span class="s2">;</span>
	<span class="s1">var </span><span class="s0">util = __webpack_require__(</span><span class="s6">4</span><span class="s0">)</span><span class="s2">;</span>

	<span class="s5">// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other</span>
	<span class="s5">// operating systems these days (capturing the result).</span>
	<span class="s1">var </span><span class="s0">REGEX_NEWLINE = </span><span class="s6">/(\r?\n)/</span><span class="s2">;</span>

	<span class="s5">// Newline character code for charCodeAt() comparisons</span>
	<span class="s1">var </span><span class="s0">NEWLINE_CODE = </span><span class="s6">10</span><span class="s2">;</span>

	<span class="s5">// Private symbol for identifying `SourceNode`s when multiple versions of</span>
	<span class="s5">// the source-map library are loaded. This MUST NOT CHANGE across</span>
	<span class="s5">// versions!</span>
	<span class="s1">var </span><span class="s0">isSourceNode = </span><span class="s3">&quot;$$$isSourceNode$$$&quot;</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* SourceNodes provide a way to abstract over interpolating/concatenating</span>
	 <span class="s7">* snippets of generated JavaScript source code while maintaining the line and</span>
	 <span class="s7">* column information associated with the original source code.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aLine The original line number.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aColumn The original column number.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSource The original source's filename.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aChunks Optional. An array of strings which are snippets of</span>
	 <span class="s7">*        generated JS, or other SourceNodes.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aName The original identifier.</span>
	 <span class="s7">*/</span>
	<span class="s1">function </span><span class="s0">SourceNode(aLine</span><span class="s2">, </span><span class="s0">aColumn</span><span class="s2">, </span><span class="s0">aSource</span><span class="s2">, </span><span class="s0">aChunks</span><span class="s2">, </span><span class="s0">aName) {</span>
	  <span class="s1">this</span><span class="s0">.children = []</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.sourceContents = {}</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.line = aLine == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aLine</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.column = aColumn == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aColumn</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.source = aSource == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aSource</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.name = aName == </span><span class="s1">null </span><span class="s0">? </span><span class="s1">null </span><span class="s0">: aName</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">[isSourceNode] = </span><span class="s1">true</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(aChunks != </span><span class="s1">null</span><span class="s0">) </span><span class="s1">this</span><span class="s0">.add(aChunks)</span><span class="s2">;</span>
	<span class="s0">}</span>

	<span class="s7">/**</span>
	 <span class="s7">* Creates a SourceNode from generated code and a SourceMapConsumer.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aGeneratedCode The generated code</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceMapConsumer The SourceMap for the generated code</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aRelativePath Optional. The path that relative sources in the</span>
	 <span class="s7">*        SourceMapConsumer should be relative to.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.fromStringWithSourceMap =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_fromStringWithSourceMap(aGeneratedCode</span><span class="s2">, </span><span class="s0">aSourceMapConsumer</span><span class="s2">, </span><span class="s0">aRelativePath) {</span>
	    <span class="s5">// The SourceNode we want to fill with the generated code</span>
	    <span class="s5">// and the SourceMap</span>
	    <span class="s1">var </span><span class="s0">node = </span><span class="s1">new </span><span class="s0">SourceNode()</span><span class="s2">;</span>

	    <span class="s5">// All even indices of this array are one line of the generated code,</span>
	    <span class="s5">// while all odd indices are the newlines between two adjacent lines</span>
	    <span class="s5">// (since `REGEX_NEWLINE` captures its match).</span>
	    <span class="s5">// Processed fragments are accessed by calling `shiftNextLine`.</span>
	    <span class="s1">var </span><span class="s0">remainingLines = aGeneratedCode.split(REGEX_NEWLINE)</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">remainingLinesIndex = </span><span class="s6">0</span><span class="s2">;</span>
	    <span class="s1">var </span><span class="s0">shiftNextLine = </span><span class="s1">function</span><span class="s0">() {</span>
	      <span class="s1">var </span><span class="s0">lineContents = getNextLine()</span><span class="s2">;</span>
	      <span class="s5">// The last line of a file might not have a newline.</span>
	      <span class="s1">var </span><span class="s0">newLine = getNextLine() || </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
	      <span class="s1">return </span><span class="s0">lineContents + newLine</span><span class="s2">;</span>

	      <span class="s1">function </span><span class="s0">getNextLine() {</span>
	        <span class="s1">return </span><span class="s0">remainingLinesIndex &lt; remainingLines.length ?</span>
	            <span class="s0">remainingLines[remainingLinesIndex++] : undefined</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span><span class="s2">;</span>

	    <span class="s5">// We need to remember the position of &quot;remainingLines&quot;</span>
	    <span class="s1">var </span><span class="s0">lastGeneratedLine = </span><span class="s6">1</span><span class="s2">, </span><span class="s0">lastGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>

	    <span class="s5">// The generate SourceNodes we need a code range.</span>
	    <span class="s5">// To extract it current and last mapping is used.</span>
	    <span class="s5">// Here we store the last mapping.</span>
	    <span class="s1">var </span><span class="s0">lastMapping = </span><span class="s1">null</span><span class="s2">;</span>

	    <span class="s0">aSourceMapConsumer.eachMapping(</span><span class="s1">function </span><span class="s0">(mapping) {</span>
	      <span class="s1">if </span><span class="s0">(lastMapping !== </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s5">// We add the code from &quot;lastMapping&quot; to &quot;mapping&quot;:</span>
	        <span class="s5">// First check if there is a new line in between.</span>
	        <span class="s1">if </span><span class="s0">(lastGeneratedLine &lt; mapping.generatedLine) {</span>
	          <span class="s5">// Associate first line with &quot;lastMapping&quot;</span>
	          <span class="s0">addMappingWithCode(lastMapping</span><span class="s2">, </span><span class="s0">shiftNextLine())</span><span class="s2">;</span>
	          <span class="s0">lastGeneratedLine++</span><span class="s2">;</span>
	          <span class="s0">lastGeneratedColumn = </span><span class="s6">0</span><span class="s2">;</span>
	          <span class="s5">// The remaining code is added without mapping</span>
	        <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	          <span class="s5">// There is no new line in between.</span>
	          <span class="s5">// Associate the code between &quot;lastGeneratedColumn&quot; and</span>
	          <span class="s5">// &quot;mapping.generatedColumn&quot; with &quot;lastMapping&quot;</span>
	          <span class="s1">var </span><span class="s0">nextLine = remainingLines[remainingLinesIndex] || </span><span class="s3">''</span><span class="s2">;</span>
	          <span class="s1">var </span><span class="s0">code = nextLine.substr(</span><span class="s6">0</span><span class="s2">, </span><span class="s0">mapping.generatedColumn -</span>
	                                        <span class="s0">lastGeneratedColumn)</span><span class="s2">;</span>
	          <span class="s0">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -</span>
	                                              <span class="s0">lastGeneratedColumn)</span><span class="s2">;</span>
	          <span class="s0">lastGeneratedColumn = mapping.generatedColumn</span><span class="s2">;</span>
	          <span class="s0">addMappingWithCode(lastMapping</span><span class="s2">, </span><span class="s0">code)</span><span class="s2">;</span>
	          <span class="s5">// No more remaining code, continue</span>
	          <span class="s0">lastMapping = mapping</span><span class="s2">;</span>
	          <span class="s1">return</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">}</span>
	      <span class="s5">// We add the generated code until the first mapping</span>
	      <span class="s5">// to the SourceNode without any mapping.</span>
	      <span class="s5">// Each line is added as separate string.</span>
	      <span class="s1">while </span><span class="s0">(lastGeneratedLine &lt; mapping.generatedLine) {</span>
	        <span class="s0">node.add(shiftNextLine())</span><span class="s2">;</span>
	        <span class="s0">lastGeneratedLine++</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s1">if </span><span class="s0">(lastGeneratedColumn &lt; mapping.generatedColumn) {</span>
	        <span class="s1">var </span><span class="s0">nextLine = remainingLines[remainingLinesIndex] || </span><span class="s3">''</span><span class="s2">;</span>
	        <span class="s0">node.add(nextLine.substr(</span><span class="s6">0</span><span class="s2">, </span><span class="s0">mapping.generatedColumn))</span><span class="s2">;</span>
	        <span class="s0">remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn)</span><span class="s2">;</span>
	        <span class="s0">lastGeneratedColumn = mapping.generatedColumn</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s0">lastMapping = mapping</span><span class="s2">;</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	    <span class="s5">// We have processed all mappings.</span>
	    <span class="s1">if </span><span class="s0">(remainingLinesIndex &lt; remainingLines.length) {</span>
	      <span class="s1">if </span><span class="s0">(lastMapping) {</span>
	        <span class="s5">// Associate the remaining code in the current line with &quot;lastMapping&quot;</span>
	        <span class="s0">addMappingWithCode(lastMapping</span><span class="s2">, </span><span class="s0">shiftNextLine())</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s5">// and add the remaining lines without any mapping</span>
	      <span class="s0">node.add(remainingLines.splice(remainingLinesIndex).join(</span><span class="s3">&quot;&quot;</span><span class="s0">))</span><span class="s2">;</span>
	    <span class="s0">}</span>

	    <span class="s5">// Copy sourcesContent into SourceNode</span>
	    <span class="s0">aSourceMapConsumer.sources.forEach(</span><span class="s1">function </span><span class="s0">(sourceFile) {</span>
	      <span class="s1">var </span><span class="s0">content = aSourceMapConsumer.sourceContentFor(sourceFile)</span><span class="s2">;</span>
	      <span class="s1">if </span><span class="s0">(content != </span><span class="s1">null</span><span class="s0">) {</span>
	        <span class="s1">if </span><span class="s0">(aRelativePath != </span><span class="s1">null</span><span class="s0">) {</span>
	          <span class="s0">sourceFile = util.join(aRelativePath</span><span class="s2">, </span><span class="s0">sourceFile)</span><span class="s2">;</span>
	        <span class="s0">}</span>
	        <span class="s0">node.setSourceContent(sourceFile</span><span class="s2">, </span><span class="s0">content)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">})</span><span class="s2">;</span>

	    <span class="s1">return </span><span class="s0">node</span><span class="s2">;</span>

	    <span class="s1">function </span><span class="s0">addMappingWithCode(mapping</span><span class="s2">, </span><span class="s0">code) {</span>
	      <span class="s1">if </span><span class="s0">(mapping === </span><span class="s1">null </span><span class="s0">|| mapping.source === undefined) {</span>
	        <span class="s0">node.add(code)</span><span class="s2">;</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s1">var </span><span class="s0">source = aRelativePath</span>
	          <span class="s0">? util.join(aRelativePath</span><span class="s2">, </span><span class="s0">mapping.source)</span>
	          <span class="s0">: mapping.source</span><span class="s2">;</span>
	        <span class="s0">node.add(</span><span class="s1">new </span><span class="s0">SourceNode(mapping.originalLine</span><span class="s2">,</span>
	                                <span class="s0">mapping.originalColumn</span><span class="s2">,</span>
	                                <span class="s0">source</span><span class="s2">,</span>
	                                <span class="s0">code</span><span class="s2">,</span>
	                                <span class="s0">mapping.name))</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Add a chunk of generated JS to this source node.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aChunk A string snippet of generated JS code, another instance of</span>
	 <span class="s7">*        SourceNode, or an array where each member is one of those things.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.add = </span><span class="s1">function </span><span class="s0">SourceNode_add(aChunk) {</span>
	  <span class="s1">if </span><span class="s0">(Array.isArray(aChunk)) {</span>
	    <span class="s0">aChunk.forEach(</span><span class="s1">function </span><span class="s0">(chunk) {</span>
	      <span class="s1">this</span><span class="s0">.add(chunk)</span><span class="s2">;</span>
	    <span class="s0">}</span><span class="s2">, </span><span class="s1">this</span><span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(aChunk[isSourceNode] || </span><span class="s1">typeof </span><span class="s0">aChunk === </span><span class="s3">&quot;string&quot;</span><span class="s0">) {</span>
	    <span class="s1">if </span><span class="s0">(aChunk) {</span>
	      <span class="s1">this</span><span class="s0">.children.push(aChunk)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">TypeError(</span>
	      <span class="s3">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ aChunk</span>
	    <span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Add a chunk of generated JS to the beginning of this source node.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aChunk A string snippet of generated JS code, another instance of</span>
	 <span class="s7">*        SourceNode, or an array where each member is one of those things.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.prepend = </span><span class="s1">function </span><span class="s0">SourceNode_prepend(aChunk) {</span>
	  <span class="s1">if </span><span class="s0">(Array.isArray(aChunk)) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = aChunk.length-</span><span class="s6">1</span><span class="s2">; </span><span class="s0">i &gt;= </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i--) {</span>
	      <span class="s1">this</span><span class="s0">.prepend(aChunk[i])</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(aChunk[isSourceNode] || </span><span class="s1">typeof </span><span class="s0">aChunk === </span><span class="s3">&quot;string&quot;</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.children.unshift(aChunk)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">throw new </span><span class="s0">TypeError(</span>
	      <span class="s3">&quot;Expected a SourceNode, string, or an array of SourceNodes and strings. Got &quot; </span><span class="s0">+ aChunk</span>
	    <span class="s0">)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Walk over the tree of JS snippets in this node and its children. The</span>
	 <span class="s7">* walking function is called once for each snippet of JS and is passed that</span>
	 <span class="s7">* snippet and the its original associated source's line/column location.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aFn The traversal function.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.walk = </span><span class="s1">function </span><span class="s0">SourceNode_walk(aFn) {</span>
	  <span class="s1">var </span><span class="s0">chunk</span><span class="s2">;</span>
	  <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = </span><span class="s1">this</span><span class="s0">.children.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	    <span class="s0">chunk = </span><span class="s1">this</span><span class="s0">.children[i]</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(chunk[isSourceNode]) {</span>
	      <span class="s0">chunk.walk(aFn)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">else </span><span class="s0">{</span>
	      <span class="s1">if </span><span class="s0">(chunk !== </span><span class="s3">''</span><span class="s0">) {</span>
	        <span class="s0">aFn(chunk</span><span class="s2">, </span><span class="s0">{ source: </span><span class="s1">this</span><span class="s0">.source</span><span class="s2">,</span>
	                     <span class="s0">line: </span><span class="s1">this</span><span class="s0">.line</span><span class="s2">,</span>
	                     <span class="s0">column: </span><span class="s1">this</span><span class="s0">.column</span><span class="s2">,</span>
	                     <span class="s0">name: </span><span class="s1">this</span><span class="s0">.name })</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between</span>
	 <span class="s7">* each of `this.children`.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSep The separator.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.join = </span><span class="s1">function </span><span class="s0">SourceNode_join(aSep) {</span>
	  <span class="s1">var </span><span class="s0">newChildren</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">i</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">len = </span><span class="s1">this</span><span class="s0">.children.length</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(len &gt; </span><span class="s6">0</span><span class="s0">) {</span>
	    <span class="s0">newChildren = []</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(i = </span><span class="s6">0</span><span class="s2">; </span><span class="s0">i &lt; len-</span><span class="s6">1</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s0">newChildren.push(</span><span class="s1">this</span><span class="s0">.children[i])</span><span class="s2">;</span>
	      <span class="s0">newChildren.push(aSep)</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s0">newChildren.push(</span><span class="s1">this</span><span class="s0">.children[i])</span><span class="s2">;</span>
	    <span class="s1">this</span><span class="s0">.children = newChildren</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Call String.prototype.replace on the very right-most source snippet. Useful</span>
	 <span class="s7">* for trimming whitespace from the end of a source node, etc.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aPattern The pattern to replace.</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aReplacement The thing to replace the pattern with.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.replaceRight = </span><span class="s1">function </span><span class="s0">SourceNode_replaceRight(aPattern</span><span class="s2">, </span><span class="s0">aReplacement) {</span>
	  <span class="s1">var </span><span class="s0">lastChild = </span><span class="s1">this</span><span class="s0">.children[</span><span class="s1">this</span><span class="s0">.children.length - </span><span class="s6">1</span><span class="s0">]</span><span class="s2">;</span>
	  <span class="s1">if </span><span class="s0">(lastChild[isSourceNode]) {</span>
	    <span class="s0">lastChild.replaceRight(aPattern</span><span class="s2">, </span><span class="s0">aReplacement)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else if </span><span class="s0">(</span><span class="s1">typeof </span><span class="s0">lastChild === </span><span class="s3">'string'</span><span class="s0">) {</span>
	    <span class="s1">this</span><span class="s0">.children[</span><span class="s1">this</span><span class="s0">.children.length - </span><span class="s6">1</span><span class="s0">] = lastChild.replace(aPattern</span><span class="s2">, </span><span class="s0">aReplacement)</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">else </span><span class="s0">{</span>
	    <span class="s1">this</span><span class="s0">.children.push(</span><span class="s3">''</span><span class="s0">.replace(aPattern</span><span class="s2">, </span><span class="s0">aReplacement))</span><span class="s2">;</span>
	  <span class="s0">}</span>
	  <span class="s1">return this</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Set the source content for a source file. This will be added to the SourceMapGenerator</span>
	 <span class="s7">* in the sourcesContent field.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceFile The filename of the source file</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aSourceContent The content of the source file</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.setSourceContent =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_setSourceContent(aSourceFile</span><span class="s2">, </span><span class="s0">aSourceContent) {</span>
	    <span class="s1">this</span><span class="s0">.sourceContents[util.toSetString(aSourceFile)] = aSourceContent</span><span class="s2">;</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Walk over the tree of SourceNodes. The walking function is called for each</span>
	 <span class="s7">* source file content and is passed the filename and source content.</span>
	 <span class="s7">*</span>
	 <span class="s7">* </span><span class="s8">@param </span><span class="s7">aFn The traversal function.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.walkSourceContents =</span>
	  <span class="s1">function </span><span class="s0">SourceNode_walkSourceContents(aFn) {</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = </span><span class="s1">this</span><span class="s0">.children.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s1">if </span><span class="s0">(</span><span class="s1">this</span><span class="s0">.children[i][isSourceNode]) {</span>
	        <span class="s1">this</span><span class="s0">.children[i].walkSourceContents(aFn)</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>

	    <span class="s1">var </span><span class="s0">sources = Object.keys(</span><span class="s1">this</span><span class="s0">.sourceContents)</span><span class="s2">;</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">i = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">len = sources.length</span><span class="s2">; </span><span class="s0">i &lt; len</span><span class="s2">; </span><span class="s0">i++) {</span>
	      <span class="s0">aFn(util.fromSetString(sources[i])</span><span class="s2">, </span><span class="s1">this</span><span class="s0">.sourceContents[sources[i]])</span><span class="s2">;</span>
	    <span class="s0">}</span>
	  <span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Return the string representation of this source node. Walks over the tree</span>
	 <span class="s7">* and concatenates all the various snippets together to one string.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.toString = </span><span class="s1">function </span><span class="s0">SourceNode_toString() {</span>
	  <span class="s1">var </span><span class="s0">str = </span><span class="s3">&quot;&quot;</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.walk(</span><span class="s1">function </span><span class="s0">(chunk) {</span>
	    <span class="s0">str += chunk</span><span class="s2">;</span>
	  <span class="s0">})</span><span class="s2">;</span>
	  <span class="s1">return </span><span class="s0">str</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s7">/**</span>
	 <span class="s7">* Returns the string representation of this source node along with a source</span>
	 <span class="s7">* map.</span>
	 <span class="s7">*/</span>
	<span class="s0">SourceNode.prototype.toStringWithSourceMap = </span><span class="s1">function </span><span class="s0">SourceNode_toStringWithSourceMap(aArgs) {</span>
	  <span class="s1">var </span><span class="s0">generated = {</span>
	    <span class="s0">code: </span><span class="s3">&quot;&quot;</span><span class="s2">,</span>
	    <span class="s0">line: </span><span class="s6">1</span><span class="s2">,</span>
	    <span class="s0">column: </span><span class="s6">0</span>
	  <span class="s0">}</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">map = </span><span class="s1">new </span><span class="s0">SourceMapGenerator(aArgs)</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalLine = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalColumn = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">var </span><span class="s0">lastOriginalName = </span><span class="s1">null</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.walk(</span><span class="s1">function </span><span class="s0">(chunk</span><span class="s2">, </span><span class="s0">original) {</span>
	    <span class="s0">generated.code += chunk</span><span class="s2">;</span>
	    <span class="s1">if </span><span class="s0">(original.source !== </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; original.line !== </span><span class="s1">null</span>
	        <span class="s0">&amp;&amp; original.column !== </span><span class="s1">null</span><span class="s0">) {</span>
	      <span class="s1">if</span><span class="s0">(lastOriginalSource !== original.source</span>
	         <span class="s0">|| lastOriginalLine !== original.line</span>
	         <span class="s0">|| lastOriginalColumn !== original.column</span>
	         <span class="s0">|| lastOriginalName !== original.name) {</span>
	        <span class="s0">map.addMapping({</span>
	          <span class="s0">source: original.source</span><span class="s2">,</span>
	          <span class="s0">original: {</span>
	            <span class="s0">line: original.line</span><span class="s2">,</span>
	            <span class="s0">column: original.column</span>
	          <span class="s0">}</span><span class="s2">,</span>
	          <span class="s0">generated: {</span>
	            <span class="s0">line: generated.line</span><span class="s2">,</span>
	            <span class="s0">column: generated.column</span>
	          <span class="s0">}</span><span class="s2">,</span>
	          <span class="s0">name: original.name</span>
	        <span class="s0">})</span><span class="s2">;</span>
	      <span class="s0">}</span>
	      <span class="s0">lastOriginalSource = original.source</span><span class="s2">;</span>
	      <span class="s0">lastOriginalLine = original.line</span><span class="s2">;</span>
	      <span class="s0">lastOriginalColumn = original.column</span><span class="s2">;</span>
	      <span class="s0">lastOriginalName = original.name</span><span class="s2">;</span>
	      <span class="s0">sourceMappingActive = </span><span class="s1">true</span><span class="s2">;</span>
	    <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sourceMappingActive) {</span>
	      <span class="s0">map.addMapping({</span>
	        <span class="s0">generated: {</span>
	          <span class="s0">line: generated.line</span><span class="s2">,</span>
	          <span class="s0">column: generated.column</span>
	        <span class="s0">}</span>
	      <span class="s0">})</span><span class="s2">;</span>
	      <span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s2">;</span>
	      <span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s2">;</span>
	    <span class="s0">}</span>
	    <span class="s1">for </span><span class="s0">(</span><span class="s1">var </span><span class="s0">idx = </span><span class="s6">0</span><span class="s2">, </span><span class="s0">length = chunk.length</span><span class="s2">; </span><span class="s0">idx &lt; length</span><span class="s2">; </span><span class="s0">idx++) {</span>
	      <span class="s1">if </span><span class="s0">(chunk.charCodeAt(idx) === NEWLINE_CODE) {</span>
	        <span class="s0">generated.line++</span><span class="s2">;</span>
	        <span class="s0">generated.column = </span><span class="s6">0</span><span class="s2">;</span>
	        <span class="s5">// Mappings end at eol</span>
	        <span class="s1">if </span><span class="s0">(idx + </span><span class="s6">1 </span><span class="s0">=== length) {</span>
	          <span class="s0">lastOriginalSource = </span><span class="s1">null</span><span class="s2">;</span>
	          <span class="s0">sourceMappingActive = </span><span class="s1">false</span><span class="s2">;</span>
	        <span class="s0">} </span><span class="s1">else if </span><span class="s0">(sourceMappingActive) {</span>
	          <span class="s0">map.addMapping({</span>
	            <span class="s0">source: original.source</span><span class="s2">,</span>
	            <span class="s0">original: {</span>
	              <span class="s0">line: original.line</span><span class="s2">,</span>
	              <span class="s0">column: original.column</span>
	            <span class="s0">}</span><span class="s2">,</span>
	            <span class="s0">generated: {</span>
	              <span class="s0">line: generated.line</span><span class="s2">,</span>
	              <span class="s0">column: generated.column</span>
	            <span class="s0">}</span><span class="s2">,</span>
	            <span class="s0">name: original.name</span>
	          <span class="s0">})</span><span class="s2">;</span>
	        <span class="s0">}</span>
	      <span class="s0">} </span><span class="s1">else </span><span class="s0">{</span>
	        <span class="s0">generated.column++</span><span class="s2">;</span>
	      <span class="s0">}</span>
	    <span class="s0">}</span>
	  <span class="s0">})</span><span class="s2">;</span>
	  <span class="s1">this</span><span class="s0">.walkSourceContents(</span><span class="s1">function </span><span class="s0">(sourceFile</span><span class="s2">, </span><span class="s0">sourceContent) {</span>
	    <span class="s0">map.setSourceContent(sourceFile</span><span class="s2">, </span><span class="s0">sourceContent)</span><span class="s2">;</span>
	  <span class="s0">})</span><span class="s2">;</span>

	  <span class="s1">return </span><span class="s0">{ code: generated.code</span><span class="s2">, </span><span class="s0">map: map }</span><span class="s2">;</span>
	<span class="s0">}</span><span class="s2">;</span>

	<span class="s0">exports.SourceNode = SourceNode</span><span class="s2">;</span>


<span class="s4">/***/ </span><span class="s0">})</span>
<span class="s4">/******/ </span><span class="s0">])</span>
<span class="s0">})</span><span class="s2">;</span>
<span class="s2">;</span></pre>
</body>
</html>