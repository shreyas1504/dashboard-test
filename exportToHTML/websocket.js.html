<html>
<head>
<title>websocket.js</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #8a8a8a;}
.s1 { color: #cfd2d5;}
.s2 { color: #8ea765;}
.s3 { color: #cc7832;}
.s4 { color: #cc7832; font-weight: bold;}
.s5 { color: #6897bb;}
.s6 { color: #8a8a8a; font-style: italic;}
.s7 { color: #8a8a8a; font-weight: bold; font-style: italic;}
.s8 { color: #808080;}
</style>
</head>
<body bgcolor="#1c1c1c">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
websocket.js</font>
</center></td></tr></table>
<pre><span class="s0">/* eslint no-unused-vars: [&quot;error&quot;, { &quot;varsIgnorePattern&quot;: &quot;^Readable$&quot; }] */</span>

<span class="s2">'use strict'</span><span class="s3">;</span>

<span class="s4">const </span><span class="s1">EventEmitter = require(</span><span class="s2">'events'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">https = require(</span><span class="s2">'https'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">http = require(</span><span class="s2">'http'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">net = require(</span><span class="s2">'net'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">tls = require(</span><span class="s2">'tls'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">{ randomBytes</span><span class="s3">, </span><span class="s1">createHash } = require(</span><span class="s2">'crypto'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">{ Readable } = require(</span><span class="s2">'stream'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">{ URL } = require(</span><span class="s2">'url'</span><span class="s1">)</span><span class="s3">;</span>

<span class="s4">const </span><span class="s1">PerMessageDeflate = require(</span><span class="s2">'./permessage-deflate'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">Receiver = require(</span><span class="s2">'./receiver'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">Sender = require(</span><span class="s2">'./sender'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">{</span>
  <span class="s1">BINARY_TYPES</span><span class="s3">,</span>
  <span class="s1">EMPTY_BUFFER</span><span class="s3">,</span>
  <span class="s1">GUID</span><span class="s3">,</span>
  <span class="s1">kStatusCode</span><span class="s3">,</span>
  <span class="s1">kWebSocket</span><span class="s3">,</span>
  <span class="s1">NOOP</span>
<span class="s1">} = require(</span><span class="s2">'./constants'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">{ addEventListener</span><span class="s3">, </span><span class="s1">removeEventListener } = require(</span><span class="s2">'./event-target'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">{ format</span><span class="s3">, </span><span class="s1">parse } = require(</span><span class="s2">'./extension'</span><span class="s1">)</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">{ toBuffer } = require(</span><span class="s2">'./buffer-util'</span><span class="s1">)</span><span class="s3">;</span>

<span class="s4">const </span><span class="s1">readyStates = [</span><span class="s2">'CONNECTING'</span><span class="s3">, </span><span class="s2">'OPEN'</span><span class="s3">, </span><span class="s2">'CLOSING'</span><span class="s3">, </span><span class="s2">'CLOSED'</span><span class="s1">]</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">protocolVersions = [</span><span class="s5">8</span><span class="s3">, </span><span class="s5">13</span><span class="s1">]</span><span class="s3">;</span>
<span class="s4">const </span><span class="s1">closeTimeout = </span><span class="s5">30 </span><span class="s1">* </span><span class="s5">1000</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* Class representing a WebSocket.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@extends </span><span class="s6">EventEmitter</span>
 <span class="s6">*/</span>
<span class="s4">class </span><span class="s1">WebSocket </span><span class="s4">extends </span><span class="s1">EventEmitter {</span>
  <span class="s6">/**</span>
   <span class="s6">* Create a new `WebSocket`.</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{(String|URL)} address The URL to which to connect</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{(String|String[])} [protocols] The subprotocols</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Object} [options] Connection options</span>
   <span class="s6">*/</span>
  <span class="s1">constructor(address</span><span class="s3">, </span><span class="s1">protocols</span><span class="s3">, </span><span class="s1">options) {</span>
    <span class="s4">super</span><span class="s1">()</span><span class="s3">;</span>

    <span class="s4">this</span><span class="s1">._binaryType = BINARY_TYPES[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._closeCode = </span><span class="s5">1006</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._closeFrameReceived = </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._closeFrameSent = </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._closeMessage = </span><span class="s2">''</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._closeTimer = </span><span class="s4">null</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._extensions = {}</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._protocol = </span><span class="s2">''</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._readyState = WebSocket.CONNECTING</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._receiver = </span><span class="s4">null</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._sender = </span><span class="s4">null</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._socket = </span><span class="s4">null</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(address !== </span><span class="s4">null</span><span class="s1">) {</span>
      <span class="s4">this</span><span class="s1">._bufferedAmount = </span><span class="s5">0</span><span class="s3">;</span>
      <span class="s4">this</span><span class="s1">._isServer = </span><span class="s4">false</span><span class="s3">;</span>
      <span class="s4">this</span><span class="s1">._redirects = </span><span class="s5">0</span><span class="s3">;</span>

      <span class="s4">if </span><span class="s1">(Array.isArray(protocols)) {</span>
        <span class="s1">protocols = protocols.join(</span><span class="s2">', '</span><span class="s1">)</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">protocols === </span><span class="s2">'object' </span><span class="s1">&amp;&amp; protocols !== </span><span class="s4">null</span><span class="s1">) {</span>
        <span class="s1">options = protocols</span><span class="s3">;</span>
        <span class="s1">protocols = undefined</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s1">initAsClient(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">protocols</span><span class="s3">, </span><span class="s1">options)</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s4">this</span><span class="s1">._isServer = </span><span class="s4">true</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* This deviates from the WHATWG interface since ws doesn't support the</span>
   <span class="s6">* required default &quot;blob&quot; type (instead we define a custom &quot;nodebuffer&quot;</span>
   <span class="s6">* type).</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{String}</span>
   <span class="s6">*/</span>
  <span class="s1">get binaryType() {</span>
    <span class="s4">return this</span><span class="s1">._binaryType</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">set binaryType(type) {</span>
    <span class="s4">if </span><span class="s1">(!BINARY_TYPES.includes(type)) </span><span class="s4">return</span><span class="s3">;</span>

    <span class="s4">this</span><span class="s1">._binaryType = type</span><span class="s3">;</span>

    <span class="s8">//</span>
    <span class="s8">// Allow to change `binaryType` on the fly.</span>
    <span class="s8">//</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">._receiver) </span><span class="s4">this</span><span class="s1">._receiver._binaryType = type</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{Number}</span>
   <span class="s6">*/</span>
  <span class="s1">get bufferedAmount() {</span>
    <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">._socket) </span><span class="s4">return this</span><span class="s1">._bufferedAmount</span><span class="s3">;</span>

    <span class="s4">return this</span><span class="s1">._socket._writableState.length + </span><span class="s4">this</span><span class="s1">._sender._bufferedBytes</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{String}</span>
   <span class="s6">*/</span>
  <span class="s1">get extensions() {</span>
    <span class="s4">return </span><span class="s1">Object.keys(</span><span class="s4">this</span><span class="s1">._extensions).join()</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{Function}</span>
   <span class="s6">*/</span>
  <span class="s0">/* istanbul ignore next */</span>
  <span class="s1">get onclose() {</span>
    <span class="s4">return </span><span class="s1">undefined</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s0">/* istanbul ignore next */</span>
  <span class="s1">set onclose(listener) {}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{Function}</span>
   <span class="s6">*/</span>
  <span class="s0">/* istanbul ignore next */</span>
  <span class="s1">get onerror() {</span>
    <span class="s4">return </span><span class="s1">undefined</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s0">/* istanbul ignore next */</span>
  <span class="s1">set onerror(listener) {}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{Function}</span>
   <span class="s6">*/</span>
  <span class="s0">/* istanbul ignore next */</span>
  <span class="s1">get onopen() {</span>
    <span class="s4">return </span><span class="s1">undefined</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s0">/* istanbul ignore next */</span>
  <span class="s1">set onopen(listener) {}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{Function}</span>
   <span class="s6">*/</span>
  <span class="s0">/* istanbul ignore next */</span>
  <span class="s1">get onmessage() {</span>
    <span class="s4">return </span><span class="s1">undefined</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s0">/* istanbul ignore next */</span>
  <span class="s1">set onmessage(listener) {}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{String}</span>
   <span class="s6">*/</span>
  <span class="s1">get protocol() {</span>
    <span class="s4">return this</span><span class="s1">._protocol</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{Number}</span>
   <span class="s6">*/</span>
  <span class="s1">get readyState() {</span>
    <span class="s4">return this</span><span class="s1">._readyState</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* </span><span class="s7">@type </span><span class="s6">{String}</span>
   <span class="s6">*/</span>
  <span class="s1">get url() {</span>
    <span class="s4">return this</span><span class="s1">._url</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* Set up the socket and the internal resources.</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{(net.Socket|tls.Socket)} socket The network socket between the</span>
   <span class="s6">*     server and client</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Buffer} head The first packet of the upgraded stream</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} [maxPayload=0] The maximum allowed message size</span>
   <span class="s6">* </span><span class="s7">@private</span>
   <span class="s6">*/</span>
  <span class="s1">setSocket(socket</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">maxPayload) {</span>
    <span class="s4">const </span><span class="s1">receiver = </span><span class="s4">new </span><span class="s1">Receiver(</span>
      <span class="s4">this</span><span class="s1">.binaryType</span><span class="s3">,</span>
      <span class="s4">this</span><span class="s1">._extensions</span><span class="s3">,</span>
      <span class="s4">this</span><span class="s1">._isServer</span><span class="s3">,</span>
      <span class="s1">maxPayload</span>
    <span class="s1">)</span><span class="s3">;</span>

    <span class="s4">this</span><span class="s1">._sender = </span><span class="s4">new </span><span class="s1">Sender(socket</span><span class="s3">, </span><span class="s4">this</span><span class="s1">._extensions)</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._receiver = receiver</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._socket = socket</span><span class="s3">;</span>

    <span class="s1">receiver[kWebSocket] = </span><span class="s4">this</span><span class="s3">;</span>
    <span class="s1">socket[kWebSocket] = </span><span class="s4">this</span><span class="s3">;</span>

    <span class="s1">receiver.on(</span><span class="s2">'conclude'</span><span class="s3">, </span><span class="s1">receiverOnConclude)</span><span class="s3">;</span>
    <span class="s1">receiver.on(</span><span class="s2">'drain'</span><span class="s3">, </span><span class="s1">receiverOnDrain)</span><span class="s3">;</span>
    <span class="s1">receiver.on(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">receiverOnError)</span><span class="s3">;</span>
    <span class="s1">receiver.on(</span><span class="s2">'message'</span><span class="s3">, </span><span class="s1">receiverOnMessage)</span><span class="s3">;</span>
    <span class="s1">receiver.on(</span><span class="s2">'ping'</span><span class="s3">, </span><span class="s1">receiverOnPing)</span><span class="s3">;</span>
    <span class="s1">receiver.on(</span><span class="s2">'pong'</span><span class="s3">, </span><span class="s1">receiverOnPong)</span><span class="s3">;</span>

    <span class="s1">socket.setTimeout(</span><span class="s5">0</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s1">socket.setNoDelay()</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(head.length &gt; </span><span class="s5">0</span><span class="s1">) socket.unshift(head)</span><span class="s3">;</span>

    <span class="s1">socket.on(</span><span class="s2">'close'</span><span class="s3">, </span><span class="s1">socketOnClose)</span><span class="s3">;</span>
    <span class="s1">socket.on(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s1">socketOnData)</span><span class="s3">;</span>
    <span class="s1">socket.on(</span><span class="s2">'end'</span><span class="s3">, </span><span class="s1">socketOnEnd)</span><span class="s3">;</span>
    <span class="s1">socket.on(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">socketOnError)</span><span class="s3">;</span>

    <span class="s4">this</span><span class="s1">._readyState = WebSocket.OPEN</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">.emit(</span><span class="s2">'open'</span><span class="s1">)</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* Emit the `'close'` event.</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@private</span>
   <span class="s6">*/</span>
  <span class="s1">emitClose() {</span>
    <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">._socket) {</span>
      <span class="s4">this</span><span class="s1">._readyState = WebSocket.CLOSED</span><span class="s3">;</span>
      <span class="s4">this</span><span class="s1">.emit(</span><span class="s2">'close'</span><span class="s3">, </span><span class="s4">this</span><span class="s1">._closeCode</span><span class="s3">, </span><span class="s4">this</span><span class="s1">._closeMessage)</span><span class="s3">;</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">._extensions[PerMessageDeflate.extensionName]) {</span>
      <span class="s4">this</span><span class="s1">._extensions[PerMessageDeflate.extensionName].cleanup()</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">this</span><span class="s1">._receiver.removeAllListeners()</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._readyState = WebSocket.CLOSED</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">.emit(</span><span class="s2">'close'</span><span class="s3">, </span><span class="s4">this</span><span class="s1">._closeCode</span><span class="s3">, </span><span class="s4">this</span><span class="s1">._closeMessage)</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* Start a closing handshake.</span>
   <span class="s6">*</span>
   <span class="s6">*          +----------+   +-----------+   +----------+</span>
   <span class="s6">*     - - -|ws.close()|--&gt;|close frame|--&gt;|ws.close()|- - -</span>
   <span class="s6">*    |     +----------+   +-----------+   +----------+     |</span>
   <span class="s6">*          +----------+   +-----------+         |</span>
   <span class="s6">* CLOSING  |ws.close()|&lt;--|close frame|&lt;--+-----+       CLOSING</span>
   <span class="s6">*          +----------+   +-----------+   |</span>
   <span class="s6">*    |           |                        |   +---+        |</span>
   <span class="s6">*                +------------------------+--&gt;|fin| - - - -</span>
   <span class="s6">*    |         +---+                      |   +---+</span>
   <span class="s6">*     - - - - -|fin|&lt;---------------------+</span>
   <span class="s6">*              +---+</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} [code] Status code explaining why the connection is closing</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{String} [data] A string explaining why the connection is closing</span>
   <span class="s6">* </span><span class="s7">@public</span>
   <span class="s6">*/</span>
  <span class="s1">close(code</span><span class="s3">, </span><span class="s1">data) {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState === WebSocket.CLOSED) </span><span class="s4">return</span><span class="s3">;</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState === WebSocket.CONNECTING) {</span>
      <span class="s4">const </span><span class="s1">msg = </span><span class="s2">'WebSocket was closed before the connection was established'</span><span class="s3">;</span>
      <span class="s4">return </span><span class="s1">abortHandshake(</span><span class="s4">this</span><span class="s3">, </span><span class="s4">this</span><span class="s1">._req</span><span class="s3">, </span><span class="s1">msg)</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState === WebSocket.CLOSING) {</span>
      <span class="s4">if </span><span class="s1">(</span>
        <span class="s4">this</span><span class="s1">._closeFrameSent &amp;&amp;</span>
        <span class="s1">(</span><span class="s4">this</span><span class="s1">._closeFrameReceived || </span><span class="s4">this</span><span class="s1">._receiver._writableState.errorEmitted)</span>
      <span class="s1">) {</span>
        <span class="s4">this</span><span class="s1">._socket.end()</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">this</span><span class="s1">._readyState = WebSocket.CLOSING</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._sender.close(code</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">!</span><span class="s4">this</span><span class="s1">._isServer</span><span class="s3">, </span><span class="s1">(err) =&gt; {</span>
      <span class="s8">//</span>
      <span class="s8">// This error is handled by the `'error'` listener on the socket. We only</span>
      <span class="s8">// want to know if the close frame has been sent here.</span>
      <span class="s8">//</span>
      <span class="s4">if </span><span class="s1">(err) </span><span class="s4">return</span><span class="s3">;</span>

      <span class="s4">this</span><span class="s1">._closeFrameSent = </span><span class="s4">true</span><span class="s3">;</span>

      <span class="s4">if </span><span class="s1">(</span>
        <span class="s4">this</span><span class="s1">._closeFrameReceived ||</span>
        <span class="s4">this</span><span class="s1">._receiver._writableState.errorEmitted</span>
      <span class="s1">) {</span>
        <span class="s4">this</span><span class="s1">._socket.end()</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">})</span><span class="s3">;</span>

    <span class="s8">//</span>
    <span class="s8">// Specify a timeout for the closing handshake to complete.</span>
    <span class="s8">//</span>
    <span class="s4">this</span><span class="s1">._closeTimer = setTimeout(</span>
      <span class="s4">this</span><span class="s1">._socket.destroy.bind(</span><span class="s4">this</span><span class="s1">._socket)</span><span class="s3">,</span>
      <span class="s1">closeTimeout</span>
    <span class="s1">)</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* Send a ping.</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{*} [data] The data to send</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Boolean} [mask] Indicates whether or not to mask `data`</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Function} [cb] Callback which is executed when the ping is sent</span>
   <span class="s6">* </span><span class="s7">@public</span>
   <span class="s6">*/</span>
  <span class="s1">ping(data</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">cb) {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState === WebSocket.CONNECTING) {</span>
      <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'WebSocket is not open: readyState 0 (CONNECTING)'</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">data === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">cb = data</span><span class="s3">;</span>
      <span class="s1">data = mask = undefined</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">mask === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">cb = mask</span><span class="s3">;</span>
      <span class="s1">mask = undefined</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">data === </span><span class="s2">'number'</span><span class="s1">) data = data.toString()</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState !== WebSocket.OPEN) {</span>
      <span class="s1">sendAfterClose(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">cb)</span><span class="s3">;</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(mask === undefined) mask = !</span><span class="s4">this</span><span class="s1">._isServer</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._sender.ping(data || EMPTY_BUFFER</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">cb)</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* Send a pong.</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{*} [data] The data to send</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Boolean} [mask] Indicates whether or not to mask `data`</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Function} [cb] Callback which is executed when the pong is sent</span>
   <span class="s6">* </span><span class="s7">@public</span>
   <span class="s6">*/</span>
  <span class="s1">pong(data</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">cb) {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState === WebSocket.CONNECTING) {</span>
      <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'WebSocket is not open: readyState 0 (CONNECTING)'</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">data === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">cb = data</span><span class="s3">;</span>
      <span class="s1">data = mask = undefined</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">mask === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">cb = mask</span><span class="s3">;</span>
      <span class="s1">mask = undefined</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">data === </span><span class="s2">'number'</span><span class="s1">) data = data.toString()</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState !== WebSocket.OPEN) {</span>
      <span class="s1">sendAfterClose(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">cb)</span><span class="s3">;</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(mask === undefined) mask = !</span><span class="s4">this</span><span class="s1">._isServer</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">._sender.pong(data || EMPTY_BUFFER</span><span class="s3">, </span><span class="s1">mask</span><span class="s3">, </span><span class="s1">cb)</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* Send a data message.</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{*} data The message to send</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Object} [options] Options object</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Boolean} [options.compress] Specifies whether or not to compress</span>
   <span class="s6">*     `data`</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Boolean} [options.binary] Specifies whether `data` is binary or</span>
   <span class="s6">*     text</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Boolean} [options.fin=true] Specifies whether the fragment is the</span>
   <span class="s6">*     last one</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Boolean} [options.mask] Specifies whether or not to mask `data`</span>
   <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Function} [cb] Callback which is executed when data is written out</span>
   <span class="s6">* </span><span class="s7">@public</span>
   <span class="s6">*/</span>
  <span class="s1">send(data</span><span class="s3">, </span><span class="s1">options</span><span class="s3">, </span><span class="s1">cb) {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState === WebSocket.CONNECTING) {</span>
      <span class="s4">throw new </span><span class="s1">Error(</span><span class="s2">'WebSocket is not open: readyState 0 (CONNECTING)'</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">options === </span><span class="s2">'function'</span><span class="s1">) {</span>
      <span class="s1">cb = options</span><span class="s3">;</span>
      <span class="s1">options = {}</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">typeof </span><span class="s1">data === </span><span class="s2">'number'</span><span class="s1">) data = data.toString()</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState !== WebSocket.OPEN) {</span>
      <span class="s1">sendAfterClose(</span><span class="s4">this</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">cb)</span><span class="s3">;</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">const </span><span class="s1">opts = {</span>
      <span class="s1">binary: </span><span class="s4">typeof </span><span class="s1">data !== </span><span class="s2">'string'</span><span class="s3">,</span>
      <span class="s1">mask: !</span><span class="s4">this</span><span class="s1">._isServer</span><span class="s3">,</span>
      <span class="s1">compress: </span><span class="s4">true</span><span class="s3">,</span>
      <span class="s1">fin: </span><span class="s4">true</span><span class="s3">,</span>
      <span class="s1">...options</span>
    <span class="s1">}</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">._extensions[PerMessageDeflate.extensionName]) {</span>
      <span class="s1">opts.compress = </span><span class="s4">false</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">this</span><span class="s1">._sender.send(data || EMPTY_BUFFER</span><span class="s3">, </span><span class="s1">opts</span><span class="s3">, </span><span class="s1">cb)</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s6">/**</span>
   <span class="s6">* Forcibly close the connection.</span>
   <span class="s6">*</span>
   <span class="s6">* </span><span class="s7">@public</span>
   <span class="s6">*/</span>
  <span class="s1">terminate() {</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState === WebSocket.CLOSED) </span><span class="s4">return</span><span class="s3">;</span>
    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">.readyState === WebSocket.CONNECTING) {</span>
      <span class="s4">const </span><span class="s1">msg = </span><span class="s2">'WebSocket was closed before the connection was established'</span><span class="s3">;</span>
      <span class="s4">return </span><span class="s1">abortHandshake(</span><span class="s4">this</span><span class="s3">, </span><span class="s4">this</span><span class="s1">._req</span><span class="s3">, </span><span class="s1">msg)</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(</span><span class="s4">this</span><span class="s1">._socket) {</span>
      <span class="s4">this</span><span class="s1">._readyState = WebSocket.CLOSING</span><span class="s3">;</span>
      <span class="s4">this</span><span class="s1">._socket.destroy()</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s7">@constant </span><span class="s6">{Number} CONNECTING</span>
 <span class="s6">* </span><span class="s7">@memberof </span><span class="s6">WebSocket</span>
 <span class="s6">*/</span>
<span class="s1">Object.defineProperty(WebSocket</span><span class="s3">, </span><span class="s2">'CONNECTING'</span><span class="s3">, </span><span class="s1">{</span>
  <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
  <span class="s1">value: readyStates.indexOf(</span><span class="s2">'CONNECTING'</span><span class="s1">)</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s7">@constant </span><span class="s6">{Number} CONNECTING</span>
 <span class="s6">* </span><span class="s7">@memberof </span><span class="s6">WebSocket.prototype</span>
 <span class="s6">*/</span>
<span class="s1">Object.defineProperty(WebSocket.prototype</span><span class="s3">, </span><span class="s2">'CONNECTING'</span><span class="s3">, </span><span class="s1">{</span>
  <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
  <span class="s1">value: readyStates.indexOf(</span><span class="s2">'CONNECTING'</span><span class="s1">)</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s7">@constant </span><span class="s6">{Number} OPEN</span>
 <span class="s6">* </span><span class="s7">@memberof </span><span class="s6">WebSocket</span>
 <span class="s6">*/</span>
<span class="s1">Object.defineProperty(WebSocket</span><span class="s3">, </span><span class="s2">'OPEN'</span><span class="s3">, </span><span class="s1">{</span>
  <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
  <span class="s1">value: readyStates.indexOf(</span><span class="s2">'OPEN'</span><span class="s1">)</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s7">@constant </span><span class="s6">{Number} OPEN</span>
 <span class="s6">* </span><span class="s7">@memberof </span><span class="s6">WebSocket.prototype</span>
 <span class="s6">*/</span>
<span class="s1">Object.defineProperty(WebSocket.prototype</span><span class="s3">, </span><span class="s2">'OPEN'</span><span class="s3">, </span><span class="s1">{</span>
  <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
  <span class="s1">value: readyStates.indexOf(</span><span class="s2">'OPEN'</span><span class="s1">)</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s7">@constant </span><span class="s6">{Number} CLOSING</span>
 <span class="s6">* </span><span class="s7">@memberof </span><span class="s6">WebSocket</span>
 <span class="s6">*/</span>
<span class="s1">Object.defineProperty(WebSocket</span><span class="s3">, </span><span class="s2">'CLOSING'</span><span class="s3">, </span><span class="s1">{</span>
  <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
  <span class="s1">value: readyStates.indexOf(</span><span class="s2">'CLOSING'</span><span class="s1">)</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s7">@constant </span><span class="s6">{Number} CLOSING</span>
 <span class="s6">* </span><span class="s7">@memberof </span><span class="s6">WebSocket.prototype</span>
 <span class="s6">*/</span>
<span class="s1">Object.defineProperty(WebSocket.prototype</span><span class="s3">, </span><span class="s2">'CLOSING'</span><span class="s3">, </span><span class="s1">{</span>
  <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
  <span class="s1">value: readyStates.indexOf(</span><span class="s2">'CLOSING'</span><span class="s1">)</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s7">@constant </span><span class="s6">{Number} CLOSED</span>
 <span class="s6">* </span><span class="s7">@memberof </span><span class="s6">WebSocket</span>
 <span class="s6">*/</span>
<span class="s1">Object.defineProperty(WebSocket</span><span class="s3">, </span><span class="s2">'CLOSED'</span><span class="s3">, </span><span class="s1">{</span>
  <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
  <span class="s1">value: readyStates.indexOf(</span><span class="s2">'CLOSED'</span><span class="s1">)</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* </span><span class="s7">@constant </span><span class="s6">{Number} CLOSED</span>
 <span class="s6">* </span><span class="s7">@memberof </span><span class="s6">WebSocket.prototype</span>
 <span class="s6">*/</span>
<span class="s1">Object.defineProperty(WebSocket.prototype</span><span class="s3">, </span><span class="s2">'CLOSED'</span><span class="s3">, </span><span class="s1">{</span>
  <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
  <span class="s1">value: readyStates.indexOf(</span><span class="s2">'CLOSED'</span><span class="s1">)</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s1">[</span>
  <span class="s2">'binaryType'</span><span class="s3">,</span>
  <span class="s2">'bufferedAmount'</span><span class="s3">,</span>
  <span class="s2">'extensions'</span><span class="s3">,</span>
  <span class="s2">'protocol'</span><span class="s3">,</span>
  <span class="s2">'readyState'</span><span class="s3">,</span>
  <span class="s2">'url'</span>
<span class="s1">].forEach((property) =&gt; {</span>
  <span class="s1">Object.defineProperty(WebSocket.prototype</span><span class="s3">, </span><span class="s1">property</span><span class="s3">, </span><span class="s1">{ enumerable: </span><span class="s4">true </span><span class="s1">})</span><span class="s3">;</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s8">//</span>
<span class="s8">// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.</span>
<span class="s8">// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface</span>
<span class="s8">//</span>
<span class="s1">[</span><span class="s2">'open'</span><span class="s3">, </span><span class="s2">'error'</span><span class="s3">, </span><span class="s2">'close'</span><span class="s3">, </span><span class="s2">'message'</span><span class="s1">].forEach((method) =&gt; {</span>
  <span class="s1">Object.defineProperty(WebSocket.prototype</span><span class="s3">, </span><span class="s2">`on</span><span class="s1">${method}</span><span class="s2">`</span><span class="s3">, </span><span class="s1">{</span>
    <span class="s1">enumerable: </span><span class="s4">true</span><span class="s3">,</span>
    <span class="s1">get() {</span>
      <span class="s4">const </span><span class="s1">listeners = </span><span class="s4">this</span><span class="s1">.listeners(method)</span><span class="s3">;</span>
      <span class="s4">for </span><span class="s1">(</span><span class="s4">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i &lt; listeners.length</span><span class="s3">; </span><span class="s1">i++) {</span>
        <span class="s4">if </span><span class="s1">(listeners[i]._listener) </span><span class="s4">return </span><span class="s1">listeners[i]._listener</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s4">return </span><span class="s1">undefined</span><span class="s3">;</span>
    <span class="s1">}</span><span class="s3">,</span>
    <span class="s1">set(listener) {</span>
      <span class="s4">const </span><span class="s1">listeners = </span><span class="s4">this</span><span class="s1">.listeners(method)</span><span class="s3">;</span>
      <span class="s4">for </span><span class="s1">(</span><span class="s4">let </span><span class="s1">i = </span><span class="s5">0</span><span class="s3">; </span><span class="s1">i &lt; listeners.length</span><span class="s3">; </span><span class="s1">i++) {</span>
        <span class="s8">//</span>
        <span class="s8">// Remove only the listeners added via `addEventListener`.</span>
        <span class="s8">//</span>
        <span class="s4">if </span><span class="s1">(listeners[i]._listener) </span><span class="s4">this</span><span class="s1">.removeListener(method</span><span class="s3">, </span><span class="s1">listeners[i])</span><span class="s3">;</span>
      <span class="s1">}</span>
      <span class="s4">this</span><span class="s1">.addEventListener(method</span><span class="s3">, </span><span class="s1">listener)</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s3">;</span>
<span class="s1">})</span><span class="s3">;</span>

<span class="s1">WebSocket.prototype.addEventListener = addEventListener</span><span class="s3">;</span>
<span class="s1">WebSocket.prototype.removeEventListener = removeEventListener</span><span class="s3">;</span>

<span class="s1">module.exports = WebSocket</span><span class="s3">;</span>

<span class="s6">/**</span>
 <span class="s6">* Initialize a WebSocket client.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{WebSocket} websocket The client to initialize</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{(String|URL)} address The URL to which to connect</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{String} [protocols] The subprotocols</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Object} [options] Connection options</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable</span>
 <span class="s6">*     permessage-deflate</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} [options.handshakeTimeout] Timeout in milliseconds for the</span>
 <span class="s6">*     handshake request</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} [options.protocolVersion=13] Value of the</span>
 <span class="s6">*     `Sec-WebSocket-Version` header</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{String} [options.origin] Value of the `Origin` or</span>
 <span class="s6">*     `Sec-WebSocket-Origin` header</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} [options.maxPayload=104857600] The maximum allowed message</span>
 <span class="s6">*     size</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Boolean} [options.followRedirects=false] Whether or not to follow</span>
 <span class="s6">*     redirects</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} [options.maxRedirects=10] The maximum number of redirects</span>
 <span class="s6">*     allowed</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">initAsClient(websocket</span><span class="s3">, </span><span class="s1">address</span><span class="s3">, </span><span class="s1">protocols</span><span class="s3">, </span><span class="s1">options) {</span>
  <span class="s4">const </span><span class="s1">opts = {</span>
    <span class="s1">protocolVersion: protocolVersions[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">,</span>
    <span class="s1">maxPayload: </span><span class="s5">100 </span><span class="s1">* </span><span class="s5">1024 </span><span class="s1">* </span><span class="s5">1024</span><span class="s3">,</span>
    <span class="s1">perMessageDeflate: </span><span class="s4">true</span><span class="s3">,</span>
    <span class="s1">followRedirects: </span><span class="s4">false</span><span class="s3">,</span>
    <span class="s1">maxRedirects: </span><span class="s5">10</span><span class="s3">,</span>
    <span class="s1">...options</span><span class="s3">,</span>
    <span class="s1">createConnection: undefined</span><span class="s3">,</span>
    <span class="s1">socketPath: undefined</span><span class="s3">,</span>
    <span class="s1">hostname: undefined</span><span class="s3">,</span>
    <span class="s1">protocol: undefined</span><span class="s3">,</span>
    <span class="s1">timeout: undefined</span><span class="s3">,</span>
    <span class="s1">method: undefined</span><span class="s3">,</span>
    <span class="s1">host: undefined</span><span class="s3">,</span>
    <span class="s1">path: undefined</span><span class="s3">,</span>
    <span class="s1">port: undefined</span>
  <span class="s1">}</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(!protocolVersions.includes(opts.protocolVersion)) {</span>
    <span class="s4">throw new </span><span class="s1">RangeError(</span>
      <span class="s2">`Unsupported protocol version: </span><span class="s1">${opts.protocolVersion} </span><span class="s2">` </span><span class="s1">+</span>
        <span class="s2">`(supported versions: </span><span class="s1">${protocolVersions.join(</span><span class="s2">', '</span><span class="s1">)}</span><span class="s2">)`</span>
    <span class="s1">)</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">let </span><span class="s1">parsedUrl</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(address </span><span class="s4">instanceof </span><span class="s1">URL) {</span>
    <span class="s1">parsedUrl = address</span><span class="s3">;</span>
    <span class="s1">websocket._url = address.href</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">parsedUrl = </span><span class="s4">new </span><span class="s1">URL(address)</span><span class="s3">;</span>
    <span class="s1">websocket._url = address</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">const </span><span class="s1">isUnixSocket = parsedUrl.protocol === </span><span class="s2">'ws+unix:'</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(!parsedUrl.host &amp;&amp; (!isUnixSocket || !parsedUrl.pathname)) {</span>
    <span class="s4">const </span><span class="s1">err = </span><span class="s4">new </span><span class="s1">Error(</span><span class="s2">`Invalid URL: </span><span class="s1">${websocket.url}</span><span class="s2">`</span><span class="s1">)</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(websocket._redirects === </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s4">throw </span><span class="s1">err</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">emitErrorAndClose(websocket</span><span class="s3">, </span><span class="s1">err)</span><span class="s3">;</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">const </span><span class="s1">isSecure =</span>
    <span class="s1">parsedUrl.protocol === </span><span class="s2">'wss:' </span><span class="s1">|| parsedUrl.protocol === </span><span class="s2">'https:'</span><span class="s3">;</span>
  <span class="s4">const </span><span class="s1">defaultPort = isSecure ? </span><span class="s5">443 </span><span class="s1">: </span><span class="s5">80</span><span class="s3">;</span>
  <span class="s4">const </span><span class="s1">key = randomBytes(</span><span class="s5">16</span><span class="s1">).toString(</span><span class="s2">'base64'</span><span class="s1">)</span><span class="s3">;</span>
  <span class="s4">const </span><span class="s1">get = isSecure ? https.get : http.get</span><span class="s3">;</span>
  <span class="s4">let </span><span class="s1">perMessageDeflate</span><span class="s3">;</span>

  <span class="s1">opts.createConnection = isSecure ? tlsConnect : netConnect</span><span class="s3">;</span>
  <span class="s1">opts.defaultPort = opts.defaultPort || defaultPort</span><span class="s3">;</span>
  <span class="s1">opts.port = parsedUrl.port || defaultPort</span><span class="s3">;</span>
  <span class="s1">opts.host = parsedUrl.hostname.startsWith(</span><span class="s2">'['</span><span class="s1">)</span>
    <span class="s1">? parsedUrl.hostname.slice(</span><span class="s5">1</span><span class="s3">, </span><span class="s1">-</span><span class="s5">1</span><span class="s1">)</span>
    <span class="s1">: parsedUrl.hostname</span><span class="s3">;</span>
  <span class="s1">opts.headers = {</span>
    <span class="s2">'Sec-WebSocket-Version'</span><span class="s1">: opts.protocolVersion</span><span class="s3">,</span>
    <span class="s2">'Sec-WebSocket-Key'</span><span class="s1">: key</span><span class="s3">,</span>
    <span class="s1">Connection: </span><span class="s2">'Upgrade'</span><span class="s3">,</span>
    <span class="s1">Upgrade: </span><span class="s2">'websocket'</span><span class="s3">,</span>
    <span class="s1">...opts.headers</span>
  <span class="s1">}</span><span class="s3">;</span>
  <span class="s1">opts.path = parsedUrl.pathname + parsedUrl.search</span><span class="s3">;</span>
  <span class="s1">opts.timeout = opts.handshakeTimeout</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(opts.perMessageDeflate) {</span>
    <span class="s1">perMessageDeflate = </span><span class="s4">new </span><span class="s1">PerMessageDeflate(</span>
      <span class="s1">opts.perMessageDeflate !== </span><span class="s4">true </span><span class="s1">? opts.perMessageDeflate : {}</span><span class="s3">,</span>
      <span class="s4">false</span><span class="s3">,</span>
      <span class="s1">opts.maxPayload</span>
    <span class="s1">)</span><span class="s3">;</span>
    <span class="s1">opts.headers[</span><span class="s2">'Sec-WebSocket-Extensions'</span><span class="s1">] = format({</span>
      <span class="s1">[PerMessageDeflate.extensionName]: perMessageDeflate.offer()</span>
    <span class="s1">})</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(protocols) {</span>
    <span class="s1">opts.headers[</span><span class="s2">'Sec-WebSocket-Protocol'</span><span class="s1">] = protocols</span><span class="s3">;</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(opts.origin) {</span>
    <span class="s4">if </span><span class="s1">(opts.protocolVersion &lt; </span><span class="s5">13</span><span class="s1">) {</span>
      <span class="s1">opts.headers[</span><span class="s2">'Sec-WebSocket-Origin'</span><span class="s1">] = opts.origin</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s1">opts.headers.Origin = opts.origin</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>
  <span class="s4">if </span><span class="s1">(parsedUrl.username || parsedUrl.password) {</span>
    <span class="s1">opts.auth = </span><span class="s2">`</span><span class="s1">${parsedUrl.username}</span><span class="s2">:</span><span class="s1">${parsedUrl.password}</span><span class="s2">`</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(isUnixSocket) {</span>
    <span class="s4">const </span><span class="s1">parts = opts.path.split(</span><span class="s2">':'</span><span class="s1">)</span><span class="s3">;</span>

    <span class="s1">opts.socketPath = parts[</span><span class="s5">0</span><span class="s1">]</span><span class="s3">;</span>
    <span class="s1">opts.path = parts[</span><span class="s5">1</span><span class="s1">]</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(opts.followRedirects) {</span>
    <span class="s4">if </span><span class="s1">(websocket._redirects === </span><span class="s5">0</span><span class="s1">) {</span>
      <span class="s1">websocket._originalUnixSocket = isUnixSocket</span><span class="s3">;</span>
      <span class="s1">websocket._originalSecure = isSecure</span><span class="s3">;</span>
      <span class="s1">websocket._originalHostOrSocketPath = isUnixSocket</span>
        <span class="s1">? opts.socketPath</span>
        <span class="s1">: parsedUrl.host</span><span class="s3">;</span>

      <span class="s4">const </span><span class="s1">headers = options &amp;&amp; options.headers</span><span class="s3">;</span>

      <span class="s8">//</span>
      <span class="s8">// Shallow copy the user provided options so that headers can be changed</span>
      <span class="s8">// without mutating the original object.</span>
      <span class="s8">//</span>
      <span class="s1">options = { ...options</span><span class="s3">, </span><span class="s1">headers: {} }</span><span class="s3">;</span>

      <span class="s4">if </span><span class="s1">(headers) {</span>
        <span class="s4">for </span><span class="s1">(</span><span class="s4">const </span><span class="s1">[key</span><span class="s3">, </span><span class="s1">value] of Object.entries(headers)) {</span>
          <span class="s1">options.headers[key.toLowerCase()] = value</span><span class="s3">;</span>
        <span class="s1">}</span>
      <span class="s1">}</span>
    <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
      <span class="s4">const </span><span class="s1">isSameHost = isUnixSocket</span>
        <span class="s1">? websocket._originalUnixSocket</span>
          <span class="s1">? opts.socketPath === websocket._originalHostOrSocketPath</span>
          <span class="s1">: </span><span class="s4">false</span>
        <span class="s1">: websocket._originalUnixSocket</span>
        <span class="s1">? </span><span class="s4">false</span>
        <span class="s1">: parsedUrl.host === websocket._originalHostOrSocketPath</span><span class="s3">;</span>

      <span class="s4">if </span><span class="s1">(!isSameHost || (websocket._originalSecure &amp;&amp; !isSecure)) {</span>
        <span class="s8">//</span>
        <span class="s8">// Match curl 7.77.0 behavior and drop the following headers. These</span>
        <span class="s8">// headers are also dropped when following a redirect to a subdomain.</span>
        <span class="s8">//</span>
        <span class="s4">delete </span><span class="s1">opts.headers.authorization</span><span class="s3">;</span>
        <span class="s4">delete </span><span class="s1">opts.headers.cookie</span><span class="s3">;</span>

        <span class="s4">if </span><span class="s1">(!isSameHost) </span><span class="s4">delete </span><span class="s1">opts.headers.host</span><span class="s3">;</span>

        <span class="s1">opts.auth = undefined</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s8">//</span>
    <span class="s8">// Match curl 7.77.0 behavior and make the first `Authorization` header win.</span>
    <span class="s8">// If the `Authorization` header is set, then there is nothing to do as it</span>
    <span class="s8">// will take precedence.</span>
    <span class="s8">//</span>
    <span class="s4">if </span><span class="s1">(opts.auth &amp;&amp; !options.headers.authorization) {</span>
      <span class="s1">options.headers.authorization =</span>
        <span class="s2">'Basic ' </span><span class="s1">+ Buffer.from(opts.auth).toString(</span><span class="s2">'base64'</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">}</span>

  <span class="s4">let </span><span class="s1">req = (websocket._req = get(opts))</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(opts.timeout) {</span>
    <span class="s1">req.on(</span><span class="s2">'timeout'</span><span class="s3">, </span><span class="s1">() =&gt; {</span>
      <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s2">'Opening handshake has timed out'</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s1">})</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">req.on(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">(err) =&gt; {</span>
    <span class="s4">if </span><span class="s1">(req === </span><span class="s4">null </span><span class="s1">|| req.aborted) </span><span class="s4">return</span><span class="s3">;</span>

    <span class="s1">req = websocket._req = </span><span class="s4">null</span><span class="s3">;</span>
    <span class="s1">emitErrorAndClose(websocket</span><span class="s3">, </span><span class="s1">err)</span><span class="s3">;</span>
  <span class="s1">})</span><span class="s3">;</span>

  <span class="s1">req.on(</span><span class="s2">'response'</span><span class="s3">, </span><span class="s1">(res) =&gt; {</span>
    <span class="s4">const </span><span class="s1">location = res.headers.location</span><span class="s3">;</span>
    <span class="s4">const </span><span class="s1">statusCode = res.statusCode</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(</span>
      <span class="s1">location &amp;&amp;</span>
      <span class="s1">opts.followRedirects &amp;&amp;</span>
      <span class="s1">statusCode &gt;= </span><span class="s5">300 </span><span class="s1">&amp;&amp;</span>
      <span class="s1">statusCode &lt; </span><span class="s5">400</span>
    <span class="s1">) {</span>
      <span class="s4">if </span><span class="s1">(++websocket._redirects &gt; opts.maxRedirects) {</span>
        <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s2">'Maximum redirects exceeded'</span><span class="s1">)</span><span class="s3">;</span>
        <span class="s4">return</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s1">req.abort()</span><span class="s3">;</span>

      <span class="s4">let </span><span class="s1">addr</span><span class="s3">;</span>

      <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">addr = </span><span class="s4">new </span><span class="s1">URL(location</span><span class="s3">, </span><span class="s1">address)</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s4">catch </span><span class="s1">(err) {</span>
        <span class="s1">emitErrorAndClose(websocket</span><span class="s3">, </span><span class="s1">err)</span><span class="s3">;</span>
        <span class="s4">return</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s1">initAsClient(websocket</span><span class="s3">, </span><span class="s1">addr</span><span class="s3">, </span><span class="s1">protocols</span><span class="s3">, </span><span class="s1">options)</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(!websocket.emit(</span><span class="s2">'unexpected-response'</span><span class="s3">, </span><span class="s1">req</span><span class="s3">, </span><span class="s1">res)) {</span>
      <span class="s1">abortHandshake(</span>
        <span class="s1">websocket</span><span class="s3">,</span>
        <span class="s1">req</span><span class="s3">,</span>
        <span class="s2">`Unexpected server response: </span><span class="s1">${res.statusCode}</span><span class="s2">`</span>
      <span class="s1">)</span><span class="s3">;</span>
    <span class="s1">}</span>
  <span class="s1">})</span><span class="s3">;</span>

  <span class="s1">req.on(</span><span class="s2">'upgrade'</span><span class="s3">, </span><span class="s1">(res</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, </span><span class="s1">head) =&gt; {</span>
    <span class="s1">websocket.emit(</span><span class="s2">'upgrade'</span><span class="s3">, </span><span class="s1">res)</span><span class="s3">;</span>

    <span class="s8">//</span>
    <span class="s8">// The user may have closed the connection from a listener of the `upgrade`</span>
    <span class="s8">// event.</span>
    <span class="s8">//</span>
    <span class="s4">if </span><span class="s1">(websocket.readyState !== WebSocket.CONNECTING) </span><span class="s4">return</span><span class="s3">;</span>

    <span class="s1">req = websocket._req = </span><span class="s4">null</span><span class="s3">;</span>

    <span class="s4">const </span><span class="s1">upgrade = res.headers.upgrade</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(upgrade === undefined || upgrade.toLowerCase() !== </span><span class="s2">'websocket'</span><span class="s1">) {</span>
      <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, </span><span class="s2">'Invalid Upgrade header'</span><span class="s1">)</span><span class="s3">;</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">const </span><span class="s1">digest = createHash(</span><span class="s2">'sha1'</span><span class="s1">)</span>
      <span class="s1">.update(key + GUID)</span>
      <span class="s1">.digest(</span><span class="s2">'base64'</span><span class="s1">)</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(res.headers[</span><span class="s2">'sec-websocket-accept'</span><span class="s1">] !== digest) {</span>
      <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, </span><span class="s2">'Invalid Sec-WebSocket-Accept header'</span><span class="s1">)</span><span class="s3">;</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">const </span><span class="s1">serverProt = res.headers[</span><span class="s2">'sec-websocket-protocol'</span><span class="s1">]</span><span class="s3">;</span>
    <span class="s4">const </span><span class="s1">protList = (protocols || </span><span class="s2">''</span><span class="s1">).split(</span><span class="s5">/, */</span><span class="s1">)</span><span class="s3">;</span>
    <span class="s4">let </span><span class="s1">protError</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(!protocols &amp;&amp; serverProt) {</span>
      <span class="s1">protError = </span><span class="s2">'Server sent a subprotocol but none was requested'</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(protocols &amp;&amp; !serverProt) {</span>
      <span class="s1">protError = </span><span class="s2">'Server sent no subprotocol'</span><span class="s3">;</span>
    <span class="s1">} </span><span class="s4">else if </span><span class="s1">(serverProt &amp;&amp; !protList.includes(serverProt)) {</span>
      <span class="s1">protError = </span><span class="s2">'Server sent an invalid subprotocol'</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(protError) {</span>
      <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, </span><span class="s1">protError)</span><span class="s3">;</span>
      <span class="s4">return</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s4">if </span><span class="s1">(serverProt) websocket._protocol = serverProt</span><span class="s3">;</span>

    <span class="s4">const </span><span class="s1">secWebSocketExtensions = res.headers[</span><span class="s2">'sec-websocket-extensions'</span><span class="s1">]</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(secWebSocketExtensions !== undefined) {</span>
      <span class="s4">if </span><span class="s1">(!perMessageDeflate) {</span>
        <span class="s4">const </span><span class="s1">message =</span>
          <span class="s2">'Server sent a Sec-WebSocket-Extensions header but no extension ' </span><span class="s1">+</span>
          <span class="s2">'was requested'</span><span class="s3">;</span>
        <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, </span><span class="s1">message)</span><span class="s3">;</span>
        <span class="s4">return</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s4">let </span><span class="s1">extensions</span><span class="s3">;</span>

      <span class="s4">try </span><span class="s1">{</span>
        <span class="s1">extensions = parse(secWebSocketExtensions)</span><span class="s3">;</span>
      <span class="s1">} </span><span class="s4">catch </span><span class="s1">(err) {</span>
        <span class="s4">const </span><span class="s1">message = </span><span class="s2">'Invalid Sec-WebSocket-Extensions header'</span><span class="s3">;</span>
        <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, </span><span class="s1">message)</span><span class="s3">;</span>
        <span class="s4">return</span><span class="s3">;</span>
      <span class="s1">}</span>

      <span class="s4">const </span><span class="s1">extensionNames = Object.keys(extensions)</span><span class="s3">;</span>

      <span class="s4">if </span><span class="s1">(extensionNames.length) {</span>
        <span class="s4">if </span><span class="s1">(</span>
          <span class="s1">extensionNames.length !== </span><span class="s5">1 </span><span class="s1">||</span>
          <span class="s1">extensionNames[</span><span class="s5">0</span><span class="s1">] !== PerMessageDeflate.extensionName</span>
        <span class="s1">) {</span>
          <span class="s4">const </span><span class="s1">message =</span>
            <span class="s2">'Server indicated an extension that was not requested'</span><span class="s3">;</span>
          <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, </span><span class="s1">message)</span><span class="s3">;</span>
          <span class="s4">return</span><span class="s3">;</span>
        <span class="s1">}</span>

        <span class="s4">try </span><span class="s1">{</span>
          <span class="s1">perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName])</span><span class="s3">;</span>
        <span class="s1">} </span><span class="s4">catch </span><span class="s1">(err) {</span>
          <span class="s4">const </span><span class="s1">message = </span><span class="s2">'Invalid Sec-WebSocket-Extensions header'</span><span class="s3">;</span>
          <span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">socket</span><span class="s3">, </span><span class="s1">message)</span><span class="s3">;</span>
          <span class="s4">return</span><span class="s3">;</span>
        <span class="s1">}</span>

        <span class="s1">websocket._extensions[PerMessageDeflate.extensionName] =</span>
          <span class="s1">perMessageDeflate</span><span class="s3">;</span>
      <span class="s1">}</span>
    <span class="s1">}</span>

    <span class="s1">websocket.setSocket(socket</span><span class="s3">, </span><span class="s1">head</span><span class="s3">, </span><span class="s1">opts.maxPayload)</span><span class="s3">;</span>
  <span class="s1">})</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Emit the `'error'` and `'close'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{WebSocket} websocket The WebSocket instance</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Error} The error to emit</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">emitErrorAndClose(websocket</span><span class="s3">, </span><span class="s1">err) {</span>
  <span class="s1">websocket._readyState = WebSocket.CLOSING</span><span class="s3">;</span>
  <span class="s1">websocket.emit(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">err)</span><span class="s3">;</span>
  <span class="s1">websocket.emitClose()</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Create a `net.Socket` and initiate a connection.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Object} options Connection options</span>
 <span class="s6">* </span><span class="s7">@return </span><span class="s6">{net.Socket} The newly created socket used to start the connection</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">netConnect(options) {</span>
  <span class="s1">options.path = options.socketPath</span><span class="s3">;</span>
  <span class="s4">return </span><span class="s1">net.connect(options)</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Create a `tls.TLSSocket` and initiate a connection.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Object} options Connection options</span>
 <span class="s6">* </span><span class="s7">@return </span><span class="s6">{tls.TLSSocket} The newly created socket used to start the connection</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">tlsConnect(options) {</span>
  <span class="s1">options.path = undefined</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(!options.servername &amp;&amp; options.servername !== </span><span class="s2">''</span><span class="s1">) {</span>
    <span class="s1">options.servername = net.isIP(options.host) ? </span><span class="s2">'' </span><span class="s1">: options.host</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">return </span><span class="s1">tls.connect(options)</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Abort the handshake and emit an error.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{WebSocket} websocket The WebSocket instance</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{(http.ClientRequest|net.Socket|tls.Socket)} stream The request to</span>
 <span class="s6">*     abort or the socket to destroy</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{String} message The error message</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">abortHandshake(websocket</span><span class="s3">, </span><span class="s1">stream</span><span class="s3">, </span><span class="s1">message) {</span>
  <span class="s1">websocket._readyState = WebSocket.CLOSING</span><span class="s3">;</span>

  <span class="s4">const </span><span class="s1">err = </span><span class="s4">new </span><span class="s1">Error(message)</span><span class="s3">;</span>
  <span class="s1">Error.captureStackTrace(err</span><span class="s3">, </span><span class="s1">abortHandshake)</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(stream.setHeader) {</span>
    <span class="s1">stream.abort()</span><span class="s3">;</span>

    <span class="s4">if </span><span class="s1">(stream.socket &amp;&amp; !stream.socket.destroyed) {</span>
      <span class="s8">//</span>
      <span class="s8">// On Node.js &gt;= 14.3.0 `request.abort()` does not destroy the socket if</span>
      <span class="s8">// called after the request completed. See</span>
      <span class="s8">// https://github.com/websockets/ws/issues/1869.</span>
      <span class="s8">//</span>
      <span class="s1">stream.socket.destroy()</span><span class="s3">;</span>
    <span class="s1">}</span>

    <span class="s1">stream.once(</span><span class="s2">'abort'</span><span class="s3">, </span><span class="s1">websocket.emitClose.bind(websocket))</span><span class="s3">;</span>
    <span class="s1">websocket.emit(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">err)</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">stream.destroy(err)</span><span class="s3">;</span>
    <span class="s1">stream.once(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">websocket.emit.bind(websocket</span><span class="s3">, </span><span class="s2">'error'</span><span class="s1">))</span><span class="s3">;</span>
    <span class="s1">stream.once(</span><span class="s2">'close'</span><span class="s3">, </span><span class="s1">websocket.emitClose.bind(websocket))</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Handle cases where the `ping()`, `pong()`, or `send()` methods are called</span>
 <span class="s6">* when the `readyState` attribute is `CLOSING` or `CLOSED`.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{WebSocket} websocket The WebSocket instance</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{*} [data] The data to send</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Function} [cb] Callback</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">sendAfterClose(websocket</span><span class="s3">, </span><span class="s1">data</span><span class="s3">, </span><span class="s1">cb) {</span>
  <span class="s4">if </span><span class="s1">(data) {</span>
    <span class="s4">const </span><span class="s1">length = toBuffer(data).length</span><span class="s3">;</span>

    <span class="s8">//</span>
    <span class="s8">// The `_bufferedAmount` property is used only when the peer is a client and</span>
    <span class="s8">// the opening handshake fails. Under these circumstances, in fact, the</span>
    <span class="s8">// `setSocket()` method is not called, so the `_socket` and `_sender`</span>
    <span class="s8">// properties are set to `null`.</span>
    <span class="s8">//</span>
    <span class="s4">if </span><span class="s1">(websocket._socket) websocket._sender._bufferedBytes += length</span><span class="s3">;</span>
    <span class="s4">else </span><span class="s1">websocket._bufferedAmount += length</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s4">if </span><span class="s1">(cb) {</span>
    <span class="s4">const </span><span class="s1">err = </span><span class="s4">new </span><span class="s1">Error(</span>
      <span class="s2">`WebSocket is not open: readyState </span><span class="s1">${websocket.readyState} </span><span class="s2">` </span><span class="s1">+</span>
        <span class="s2">`(</span><span class="s1">${readyStates[websocket.readyState]}</span><span class="s2">)`</span>
    <span class="s1">)</span><span class="s3">;</span>
    <span class="s1">cb(err)</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `Receiver` `'conclude'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Number} code The status code</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{String} reason The reason for closing</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">receiverOnConclude(code</span><span class="s3">, </span><span class="s1">reason) {</span>
  <span class="s4">const </span><span class="s1">websocket = </span><span class="s4">this</span><span class="s1">[kWebSocket]</span><span class="s3">;</span>

  <span class="s1">websocket._closeFrameReceived = </span><span class="s4">true</span><span class="s3">;</span>
  <span class="s1">websocket._closeMessage = reason</span><span class="s3">;</span>
  <span class="s1">websocket._closeCode = code</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(websocket._socket[kWebSocket] === undefined) </span><span class="s4">return</span><span class="s3">;</span>

  <span class="s1">websocket._socket.removeListener(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s1">socketOnData)</span><span class="s3">;</span>
  <span class="s1">process.nextTick(resume</span><span class="s3">, </span><span class="s1">websocket._socket)</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(code === </span><span class="s5">1005</span><span class="s1">) websocket.close()</span><span class="s3">;</span>
  <span class="s4">else </span><span class="s1">websocket.close(code</span><span class="s3">, </span><span class="s1">reason)</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `Receiver` `'drain'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">receiverOnDrain() {</span>
  <span class="s4">this</span><span class="s1">[kWebSocket]._socket.resume()</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `Receiver` `'error'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{(RangeError|Error)} err The emitted error</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">receiverOnError(err) {</span>
  <span class="s4">const </span><span class="s1">websocket = </span><span class="s4">this</span><span class="s1">[kWebSocket]</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(websocket._socket[kWebSocket] !== undefined) {</span>
    <span class="s1">websocket._socket.removeListener(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s1">socketOnData)</span><span class="s3">;</span>

    <span class="s8">//</span>
    <span class="s8">// On Node.js &lt; 14.0.0 the `'error'` event is emitted synchronously. See</span>
    <span class="s8">// https://github.com/websockets/ws/issues/1940.</span>
    <span class="s8">//</span>
    <span class="s1">process.nextTick(resume</span><span class="s3">, </span><span class="s1">websocket._socket)</span><span class="s3">;</span>

    <span class="s1">websocket.close(err[kStatusCode])</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">websocket.emit(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">err)</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `Receiver` `'finish'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">receiverOnFinish() {</span>
  <span class="s4">this</span><span class="s1">[kWebSocket].emitClose()</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `Receiver` `'message'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{(String|Buffer|ArrayBuffer|Buffer[])} data The message</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">receiverOnMessage(data) {</span>
  <span class="s4">this</span><span class="s1">[kWebSocket].emit(</span><span class="s2">'message'</span><span class="s3">, </span><span class="s1">data)</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `Receiver` `'ping'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Buffer} data The data included in the ping frame</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">receiverOnPing(data) {</span>
  <span class="s4">const </span><span class="s1">websocket = </span><span class="s4">this</span><span class="s1">[kWebSocket]</span><span class="s3">;</span>

  <span class="s1">websocket.pong(data</span><span class="s3">, </span><span class="s1">!websocket._isServer</span><span class="s3">, </span><span class="s1">NOOP)</span><span class="s3">;</span>
  <span class="s1">websocket.emit(</span><span class="s2">'ping'</span><span class="s3">, </span><span class="s1">data)</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `Receiver` `'pong'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Buffer} data The data included in the pong frame</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">receiverOnPong(data) {</span>
  <span class="s4">this</span><span class="s1">[kWebSocket].emit(</span><span class="s2">'pong'</span><span class="s3">, </span><span class="s1">data)</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* Resume a readable stream</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Readable} stream The readable stream</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">resume(stream) {</span>
  <span class="s1">stream.resume()</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `net.Socket` `'close'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">socketOnClose() {</span>
  <span class="s4">const </span><span class="s1">websocket = </span><span class="s4">this</span><span class="s1">[kWebSocket]</span><span class="s3">;</span>

  <span class="s4">this</span><span class="s1">.removeListener(</span><span class="s2">'close'</span><span class="s3">, </span><span class="s1">socketOnClose)</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s1">.removeListener(</span><span class="s2">'data'</span><span class="s3">, </span><span class="s1">socketOnData)</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s1">.removeListener(</span><span class="s2">'end'</span><span class="s3">, </span><span class="s1">socketOnEnd)</span><span class="s3">;</span>

  <span class="s1">websocket._readyState = WebSocket.CLOSING</span><span class="s3">;</span>

  <span class="s4">let </span><span class="s1">chunk</span><span class="s3">;</span>

  <span class="s8">//</span>
  <span class="s8">// The close frame might not have been received or the `'end'` event emitted,</span>
  <span class="s8">// for example, if the socket was destroyed due to an error. Ensure that the</span>
  <span class="s8">// `receiver` stream is closed after writing any remaining buffered data to</span>
  <span class="s8">// it. If the readable side of the socket is in flowing mode then there is no</span>
  <span class="s8">// buffered data as everything has been already written and `readable.read()`</span>
  <span class="s8">// will return `null`. If instead, the socket is paused, any possible buffered</span>
  <span class="s8">// data will be read as a single chunk.</span>
  <span class="s8">//</span>
  <span class="s4">if </span><span class="s1">(</span>
    <span class="s1">!</span><span class="s4">this</span><span class="s1">._readableState.endEmitted &amp;&amp;</span>
    <span class="s1">!websocket._closeFrameReceived &amp;&amp;</span>
    <span class="s1">!websocket._receiver._writableState.errorEmitted &amp;&amp;</span>
    <span class="s1">(chunk = websocket._socket.read()) !== </span><span class="s4">null</span>
  <span class="s1">) {</span>
    <span class="s1">websocket._receiver.write(chunk)</span><span class="s3">;</span>
  <span class="s1">}</span>

  <span class="s1">websocket._receiver.end()</span><span class="s3">;</span>

  <span class="s4">this</span><span class="s1">[kWebSocket] = undefined</span><span class="s3">;</span>

  <span class="s1">clearTimeout(websocket._closeTimer)</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(</span>
    <span class="s1">websocket._receiver._writableState.finished ||</span>
    <span class="s1">websocket._receiver._writableState.errorEmitted</span>
  <span class="s1">) {</span>
    <span class="s1">websocket.emitClose()</span><span class="s3">;</span>
  <span class="s1">} </span><span class="s4">else </span><span class="s1">{</span>
    <span class="s1">websocket._receiver.on(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">receiverOnFinish)</span><span class="s3">;</span>
    <span class="s1">websocket._receiver.on(</span><span class="s2">'finish'</span><span class="s3">, </span><span class="s1">receiverOnFinish)</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `net.Socket` `'data'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@param </span><span class="s6">{Buffer} chunk A chunk of data</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">socketOnData(chunk) {</span>
  <span class="s4">if </span><span class="s1">(!</span><span class="s4">this</span><span class="s1">[kWebSocket]._receiver.write(chunk)) {</span>
    <span class="s4">this</span><span class="s1">.pause()</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `net.Socket` `'end'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">socketOnEnd() {</span>
  <span class="s4">const </span><span class="s1">websocket = </span><span class="s4">this</span><span class="s1">[kWebSocket]</span><span class="s3">;</span>

  <span class="s1">websocket._readyState = WebSocket.CLOSING</span><span class="s3">;</span>
  <span class="s1">websocket._receiver.end()</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s1">.end()</span><span class="s3">;</span>
<span class="s1">}</span>

<span class="s6">/**</span>
 <span class="s6">* The listener of the `net.Socket` `'error'` event.</span>
 <span class="s6">*</span>
 <span class="s6">* </span><span class="s7">@private</span>
 <span class="s6">*/</span>
<span class="s4">function </span><span class="s1">socketOnError() {</span>
  <span class="s4">const </span><span class="s1">websocket = </span><span class="s4">this</span><span class="s1">[kWebSocket]</span><span class="s3">;</span>

  <span class="s4">this</span><span class="s1">.removeListener(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">socketOnError)</span><span class="s3">;</span>
  <span class="s4">this</span><span class="s1">.on(</span><span class="s2">'error'</span><span class="s3">, </span><span class="s1">NOOP)</span><span class="s3">;</span>

  <span class="s4">if </span><span class="s1">(websocket) {</span>
    <span class="s1">websocket._readyState = WebSocket.CLOSING</span><span class="s3">;</span>
    <span class="s4">this</span><span class="s1">.destroy()</span><span class="s3">;</span>
  <span class="s1">}</span>
<span class="s1">}</span>
</pre>
</body>
</html>